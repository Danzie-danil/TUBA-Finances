<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- Favicon and App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="tuba-icon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="167x167" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="120x120" href="tuba-icon.png">
    <link rel="apple-touch-icon-precomposed" href="tuba-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="tuba-icon.png">
    <link rel="icon" type="image/png" sizes="512x512" href="tuba-icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TUBA">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="format-detection" content="telephone=no">
    <title>TUBA</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Mobile-specific enhancements */
        html {
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            padding-bottom: 70px;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        /* Removed in-app pull-to-refresh styles */

        /* Enhanced touch interactions */
        button,
        .btn,
        .nav-item,
        .stat-card,
        .item,
        .quick-nav-btn {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
        }

        /* Improved button feedback for mobile */
        button:active,
        .btn:active,
        .nav-item:active,
        .stat-card:active {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        /* Safe area support for notched devices */
        .header {
            padding-top: max(16px, env(safe-area-inset-top));
            padding-left: max(16px, env(safe-area-inset-left));
            padding-right: max(16px, env(safe-area-inset-right));
        }

        .bottom-nav {
            /* Extra breathing room to avoid iPhone home indicator overlap */
            padding-top: 8px;
            padding-bottom: calc(max(0px, env(safe-area-inset-bottom)) + 16px);
            padding-left: max(0px, env(safe-area-inset-left));
            padding-right: max(0px, env(safe-area-inset-right));
        }

        /* Offline banner (non-overlay, sits between header and content) */
        .offline-banner {
            display: none;
            width: 100%;
            background: linear-gradient(145deg, #b71c1c, #7f0000);
            color: #ffffff;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        }

        .offline-banner.clickable {
            cursor: pointer;
        }

        /* Auth banner (same style, clickable) */
        .auth-banner {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            cursor: pointer;
        }

        /* FAB (Floating Action Button) and radial tabs */
        .fab-container {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 8px;
            /* above bottom nav */
            z-index: 1000;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            background: linear-gradient(145deg, #7b1fa2, #4a148c);
        }

        .fab:active {
            transform: scale(0.98);
        }

        /* FAB hint: subtle pulsing ring to indicate tap */
        .fab.hint::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 72px;
            height: 72px;
            border-radius: 50%;
            box-shadow: 0 0 0 0 rgba(123, 31, 162, 0.5);
            animation: fab-pulse 1.8s ease-out infinite;
        }

        @keyframes fab-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(123, 31, 162, 0.45);
            }

            70% {
                box-shadow: 0 0 0 14px rgba(123, 31, 162, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(123, 31, 162, 0);
            }
        }

        .fab-menu {
            position: absolute;
            left: 50%;
            bottom: 28px;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            pointer-events: none;
            /* enable items only when open */
        }

        .fab-item {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: none;
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            transform: translate(0, 0) scale(0.6);
            opacity: 0;
            transition: transform 0.35s cubic-bezier(.2, .8, .2, 1), opacity 0.25s ease-out;
            overflow: visible;
        }

        .fab-icon {
            pointer-events: none;
            color: #fff;
        }

        .fab-label {
            position: absolute;
            top: 52px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            font-weight: 600;
            color: #222;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px 6px;
            border-radius: 10px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            max-width: 96px;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 2;
        }

        .fab-item:hover {
            filter: brightness(1.05);
        }

        .fab-container.open .fab-menu {
            pointer-events: auto;
        }

        .fab-container.open .fab-item {
            opacity: 1;
            transform: scale(1);
        }

        @keyframes fab-spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .fab-container.open .fab {
            animation: fab-spin 0.6s ease-out;
        }

        /* Splash screen styles */
        .privacy-blur {
            filter: blur(8px);
            -webkit-filter: blur(8px);
            transition: filter 0.3s ease;
        }

        /* Hide legacy bottom nav in favor of FAB menu */
        .bottom-nav {
            display: none;
        }

        .privacy-toggle-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4), inset 0 -1px 2px rgba(0, 0, 0, 0.2);
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .privacy-toggle-btn.show {
            display: flex;
        }

        .privacy-toggle-btn:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6), inset 0 -1px 2px rgba(0, 0, 0, 0.2);
        }

        .privacy-toggle-btn:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        .privacy-container {
            position: relative;
            margin-bottom: 12px;
        }

        input[readonly] {
            background: rgba(0, 0, 0, 0.05);
            cursor: not-allowed;
            color: #666;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            padding-bottom: 70px;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(145deg, #1a1a1a, #000000);
            color: white;
            padding: 16px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: max(16px, env(safe-area-inset-top));
            padding-left: max(16px, env(safe-area-inset-left));
            padding-right: max(16px, env(safe-area-inset-right));
        }

        .header h1 {
            font-size: 15px;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .header-btn {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(46, 125, 50, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .header-btn:hover {
            box-shadow: 0 6px 20px rgba(46, 125, 50, 0.6), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        .header-btn:active {
            transform: translateY(-50%) scale(0.95);
            box-shadow: 0 2px 10px rgba(46, 125, 50, 0.4), inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .header-btn-left {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        .header-btn-left:hover {
            box-shadow: 0 6px 20px rgba(25, 118, 210, 0.6), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        .header-btn-left:active {
            transform: translateY(-50%) scale(0.95);
            box-shadow: 0 2px 10px rgba(25, 118, 210, 0.4), inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .content {
            padding: 16px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .stat-card {
            background: linear-gradient(145deg, #1a1a1a, #000000);
            color: white;
            padding: 16px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.8;
            margin-bottom: 4px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 22px;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .stat-subvalue {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 4px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 14px;
            margin-bottom: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 3px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
            position: relative;
        }

        .card:hover {
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .card h2 {
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #1a1a1a;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .card-header-buttons {
            position: absolute;
            right: 14px;
            top: 14px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .quick-nav-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.18), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        .quick-nav-btn:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .quick-nav-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .quick-nav-btn.products {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
        }

        .quick-nav-btn.categories {
            background: linear-gradient(145deg, #e65100, #bf360c);
        }

        .quick-nav-btn.back {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1), inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        button,
        .btn {
            width: 100%;
            padding: 11px;
            background: linear-gradient(145deg, #1a1a1a, #000000);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            box-shadow: 0 5px 16px rgba(0, 0, 0, 0.28), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #757575, #424242);
        }

        .btn-success {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
        }

        .btn-danger {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
        }

        .btn-small {
            padding: 8px 12px;
            font-size: 13px;
            width: auto;
        }

        .item {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.07),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .item:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .item-title {
            font-weight: 700;
            font-size: 15px;
            color: #1a1a1a;
        }

        .item-subtitle {
            font-size: 13px;
            color: #666;
            margin-top: 4px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            display: inline-block;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .badge-success {
            background: linear-gradient(145deg, #66bb6a, #43a047);
            color: white;
        }

        .badge-warning {
            background: linear-gradient(145deg, #ffeb3b, #fbc02d);
            color: #333;
        }

        .badge-danger {
            background: linear-gradient(145deg, #ef5350, #c62828);
            color: white;
        }

        .badge-paid {
            background: linear-gradient(145deg, #66bb6a, #43a047);
            color: white;
        }

        .badge-unpaid {
            background: linear-gradient(145deg, #ef5350, #c62828);
            color: white;
        }

        .badge-mpesa {
            background: linear-gradient(145deg, #ef5350, #c62828);
            color: white;
        }

        .badge-crdb {
            background: linear-gradient(145deg, #66bb6a, #43a047);
            color: white;
        }

        .badge-nmb {
            background: linear-gradient(145deg, #ff9800, #e65100);
            color: white;
        }

        .badge-yas {
            background: linear-gradient(145deg, #42a5f5, #1976d2);
            color: white;
        }

        .badge-airtel {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
            color: white;
        }

        .badge-halopesa {
            background: linear-gradient(145deg, #ffeb3b, #fbc02d);
            color: #333;
        }

        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            overflow-x: auto;
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.15);
            z-index: 100;
            padding-bottom: max(0px, env(safe-area-inset-bottom));
            padding-left: max(0px, env(safe-area-inset-left));
            padding-right: max(0px, env(safe-area-inset-right));
        }

        .nav-item {
            flex: 1;
            min-width: 70px;
            max-width: 90px;
            padding: 10px 4px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #666;
            font-size: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            word-wrap: break-word;
            overflow: hidden;
        }

        .nav-item span:last-child {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }

        .nav-item.active {
            background: linear-gradient(145deg, #1a1a1a, #000000);
            color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .nav-item:hover:not(.active) {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }

        .nav-icon {
            font-size: 20px;
        }

        .info-box {
            background: linear-gradient(145deg, #f5f5f5, #e0e0e0);
            padding: 12px;
            border-radius: 12px;
            margin-top: 12px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }


        @keyframes autofillDetection {
            from {
                opacity: 1;
            }

            to {
                opacity: 1;
            }
        }

        input:-webkit-autofill {
            animation-name: autofillDetection;
            animation-duration: 0.001s;
            animation-iteration-count: 1;
            animation-timing-function: ease;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .flex-gap {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 16px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 28px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .modal-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 16px;
            color: #1a1a1a;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        .toast-bar {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            z-index: 9999;
            pointer-events: none;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 11px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-align: center;
            pointer-events: auto;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }


        .toast-success {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
        }

        .toast-error {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
        }

        .toast-info {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
        }

        .transaction-tabs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .transaction-tab {
            padding: 14px 16px;
            border-radius: 16px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            text-align: center;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab:active {
            transform: translateY(0);
        }

        .transaction-tab.mpesa {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
            opacity: 0.6;
        }

        .transaction-tab.mpesa.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(211, 47, 47, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.crdb {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
            opacity: 0.6;
        }

        .transaction-tab.crdb.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(46, 125, 50, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.nmb {
            background: linear-gradient(145deg, #e65100, #bf360c);
            opacity: 0.6;
        }

        .transaction-tab.nmb.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(230, 81, 0, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.yas {
            background: linear-gradient(145deg, #0d47a1, #01579b);
            opacity: 0.6;
        }

        .transaction-tab.yas.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(13, 71, 161, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.halopesa {
            background: linear-gradient(145deg, #fdd835, #f9a825);
            color: #000;
            opacity: 0.6;
        }

        .transaction-tab.halopesa.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(253, 216, 53, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.airtel {
            background: linear-gradient(145deg, #b71c1c, #7f0000);
            opacity: 0.6;
        }

        .transaction-tab.airtel.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(183, 28, 28, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .note-preview {
            cursor: pointer;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            line-clamp: 4;
            -webkit-box-orient: vertical;
            line-height: 1.5;
            background: linear-gradient(145deg, #ffffff, #f5f5f5);
            border: 2px solid rgba(102, 126, 234, 0.2);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }

        .note-preview:hover {
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            border-color: rgba(102, 126, 234, 0.4);
        }

        .note-preview:active {
            transform: translateY(-2px) scale(1.01);
        }

        .collapse-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(145deg, #f8f8f8, #e8e8e8);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            color: #555;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            margin: 12px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .collapse-btn:hover {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .collapse-btn:active {
            transform: translateY(0);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .collapse-icon {
            font-size: 12px;
            transition: transform 0.3s;
        }

        .collapse-icon.expanded {
            transform: rotate(180deg);
        }

        .highlight-pulse {
            animation: highlightFade 1s ease-out;
        }

        @keyframes highlightFade {
            0% {
                background: rgba(102, 126, 234, 0.3);
                box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
            }

            100% {
                background: transparent;
                box-shadow: none;
            }
        }

        .search-box {
            margin-bottom: 16px;
        }

        .search-box input {
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .filter-row {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .filter-row input,
        .filter-row select {
            flex: 1;
            min-width: 120px;
        }

        .filter-row input[type="date"] {
            position: relative;
        }

        .filter-row input[type="date"]::-webkit-datetime-edit {
            display: block;
            padding: 0;
        }

        .filter-row input[type="date"]::-webkit-datetime-edit-fields-wrapper {
            display: block;
        }

        .filter-row input[type="date"]::-webkit-calendar-picker-indicator {
            position: absolute;
            right: 8px;
            cursor: pointer;
        }

        /* Date input sizing: prevent overflow outside cards */
        input[type="date"] {
            width: 100%;
            max-width: 220px;
            /* keep compact across devices */
            box-sizing: border-box;
            -webkit-appearance: none;
            /* normalize iOS Safari */
            appearance: none;
            height: 36px;
            line-height: 1.2;
            padding: 6px 28px 6px 10px;
            /* space for picker icon */
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .form-group input[type="date"],
        .filter-row input[type="date"] {
            flex: 0 1 220px;
            /* allow shrink/grow but cap width */
            min-width: 0;
            /* avoid flex min-content overflow */
        }

        /* Ensure date inputs can shrink within filter groups on iOS */
        .filter-row .form-group {
            min-width: 0;
            flex: 0 1 auto;
        }

        /* iOS-specific tuning */
        @supports (-webkit-touch-callout: none) {
            input[type="date"] {
                max-width: clamp(140px, 42vw, 220px);
                /* flex-basis mirrors max-width to prevent overflow */
                /* Use both to handle different flex contexts */
            }

            .form-group input[type="date"],
            .filter-row input[type="date"] {
                flex-basis: clamp(140px, 42vw, 220px);
                font-size: 14px;
            }

            .filter-row input[type="date"]::-webkit-calendar-picker-indicator {
                right: 6px;
            }
        }

        /* Inventory page date inputs: uniform and spaced */
        #invFilterFrom,
        #invFilterTo,
        #invDate,
        #invTime {
            width: 100%;
            max-width: 220px;
            margin-top: 4px;
        }

        .alert-box {
            background: linear-gradient(145deg, #fff3e0, #ffe0b2);
            border-left: 4px solid #e65100;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            box-shadow: 0 4px 15px rgba(230, 81, 0, 0.2);
        }

        .alert-box-danger {
            background: linear-gradient(145deg, #ffebee, #ffcdd2);
            border-left: 4px solid #d32f2f;
            box-shadow: 0 4px 15px rgba(211, 47, 47, 0.2);
        }

        .alert-success {
            background: linear-gradient(145deg, #e8f5e9, #c8e6c9);
            border-left: 4px solid #2e7d32;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            box-shadow: 0 4px 15px rgba(46, 125, 50, 0.2);
        }

        .alert-info {
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            border-left: 4px solid #1976d2;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 16px;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.2);
        }

        .alert-info {
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            border-left: 4px solid #1976d2;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 16px;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.2);
        }

        .float-balance-container {
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.2);
            border: 2px solid rgba(25, 118, 210, 0.3);
        }

        .float-balance-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(25, 118, 210, 0.2);
        }

        .float-balance-row:last-child {
            border-bottom: none;
        }

        .float-balance-label {
            font-weight: 600;
            color: #0d47a1;
            font-size: 14px;
        }

        .float-balance-value {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 16px;
        }

        .float-balance-value.positive {
            color: #2e7d32;
        }

        .float-balance-value.negative {
            color: #d32f2f;
        }

        .editable-float {
            padding: 8px 12px;
            border: 2px solid rgba(25, 118, 210, 0.3);
            border-radius: 8px;
            background: white;
            font-weight: 700;
            color: #1976d2;
            cursor: pointer;
            display: inline-block;
            min-width: 100px;
            text-align: right;
        }

        .editable-float:hover {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .progress-bar {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            height: 8px;
            margin-top: 8px;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #2e7d32, #66bb6a);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeOut 0.3s ease-in-out 0.5s forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                visibility: hidden;
            }
        }

        .welcome-logo {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s ease-in-out;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        .welcome-title {
            color: white;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            animation: slideUp 0.8s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-subtitle {
            color: #aaa;
            font-size: 14px;
            animation: slideUp 0.8s ease-out 0.2s both;
        }

        .app-container {
            opacity: 0;
            animation: fadeIn 0.3s ease-in-out 0.8s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        .quick-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }

        .quick-stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 8px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        @media (max-width: 640px) {
            .stat-grid {
                grid-template-columns: 1fr;
            }

            .transaction-tabs {
                grid-template-columns: repeat(2, 1fr);
            }

            .filter-row {
                flex-direction: column;
            }

            .filter-row input,
            .filter-row select {
                width: 100%;
            }

            .form-group input[type="date"],
            .filter-row input[type="date"] {
                max-width: 100%;
                flex: 1 1 auto;
            }
        }

        .sync-indicator {
            position: absolute;
            left: 62px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 13px;
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
            color: white;
            display: none;
            white-space: normal;
            /* allow two-line label */
        }

        .sync-indicator.show {
            display: block;
        }

        .sync-indicator.syncing {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            animation: pulse 1s infinite;
        }

        .sync-indicator.clickable {
            cursor: pointer;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

        }

        .checkbox-select {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 8px;
            accent-color: #1976d2;
        }

        .bulk-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px;
            background: linear-gradient(145deg, #f5f5f5, #e8e8e8);
            border-radius: 12px;
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .bulk-actions label {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            margin: 0;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .side-nav {
            position: fixed;
            top: 0;
            left: -250px;
            width: 250px;
            height: 100vh;
            background: linear-gradient(180deg, #1a1a1a 0%, #000000 100%);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transition: left 0.3s ease;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }

        .side-nav.open {
            left: 0;
        }

        /* Prevent body scroll when nav is open */
        body.nav-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        .side-nav-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .side-nav-overlay.show {
            display: block;
            opacity: 1;
        }

        .side-nav-header {
            padding: 16px;
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .side-nav-header h2 {
            font-size: 16px;
            font-weight: 700;
            margin: 0;
        }

        .side-nav-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .side-nav-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .side-nav-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            color: white;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            font-size: 13px;
            flex-shrink: 0;
        }

        .side-nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #667eea;
        }

        .side-nav-item.active {
            background: rgba(102, 126, 234, 0.2);
            border-left-color: #667eea;
            font-weight: 600;
        }

        .side-nav-icon {
            font-size: 18px;
            width: 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .side-nav-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
        }

        .side-nav-section-title {
            padding: 10px 16px 6px 16px;
            font-size: 10px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            flex-shrink: 0;
        }

        .side-nav-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 80px;
        }

        .side-nav-footer {
            padding: 16px;
            text-align: center;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .side-nav-footer-text {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.4;
        }

        .side-nav-footer-brand {
            font-size: 13px;
            font-weight: 700;
            color: white;
            margin-top: 4px;
        }
    </style>
    <!-- Add this line -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- Your existing scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>

<body>
    <!-- Removed in-app pull-to-refresh indicator -->

    <!-- Side Navigation Drawer -->
    <div class="side-nav-overlay" id="sideNavOverlay" onclick="toggleSideNav()"></div>
    <div class="side-nav" id="sideNav">
        <div class="side-nav-header">
            <h2>üíº TUBA</h2>
            <button class="side-nav-close" onclick="toggleSideNav()">√ó</button>
        </div>

        <div class="side-nav-content">
            <div class="side-nav-section-title">Main</div>
            <div class="side-nav-item" onclick="navigateToTab('account')">
                <span class="side-nav-icon">üë§</span>
                <span>Profile</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('dashboard')">
                <span class="side-nav-icon">üìä</span>
                <span>Dashboard</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('sales')">
                <span class="side-nav-icon">üí∞</span>
                <span>Sales</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('transactions')">
                <span class="side-nav-icon">üí≥</span>
                <span>Transactions</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('invoices')">
                <span class="side-nav-icon">üìÑ</span>
                <span>Invoices</span>
            </div>

            <div class="side-nav-divider"></div>
            <div class="side-nav-section-title">Management</div>
            <div class="side-nav-item" onclick="navigateToTab('products')">
                <span class="side-nav-icon">üõçÔ∏è</span>
                <span>Products/Services</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('categories')">
                <span class="side-nav-icon">üìë</span>
                <span>Categories</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('inventory')">
                <span class="side-nav-icon">üì¶</span>
                <span>Stock</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('inventoryPurchases')">
                <span class="side-nav-icon">üì¶</span>
                <span>Inventory</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('customers')">
                <span class="side-nav-icon">üë•</span>
                <span>Customers</span>
            </div>

            <div class="side-nav-divider"></div>
            <div class="side-nav-section-title">Finance</div>
            <div class="side-nav-item" onclick="navigateToTab('expenses')">
                <span class="side-nav-icon">üí∏</span>
                <span>Expenses</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('unpaid')">
                <span class="side-nav-icon">‚è≥</span>
                <span>Unpaid</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('analytics')">
                <span class="side-nav-icon">üìà</span>
                <span>Analytics</span>
            </div>

            <div class="side-nav-divider"></div>
            <div class="side-nav-section-title">Tools</div>
            <div class="side-nav-item" onclick="navigateToTab('notes')">
                <span class="side-nav-icon">üìù</span>
                <span>Notes</span>
            </div>
        </div>

        <!-- Offline Info Modal -->
        <div class="modal" id="offlineInfoModal">
            <div class="modal-content">
                <div class="modal-title">Offline Usage</div>
                <div style="font-size: 13px; color: #333; line-height: 1.5;">
                    <p>You‚Äôre offline. All changes are saved locally and will sync when you‚Äôre back online.</p>
                    <p><strong>How to save a local backup:</strong><br>
                        Tap the top-right save button (üíæ) or click the ‚ÄúConsider Local Backup‚Äù toast to export a JSON
                        file.</p>
                    <p><strong>When back online:</strong><br>
                        Click the sync indicator (‚Äú‚òÅÔ∏è Synced ‚Üí Click to üîÑ‚Äù) to push data silently, or use Account ‚Üí
                        Push to Cloud.</p>
                    <p><strong>Tip:</strong> You can continue recording sales, products, expenses, etc., while offline ‚Äî
                        they‚Äôll sync later.</p>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end;">
                    <button class="btn-small btn-success" onclick="exportData('Saved', 2000)">Backup Now</button>
                    <button class="btn-small btn-secondary" onclick="closeOfflineInfoModal()">Close</button>
                </div>
            </div>
        </div>


        <div class="modal" id="pdfViewerModal">
            <div class="modal-content"
                style="width: 92%; max-width: 920px; height: 85vh; display: flex; flex-direction: column;">
                <div class="modal-title" id="pdfViewerTitle">PDF Preview</div>
                <div style="flex:1; border:1px solid rgba(0,0,0,0.12); border-radius:8px; overflow:hidden;">
                    <iframe id="pdfIframe" style="width:100%; height:100%;"></iframe>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end;">
                    <button class="btn-small" id="pdfDownloadBtn">Download</button>
                    <button class="btn-small btn-secondary" onclick="closePdfViewer()">Close</button>
                </div>
            </div>
        </div>



        <div class="side-nav-footer">
            <div class="side-nav-footer-text">Empowering Your Business</div>
            <div class="side-nav-footer-brand">The Ultimate Business Architecture (TUBA)</div>
        </div>
    </div>
    <div class="welcome-screen">
        <div class="welcome-logo">üíº</div>
        <div class="welcome-title">
            TUBA
        </div>
        <div class="welcome-subtitle">The Ultimate Business Architecture</div>
    </div>

    <div class="app-container">
        <div class="header">
            <button class="header-btn-left" onclick="toggleSideNav()">‚ò∞</button>
            <div class="sync-indicator" id="syncIndicator">‚òÅÔ∏è Synced</div>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                <h1 style="margin: 0;">üíº TUBA</h1>
                <div id="headerDate" style="font-size: 9px; opacity: 0.8; font-weight: 400;"></div>
            </div>
            <div
                style="position: absolute; right: 16px; top: 50%; transform: translateY(-50%); display: flex; gap: 8px;">
                <button
                    style="width: 40px; height: 40px; background: linear-gradient(145deg, #2e7d32, #1b5e20); color: white; border: none; border-radius: 50%; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 15px rgba(46, 125, 50, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);"
                    onclick="exportData()">üíæ</button>
                <button
                    style="width: 40px; height: 40px; background: linear-gradient(145deg, #1976d2, #0d47a1); color: white; border: none; border-radius: 50%; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 15px rgba(25, 118, 210, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);"
                    onclick="importData()">üì•</button>
            </div>
        </div>

        <!-- Offline status banner inserted below header so it does not overlay content -->
        <div id="offlineBanner" class="offline-banner" role="status" aria-live="polite" aria-atomic="true"></div>
        <!-- Not signed-in banner (click to go to Sign In) -->
        <div id="authBanner" class="offline-banner auth-banner" role="status" aria-live="polite" aria-atomic="true">
        </div>

        <div class="content" id="app"></div>
        <div class="bottom-nav" id="bottomNav"></div>
    </div>

    <div class="modal" id="noteModal">
        <div class="modal-content">
            <div class="modal-title">Note Details</div>
            <div id="noteModalContent"></div>
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-small" onclick="editNoteFromModal()">Edit</button>
                <button class="btn-small btn-danger" onclick="deleteNoteFromModal()">Delete</button>
                <button class="btn-small btn-secondary" onclick="closeNoteModal()">Close</button>
            </div>
        </div>
    </div>


    <div class="modal" id="cleanupModal">
        <div class="modal-content">
            <div class="modal-title">Clean Duplicate Records</div>
            <p>This will remove duplicate entries from your local and cloud data based on ID.</p>
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-small btn-success" onclick="confirmCleanup()">Proceed</button>
                <button class="btn-small btn-secondary" onclick="closeCleanupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="floatModal">
        <div class="modal-content">
            <div class="modal-title">Set Initial Float</div>
            <div id="floatModalContent"></div>
        </div>
    </div>

    <!-- Inventory Purchase Modal -->
    <div class="modal" id="inventoryModal">
        <div class="modal-content">
            <div class="modal-title">Add Inventory Purchase</div>
            <div id="inventoryModalContent"></div>
            <div class="flex-gap" style="margin-top:12px;">
                <button class="btn-success btn-small" onclick="addInventoryRecord()">Save Purchase</button>
                <button class="btn-secondary btn-small" onclick="closeInventoryModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // SUPABASE CONFIGURATION
        // ========================================
        const SUPABASE_URL = 'https://tusrkwljhpkylgfrikrw.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1c3Jrd2xqaHBreWxnZnJpa3J3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4ODE1MDcsImV4cCI6MjA3ODQ1NzUwN30.2eWlpXzsxYhw6-Fo5QFOz_DYnoMnUGqrF0vxdSTqueQ';

        let supabase;
        // ===============================
        // ID SANITIZATION & DEDUP HELPERS
        // ===============================
        function ensureItemIDs() {
            const lists = ['sales', 'products', 'expenses', 'customers', 'transactions', 'unpaidEntries', 'notes'];
            lists.forEach(listName => {
                if (!Array.isArray(state[listName])) return;
                state[listName] = state[listName].map(item => {
                    if (!item.id) item.id = generateID(listName);
                    return item;
                });
            });
        }

        function removeDuplicatesByID(arr) {
            const seen = new Set();
            const seenHashes = new Set();

            return arr.filter(item => {
                if (!item.id) return true;

                // Check for ID duplicates
                if (seen.has(item.id)) return false;

                // Check for content duplicates (same data, different IDs)
                const content = { ...item };
                delete content.id;
                delete content.created_at;
                delete content.updated_at;
                const contentHash = JSON.stringify(content);

                if (seenHashes.has(contentHash)) return false;

                seen.add(item.id);
                seenHashes.add(contentHash);
                return true;
            });
        }
        let currentUser = null;
        let syncEnabled = false;
        let autoCloudPullDone = false;

        // Your existing code continues below...
        const SHOP_NAME = "";
        const SHOP_ADDRESS = "";
        const SHOP_PHONE = "";
        const SHOP_EMAIL = "";

        // ========================================
        // SUPABASE FUNCTIONS
        // ========================================

        function initSupabase() {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    auth: {
                        persistSession: true,
                        autoRefreshToken: true,
                        detectSessionInUrl: true,
                        multiTab: true,
                        storageKey: 'tuba-auth-token',
                        storage: window.localStorage
                    }
                });

                console.log('‚úÖ Supabase initialized');

                // Listen for auth state changes
                supabase.auth.onAuthStateChange(async (event, session) => {
                    console.log('Auth event:', event);

                    if (event === 'SIGNED_IN' && session) {
                        currentUser = session.user;
                        syncEnabled = true;
                        // Ensure fresh cloud pull/merge for new session
                        autoCloudPullDone = false;
                        updateSyncIndicator('synced');
                        await maybeAutoPullCloudData();
                    } else if (event === 'SIGNED_OUT') {
                        currentUser = null;
                        syncEnabled = false;
                        // Reset auto-pull flag for next sign-in
                        autoCloudPullDone = false;
                        updateSyncIndicator('offline');
                        render();
                    } else if (event === 'TOKEN_REFRESHED' && session) {
                        console.log('‚úÖ Token refreshed');
                        currentUser = session.user;
                        syncEnabled = true;
                        autoCloudPullDone = false;
                        await maybeAutoPullCloudData();
                    }
                });

            } catch (error) {
                console.error('Supabase init error:', error);
                syncEnabled = false;
            }
        }

        async function restoreSession() {
            try {
                const { data: { session }, error } = await supabase.auth.getSession();

                if (error) {
                    console.error('Session restore error:', error);
                    return false;
                }

                if (session) {
                    currentUser = session.user;
                    syncEnabled = true;
                    updateSyncIndicator('synced');

                    // Load user profile
                    await loadUserProfile();

                    // Always pull and merge cloud data after session restore
                    // This is safe because pullDataFromSupabase merges and deduplicates
                    try {
                        await pullDataFromSupabase();
                    } catch (e) {
                        console.warn('Cloud pull after restore failed:', e);
                    }

                    console.log('‚úÖ Session restored successfully (local data preserved)');
                    return true;
                }

                return false;
            } catch (error) {
                console.error('Restore session error:', error);
                return false;
            }
        }

        function hasAnyLocalData() {
            try {
                const nonEmptyArrays = [
                    state.products,
                    state.sales,
                    state.expenses,
                    state.customers,
                    state.invoices,
                    state.receipts,
                    state.notes,
                    state.transactions,
                    state.unpaidEntries,
                    state.categories
                ].some(arr => Array.isArray(arr) && arr.length > 0);

                const hasInventory = state.inventory && Object.keys(state.inventory).length > 0;
                return nonEmptyArrays || hasInventory;
            } catch (e) {
                return false;
            }
        }

        async function maybeAutoPullCloudData() {
            if (!syncEnabled || !currentUser) return;
            if (autoCloudPullDone) return;

            const hasLocal = hasAnyLocalData();
            if (!hasLocal) {
                try {
                    await pullDataFromSupabase();
                } finally {
                    autoCloudPullDone = true;
                }
            }
        }

        async function loadUserProfile() {
            // First, check if we have local profile data
            const localProfile = state.userProfile;
            const hasLocalProfile = localProfile && localProfile.businessName && localProfile.phone && localProfile.address;

            if (!syncEnabled || !currentUser) {
                // Not signed in - use local profile if available
                if (!hasLocalProfile) {
                    // No local profile - set up for first-time entry
                    state.profileEditMode = true;
                    state.profileLoaded = false;
                } else {
                    // Has local profile
                    state.profileEditMode = false;
                    state.profileLoaded = true;
                }
                return;
            }

            // Signed in - check cloud profile
            try {
                const { data, error } = await supabase
                    .from('user_profiles')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .single();

                if (error && error.code !== 'PGRST116') {
                    console.error('Error loading profile:', error);
                    return;
                }

                if (data) {
                    // Cloud profile exists - use it
                    state.userProfile = {
                        businessName: data.business_name || "",
                        email: data.email || currentUser.email || "",
                        phone: data.phone || "",
                        address: data.address || ""
                    };
                    if (data.logo_url) {
                        state.userLogoPublicUrl = data.logo_url;
                        try {
                            const res = await fetch(data.logo_url);
                            const blob = await res.blob();
                            const reader = new FileReader();
                            const base64 = await new Promise((resolve, reject) => { reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob); });
                            state.userLogoDataUrl = base64;
                            state.userLogoMime = blob.type.includes('png') ? 'image/png' : 'image/jpeg';
                        } catch (e) {
                            console.warn('Failed to hydrate logo from URL:', e);
                        }
                    }
                    state.profileEditMode = false;
                    state.profileLoaded = true;
                    saveData();
                } else {
                    // No cloud profile
                    if (hasLocalProfile) {
                        // Has local profile - upload it to cloud
                        console.log('üì§ Uploading local profile to cloud...');
                        await createProfileFromLocal();
                    } else {
                        // No profile at all - show edit mode
                        state.profileEditMode = true;
                        state.profileLoaded = false;
                    }
                }
            } catch (error) {
                console.error('Load profile error:', error);
            }
        }

        async function createProfileFromLocal() {
            if (!syncEnabled || !currentUser) return;

            try {
                const { error } = await supabase
                    .from('user_profiles')
                    .insert({
                        user_id: currentUser.id,
                        business_name: state.userProfile.businessName,
                        email: state.userProfile.email || currentUser.email,
                        phone: state.userProfile.phone,
                        address: state.userProfile.address,
                        logo_url: state.userLogoPublicUrl || null
                    });

                if (error) {
                    console.error('Error creating profile from local:', error);
                    return false;
                }

                console.log('‚úÖ Local profile uploaded to cloud');
                state.profileLoaded = true;
                saveData();
                return true;
            } catch (error) {
                console.error('Create profile from local error:', error);
                return false;
            }
        }

        async function createDefaultProfile() {
            if (!syncEnabled || !currentUser) return;

            try {
                const { error } = await supabase
                    .from('user_profiles')
                    .insert({
                        user_id: currentUser.id,
                        business_name: state.userProfile.businessName,
                        email: currentUser.email,
                        phone: state.userProfile.phone,
                        address: state.userProfile.address
                    });

                if (error) {
                    console.error('Error creating profile:', error);
                }
            } catch (error) {
                console.error('Create profile error:', error);
            }
        }

        async function saveUserProfile(profileData) {
            // Always save locally first
            state.userProfile = { ...profileData };
            state.profileLoaded = true;
            saveData();

            // If signed in, also save to cloud
            if (syncEnabled && currentUser) {
                try {
                    updateSyncIndicator('syncing');

                    const { error } = await supabase
                        .from('user_profiles')
                        .upsert({
                            user_id: currentUser.id,
                            business_name: profileData.businessName,
                            email: profileData.email,
                            phone: profileData.phone,
                            address: profileData.address,
                            logo_url: state.userLogoPublicUrl || null,
                            updated_at: new Date().toISOString()
                        }, {
                            onConflict: 'user_id'
                        });

                    if (error) throw error;

                    updateSyncIndicator('synced');
                    console.log('‚úÖ Profile saved to cloud');
                } catch (error) {
                    console.error('Save profile to cloud error:', error);
                    updateSyncIndicator('synced');
                    showToast('Profile saved locally (cloud sync failed)', 'info');
                }
            } else {
                console.log('‚úÖ Profile saved locally');
            }

            return true;
        }

        function getUserProfileData() {
            return {
                businessName: state.userProfile?.businessName || "",
                email: state.userProfile?.email || currentUser?.email || "",
                phone: state.userProfile?.phone || "",
                address: state.userProfile?.address || ""
            };
        }

        function updateSyncIndicator(status) {
            const indicator = document.getElementById('syncIndicator');
            if (!indicator) return;

            if (status === 'synced' && syncEnabled) {
                indicator.innerHTML = '‚òÅÔ∏è Synced<br><span style="font-size:9px;opacity:0.9;">Click to üîÑ</span>';
                indicator.className = 'sync-indicator show clickable';
                indicator.setAttribute('title', 'Push all data to cloud');
                indicator.onclick = function () {
                    try { pushToCloudSilent(); } catch (e) { /* no-op */ }
                };
            } else if (status === 'syncing') {
                indicator.textContent = 'üîÑ Syncing...';
                indicator.className = 'sync-indicator show syncing';
                indicator.removeAttribute('title');
                indicator.onclick = null;
            } else {
                indicator.className = 'sync-indicator';
                indicator.onclick = null;
            }
        }

        // Silent push-to-cloud for sync indicator click (no confirmation)
        async function pushToCloudSilent() {
            if (!syncEnabled || !currentUser) {
                return showToast('Not signed in', 'error');
            }

            updateSyncIndicator('syncing');
            try {
                await clearAndPushAllData();
                updateSyncIndicator('synced');
                showToast('Data pushed to cloud successfully!', 'success');
            } catch (error) {
                console.error('Push error:', error);
                updateSyncIndicator('synced');
                showToast('Push failed: ' + error.message, 'error');
            }
        }

        async function signUp(email, password) {
            try {
                const { data, error } = await supabase.auth.signUp({ email, password });
                if (error) throw error;
                showToast('Account created! Check your email to confirm.', 'success');
                return data;
            } catch (error) {
                showToast('Sign up error: ' + error.message, 'error');
                return null;
            }
        }

        async function signIn(email, password) {
            try {
                const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                if (error) throw error;

                currentUser = data.user;
                syncEnabled = true;

                showToast('Signed in successfully!', 'success');

                // Load user profile first
                await loadUserProfile();
                // Hydrate logo base64 for immediate UI/PDF usage
                try { await ensureLogoReady(); } catch (e) { /* no-op */ }
                // Update auth banner visibility
                try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }

                // Upload logo if selected locally
                // if (state.userLogoDataUrl) {
                //     try { await uploadLogoToSupabase(state.userLogoDataUrl, state.userLogoMime || 'image/png'); } catch (e) { console.warn('Logo upload after sign-in failed:', e); }
                // }

                // Check if local data exists
                const localHasData = state.sales.length > 0 || state.products.length > 0;

                try {
                    if (localHasData) {
                        // Smart merge - combine unique items by ID
                        await smartMergeData();
                        showToast('Local and cloud data merged successfully', 'success');
                    } else {
                        // No local data, just pull from cloud
                        await pullDataFromSupabase();
                        showToast('Cloud data loaded', 'success');
                    }
                } catch (syncError) {
                    console.error('Sync error after sign in:', syncError);
                    showToast('Signed in but sync failed. Try manual sync.', 'error');
                }

                return data;
            } catch (error) {
                console.error('Sign in error:', error);
                showToast('Sign in error: ' + error.message, 'error');
                currentUser = null;
                syncEnabled = false;
                return null;
            }
        }

        async function smartMergeData() {
            try {
                updateSyncIndicator('syncing');
                showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                console.log('üîÑ Starting smart merge...');

                // Save local data BEFORE pulling from cloud
                const localData = {
                    sales: [...(state.sales || [])],
                    products: [...(state.products || [])],
                    expenses: [...(state.expenses || [])],
                    customers: [...(state.customers || [])],
                    transactions: [...(state.transactions || [])],
                    unpaidEntries: [...(state.unpaidEntries || [])],
                    notes: [...(state.notes || [])],
                    categories: [...(state.categories || [])]
                };

                console.log('üì± Local data counts:', {
                    sales: localData.sales.length,
                    products: localData.products.length,
                    expenses: localData.expenses.length,
                    customers: localData.customers.length,
                    transactions: localData.transactions.length,
                    unpaidEntries: localData.unpaidEntries.length,
                    notes: localData.notes.length
                });

                // Fetch cloud data directly from Supabase (don't overwrite state yet)
                const cloudData = await fetchCloudDataDirect();

                console.log('‚òÅÔ∏è Cloud data counts:', {
                    sales: cloudData.sales.length,
                    products: cloudData.products.length,
                    expenses: cloudData.expenses.length,
                    customers: cloudData.customers.length,
                    transactions: cloudData.transactions.length,
                    unpaidEntries: cloudData.unpaidEntries.length,
                    notes: cloudData.notes.length
                });

                // Enhanced merge function with better duplicate detection
                const mergeByID = (local, cloud, dataType) => {
                    const idMap = new Map();
                    const seenHashes = new Set();

                    // Helper function to create content hash for duplicate detection
                    const createContentHash = (item) => {
                        const content = { ...item };
                        delete content.id;
                        delete content.created_at;
                        delete content.updated_at;
                        // Strip DB-only ownership/meta fields to compare local vs cloud consistently
                        delete content.user_id;
                        delete content.userId;
                        delete content.inserted_at;
                        delete content.deleted_at;
                        return JSON.stringify(content);
                    };

                    // Add cloud items first (they take priority for same IDs)
                    cloud.forEach(item => {
                        if (!item.id) item.id = generateID(dataType);
                        const contentHash = createContentHash(item);

                        idMap.set(item.id, item);
                        seenHashes.add(contentHash);
                    });

                    // Add local items only if ID doesn't exist AND content is unique
                    local.forEach(item => {
                        if (!item.id) item.id = generateID(dataType);
                        const contentHash = createContentHash(item);

                        // Only add if both ID and content are unique
                        if (!idMap.has(item.id) && !seenHashes.has(contentHash)) {
                            idMap.set(item.id, item);
                            seenHashes.add(contentHash);
                        }
                    });

                    return Array.from(idMap.values());
                };

                // Merge each array with proper data type identification
                state.sales = mergeByID(localData.sales, cloudData.sales, 'sales');
                state.products = mergeByID(localData.products, cloudData.products, 'products');
                state.expenses = mergeByID(localData.expenses, cloudData.expenses, 'expenses');
                state.customers = mergeByID(localData.customers, cloudData.customers, 'customers');
                state.transactions = mergeByID(localData.transactions, cloudData.transactions, 'transactions');
                state.unpaidEntries = mergeByID(localData.unpaidEntries, cloudData.unpaidEntries, 'unpaid');
                state.notes = mergeByID(localData.notes, cloudData.notes, 'notes');
                // Categories: merge by name (set uniqueness)
                state.categories = Array.from(new Set([...(localData.categories || []), ...((cloudData.categories) || [])]));

                // Final pass: content-based deduplication per type
                state.sales = deduplicateByContent(state.sales, 'sales');
                state.products = deduplicateByContent(state.products, 'products');
                state.expenses = deduplicateByContent(state.expenses, 'expenses');
                state.customers = deduplicateByContent(state.customers, 'customers');
                state.transactions = deduplicateByContent(state.transactions, 'transactions');
                state.unpaidEntries = deduplicateByContent(state.unpaidEntries, 'unpaid');
                state.notes = deduplicateByContent(state.notes, 'notes');

                console.log('üîÄ Merged data counts:', {
                    sales: state.sales.length,
                    products: state.products.length,
                    expenses: state.expenses.length,
                    customers: state.customers.length,
                    transactions: state.transactions.length,
                    unpaidEntries: state.unpaidEntries.length,
                    notes: state.notes.length
                });

                // Save merged data locally
                saveData();

                // Push merged data back to cloud (clear and push to avoid server-side duplicates)
                await clearAndPushAllData();
                updateSyncIndicator('synced');

                console.log('‚úÖ Smart merge completed successfully');
            } catch (error) {
                console.error('Smart merge error:', error);
                updateSyncIndicator('synced');
                throw error;
            }
        }

        // Helper function to fetch cloud data without overwriting local state
        async function fetchCloudDataDirect() {
            if (!syncEnabled || !currentUser) return {
                sales: [], products: [], expenses: [], customers: [],
                transactions: [], unpaidEntries: [], notes: []
            };

            try {
                const [
                    { data: products },
                    { data: sales },
                    { data: expenses },
                    { data: customers },
                    { data: transactions },
                    { data: unpaidEntries },
                    { data: notes },
                    { data: categories }
                ] = await Promise.all([
                    supabase.from('products').select('*').eq('user_id', currentUser.id),
                    supabase.from('sales').select('*').eq('user_id', currentUser.id),
                    supabase.from('expenses').select('*').eq('user_id', currentUser.id),
                    supabase.from('customers').select('*').eq('user_id', currentUser.id),
                    supabase.from('transactions').select('*').eq('user_id', currentUser.id),
                    supabase.from('unpaid_entries').select('*').eq('user_id', currentUser.id),
                    supabase.from('notes').select('*').eq('user_id', currentUser.id),
                    supabase.from('categories').select('*').eq('user_id', currentUser.id)
                ]);

                return {
                    sales: sales || [],
                    products: products || [],
                    expenses: expenses || [],
                    customers: customers || [],
                    transactions: transactions || [],
                    unpaidEntries: unpaidEntries || [],
                    notes: notes || [],
                    categories: (categories || [])
                        .map(c => (c.name || '').trim())
                        .filter(Boolean)
                };
            } catch (error) {
                console.error('Error fetching cloud data:', error);
                return {
                    sales: [], products: [], expenses: [], customers: [],
                    transactions: [], unpaidEntries: [], notes: [], categories: []
                };
            }
        }

        function getTypeFromItem(item) {
            if (item.productName) return 'sales';
            if (item.cost !== undefined && item.price !== undefined) return 'products';
            if (item.description && item.category) return 'expenses';
            if (item.email !== undefined) return 'customers';
            if (item.channel) return 'transactions';
            if (item.paid !== undefined) return 'unpaid';
            if (item.content) return 'notes';
            return 'unknown';
        }

        async function signOut() {
            try {
                // Set these first in case signOut fails
                currentUser = null;
                syncEnabled = false;
                updateSyncIndicator('offline');

                const { error } = await supabase.auth.signOut();
                if (error) {
                    console.error('Sign out error:', error);
                    // Still consider it signed out locally
                }

                showToast('Signed out successfully', 'info');
                try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }
                render();
            } catch (error) {
                console.error('Sign out error:', error);
                showToast('Signed out (with errors)', 'info');
                try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }
                render();
            }
        }
        async function pushAllDataToSupabase() {
            if (!syncEnabled || !currentUser) return;

            updateSyncIndicator('syncing');

            try {
                // Sync products
                if (state.products.length > 0) {
                    const productsData = state.products.map(p => ({
                        user_id: currentUser.id,
                        name: p.name,
                        category: p.category || '',
                        cost: p.cost,
                        price: p.price,
                        has_stock: (p.hasStock === false) ? false : true
                    }));
                    const { error } = await supabase
                        .from('products')
                        .upsert(productsData, { onConflict: 'user_id,name,category' });
                    if (error) throw error;
                }

                // Sync categories
                if (state.categories.length > 0) {
                    const categoriesData = state.categories.map(c => ({
                        user_id: currentUser.id,
                        name: c
                    }));
                    const { error } = await supabase
                        .from('categories')
                        .upsert(categoriesData, { onConflict: 'user_id,name' });
                    if (error) console.warn('Categories upsert skipped:', error.message || error);
                }

                // Sync sales
                if (state.sales.length > 0) {
                    const salesData = state.sales.map(s => ({
                        user_id: currentUser.id,
                        date: s.date,
                        time: s.time,
                        timestamp: s.timestamp,
                        product_name: s.productName,
                        customer: s.customer,
                        quantity: s.quantity,
                        cost_per_unit: s.costPerUnit,
                        price_per_unit: s.pricePerUnit,
                        total_cost: s.totalCost,
                        total_price: s.totalPrice,
                        profit: s.profit,
                        payment: s.payment
                    }));
                    const { error } = await supabase
                        .from('sales')
                        .upsert(salesData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync expenses
                if (state.expenses.length > 0) {
                    const expensesData = state.expenses.map(e => ({
                        user_id: currentUser.id,
                        date: e.date,
                        time: e.time,
                        timestamp: e.timestamp,
                        description: e.description,
                        category: e.category,
                        amount: e.amount,
                        payment: e.payment,
                        comment: e.comment || ''
                    }));
                    const { error } = await supabase
                        .from('expenses')
                        .upsert(expensesData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync customers
                if (state.customers.length > 0) {
                    const customersData = state.customers.map(c => ({
                        user_id: currentUser.id,
                        name: c.name,
                        email: c.email || '',
                        phone: c.phone || '',
                        address: c.address || '',
                        total_purchases: c.totalPurchases || 0
                    }));
                    const { error } = await supabase
                        .from('customers')
                        .upsert(customersData, { onConflict: 'user_id,name,email' });
                    if (error) throw error;
                }

                // Sync invoices
                if (state.invoices.length > 0) {
                    const invoicesData = state.invoices.map(i => ({
                        user_id: currentUser.id,
                        number: i.number,
                        customer: i.customer,
                        date: i.date,
                        due_date: i.dueDate,
                        items: i.items,
                        amount: i.amount,
                        status: i.status
                    }));
                    const { error } = await supabase
                        .from('invoices')
                        .upsert(invoicesData, { onConflict: 'user_id,number' });
                    if (error) throw error;
                }

                // Sync receipts
                if (state.receipts && state.receipts.length > 0) {
                    const receiptsData = state.receipts.map(r => ({
                        user_id: currentUser.id,
                        number: r.number,
                        customer: r.customer,
                        customer_email: r.customerEmail || '',
                        date: r.date,
                        time: r.time,
                        timestamp: r.timestamp,
                        description: r.description,
                        amount: r.amount,
                        payment_method: r.paymentMethod
                    }));
                    const { error } = await supabase
                        .from('receipts')
                        .upsert(receiptsData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync inventory
                if (Object.keys(state.inventory).length > 0) {
                    const inventoryData = Object.entries(state.inventory).map(([productName, inv]) => ({
                        user_id: currentUser.id,
                        product_name: productName,
                        stock: inv.stock,
                        min_alert: inv.minAlert
                    }));
                    const { error } = await supabase
                        .from('inventory')
                        .upsert(inventoryData, { onConflict: 'user_id,product_name' });
                    if (error) throw error;
                }

                // Sync notes
                if (state.notes.length > 0) {
                    const notesData = state.notes.map(n => ({
                        user_id: currentUser.id,
                        title: n.title || '',
                        content: n.content,
                        date: n.date,
                        time: n.time,
                        timestamp: n.timestamp
                    }));
                    const { error } = await supabase
                        .from('notes')
                        .upsert(notesData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync inventory purchase Periods
                if (state.inventoryPurchaseCycles && state.inventoryPurchaseCycles.length > 0) {
                    const periodsData = state.inventoryPurchaseCycles.map(c => ({
                        user_id: currentUser.id,
                        period_number: c.number,
                        title: c.title || '',
                        start_date: c.startDate || null,
                        end_date: c.endDate || null,
                        notes: c.notes || ''
                    }));
                    const { error: periodsErr } = await supabase
                        .from('inventory_purchase_periods')
                        .upsert(periodsData, { onConflict: 'user_id,period_number' });
                    if (periodsErr) throw periodsErr;
                }

                // Sync inventory purchases
                if (state.inventoryPurchases && state.inventoryPurchases.length > 0) {
                    const purchasesData = state.inventoryPurchases.map(p => ({
                        user_id: currentUser.id,
                        period_number: p.cycleNumber,
                        item_name: p.itemName,
                        quantity: p.quantity || 0,
                        unit_cost: p.unitCost || p.buyingPrice || 0,
                        total_cost: p.totalCost || p.buyingPrice || 0,
                        purchase_date: p.purchaseDate,
                        supplier_name: p.supplierName || '',
                        supplier_phone: p.supplierPhone || p.supplierContact || '',
                        supplier_address: p.supplierAddress || '',
                        notes: p.notes || '',
                        timestamp: p.timestamp
                    }));
                    const { error: purchasesErr } = await supabase
                        .from('inventory_purchases')
                        .upsert(purchasesData, { onConflict: 'user_id,timestamp' });
                    if (purchasesErr) throw purchasesErr;
                }

                // Sync transactions
                if (state.transactions.length > 0) {
                    const transactionsData = state.transactions.map(t => ({
                        user_id: currentUser.id,
                        channel: t.channel,
                        customer_name: t.customerName,
                        type: t.type,
                        amount: t.amount,
                        date: t.date,
                        time: t.time,
                        timestamp: t.timestamp
                    }));
                    const { error } = await supabase
                        .from('transactions')
                        .upsert(transactionsData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync unpaid entries
                if (state.unpaidEntries.length > 0) {
                    const unpaidData = state.unpaidEntries.map(u => ({
                        user_id: currentUser.id,
                        name: u.name,
                        type: u.type,
                        amount: u.amount,
                        date: u.date,
                        time: u.time,
                        timestamp: u.timestamp,
                        paid: u.paid
                    }));
                    const { error } = await supabase
                        .from('unpaid_entries')
                        .upsert(unpaidData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync transaction floats
                const floatsData = Object.entries(state.transactionFloats).map(([channel, floatData]) => ({
                    user_id: currentUser.id,
                    channel: channel,
                    initial_float: floatData.initial
                }));
                {
                    const { error } = await supabase
                        .from('transaction_floats')
                        .upsert(floatsData, { onConflict: 'user_id,channel' });
                    if (error) console.warn('Transaction floats upsert skipped:', error.message || error);
                }

                // Sync settings
                {
                    const { error } = await supabase
                        .from('settings')
                        .upsert({
                            user_id: currentUser.id,
                            daily_target: state.dailyTarget || 0,
                            monthly_target: state.monthlyTarget || 0
                        }, { onConflict: 'user_id' });
                    if (error) console.warn('Settings upsert skipped:', error.message || error);
                }

                updateSyncIndicator('synced');
            } catch (error) {
                console.error('Push error:', error);
                updateSyncIndicator('synced');
                throw error;
            }
        }

        async function syncAllData() {
            if (!syncEnabled || !currentUser) return;
            if (isSyncing) {
                console.log('Sync already in progress, skipping...');
                return;
            }

            isSyncing = true;
            updateSyncIndicator('syncing');

            try {
                console.log('üîÑ Starting sync...');

                // Check if local data is essentially empty
                const localIsEmpty =
                    state.sales.length === 0 &&
                    state.products.length === 0 &&
                    state.expenses.length === 0;

                if (localIsEmpty) {
                    // Pull from cloud if local is empty
                    console.log('‚¨áÔ∏è Local data is empty, pulling from cloud...');
                    await pullDataFromSupabase();
                } else {
                    // Push local data to cloud
                    console.log('‚¨ÜÔ∏è Pushing local data to cloud...');
                    await clearAndPushAllData();
                }

                updateSyncIndicator('synced');
                showToast('Data synced successfully!', 'success');
                console.log('‚úÖ Sync complete');
                render();
            } catch (error) {
                console.error('‚ùå Sync error:', error);
                updateSyncIndicator('synced');
                showToast('Sync failed: ' + error.message, 'error');
            } finally {
                isSyncing = false;
            }
        }

        async function clearAndPushAllData() {
            if (!syncEnabled || !currentUser) return;

            try {
                console.log('üîÑ Merging local data to cloud (upsert, no delete)...');
                await pushAllDataToSupabase();
                console.log('‚úÖ Local data merged to cloud');
            } catch (error) {
                console.error('Merge and push error:', error);
                throw error;
            }
        }

        async function syncInBackground() {
            if (!syncEnabled || !currentUser) return;

            try {
                // Silent background sync - no loading indicators
                await clearAndPushAllData();
                console.log('‚úÖ Background sync complete');
            } catch (error) {
                console.error('‚ùå Background sync error:', error);
                // Don't show error toast for background operations
            }
        }

        async function pullDataFromSupabase() {
            if (!syncEnabled || !currentUser) return;

            try {
                showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                console.log('üì• Pulling data from cloud (parallel)...');

                const uid = currentUser.id;
                const fetch = (table, cols) => supabase.from(table).select(cols).eq('user_id', uid);

                const [
                    productsRes,
                    salesRes,
                    categoriesRes,
                    expensesRes,
                    customersRes,
                    invoicesRes,
                    receiptsRes,
                    inventoryRes,
                    notesRes,
                    transactionsRes,
                    unpaidRes,
                    floatsRes,
                    settingsRes,
                    periodsRes,
                    purchasesRes
                ] = await Promise.all([
                    fetch('products', 'name,category,cost,price,has_stock'),
                    supabase.from('sales').select('date,time,timestamp,product_name,customer,quantity,cost_per_unit,price_per_unit,total_cost,total_price,profit,payment').eq('user_id', uid).order('timestamp', { ascending: false }),
                    fetch('categories', 'name'),
                    fetch('expenses', 'date,time,timestamp,description,category,amount,payment,comment'),
                    fetch('customers', 'name,email,phone,address,total_purchases'),
                    fetch('invoices', 'number,customer,date,due_date,items,amount,status'),
                    fetch('receipts', 'number,customer,customer_email,date,time,timestamp,description,amount,payment_method'),
                    fetch('inventory', 'product_name,stock,min_alert'),
                    fetch('notes', 'title,content,date,time,timestamp'),
                    fetch('transactions', 'channel,customer_name,type,amount,date,time,timestamp'),
                    fetch('unpaid_entries', 'name,type,amount,date,time,timestamp,paid'),
                    fetch('transaction_floats', 'channel,initial_float'),
                    supabase.from('settings').select('daily_target,monthly_target').eq('user_id', uid).single(),
                    fetch('inventory_purchase_periods', 'period_number,title,start_date,end_date,notes'),
                    fetch('inventory_purchases', 'period_number,item_name,quantity,unit_cost,total_cost,purchase_date,supplier_name,supplier_phone,supplier_address,notes,timestamp')
                ]);

                const products = productsRes.data || [];
                if (products.length) {
                    const cloudProducts = products.map(p => ({
                        id: `P-${(p.name || '').toLowerCase().replace(/[^a-z0-9]+/g, '_')}`,
                        name: p.name,
                        category: p.category,
                        cost: parseFloat(p.cost),
                        price: parseFloat(p.price),
                        hasStock: (p.has_stock === false) ? false : true
                    }));
                    state.products = deduplicateByContent([...state.products, ...cloudProducts], 'products');
                }

                const sales = salesRes.data || [];
                if (sales.length) {
                    const cloudSales = sales.map(s => ({
                        id: `S-${s.timestamp}`,
                        date: s.date,
                        time: s.time,
                        timestamp: s.timestamp,
                        productName: s.product_name,
                        customer: s.customer,
                        quantity: s.quantity,
                        costPerUnit: parseFloat(s.cost_per_unit),
                        pricePerUnit: parseFloat(s.price_per_unit),
                        totalCost: parseFloat(s.total_cost),
                        totalPrice: parseFloat(s.total_price),
                        profit: parseFloat(s.profit),
                        payment: s.payment
                    }));
                    state.sales = deduplicateByContent([...state.sales, ...cloudSales], 'sales');
                }

                const categories = categoriesRes.data || [];
                if (categories.length) {
                    const cloudCategories = categories.map(c => (c.name || '').trim()).filter(Boolean);
                    state.categories = Array.from(new Set([...(state.categories || []), ...cloudCategories]));
                }

                const expenses = expensesRes.data || [];
                if (expenses.length) {
                    const cloudExpenses = expenses.map(e => ({
                        id: `E-${e.timestamp}`,
                        date: e.date,
                        time: e.time,
                        timestamp: e.timestamp,
                        description: e.description,
                        category: e.category,
                        amount: parseFloat(e.amount),
                        payment: e.payment,
                        comment: e.comment
                    }));
                    state.expenses = deduplicateByContent([...state.expenses, ...cloudExpenses], 'expenses');
                }

                const customers = customersRes.data || [];
                if (customers.length) {
                    const cloudCustomers = customers.map(c => ({
                        id: `C-${c.name.replace(/\s+/g, '_')}_${Date.now()}`,
                        name: c.name,
                        email: c.email || '',
                        phone: c.phone || '',
                        address: c.address || '',
                        totalPurchases: parseFloat(c.total_purchases || 0)
                    }));
                    state.customers = deduplicateByContent([...state.customers, ...cloudCustomers], 'customers');
                }

                const invoices = invoicesRes.data || [];
                if (invoices.length) {
                    const cloudInvoices = invoices.map(i => ({
                        id: `INV-${i.number}`,
                        number: i.number,
                        customer: i.customer,
                        date: i.date,
                        dueDate: i.due_date,
                        items: i.items,
                        amount: parseFloat(i.amount),
                        status: i.status
                    }));
                    state.invoices = deduplicateByContent([...(state.invoices || []), ...cloudInvoices], 'invoices');
                }

                const receipts = receiptsRes.data || [];
                if (receipts.length) {
                    const cloudReceipts = receipts.map(r => ({
                        id: `RCPT-${r.timestamp}`,
                        number: r.number,
                        customer: r.customer,
                        customerEmail: r.customer_email || '',
                        date: r.date,
                        time: r.time,
                        timestamp: r.timestamp,
                        description: r.description,
                        amount: parseFloat(r.amount),
                        paymentMethod: r.payment_method
                    }));
                    state.receipts = deduplicateByContent([...(state.receipts || []), ...cloudReceipts], 'receipts');
                }

                const inventory = inventoryRes.data || [];
                if (inventory.length) {
                    if (!state.inventory) state.inventory = {};
                    inventory.forEach(item => {
                        const name = item.product_name;
                        if (!(name in state.inventory)) {
                            state.inventory[name] = {
                                stock: parseInt(item.stock) || 0,
                                minAlert: parseInt(item.min_alert) || 5
                            };
                        } else {
                            const existing = state.inventory[name];
                            if (existing.stock == null) existing.stock = parseInt(item.stock) || 0;
                            if (existing.minAlert == null) existing.minAlert = parseInt(item.min_alert) || 5;
                        }
                    });
                }

                const notes = notesRes.data || [];
                if (notes.length) {
                    const cloudNotes = notes.map(n => ({
                        id: `N-${n.timestamp}`,
                        title: n.title || '',
                        content: n.content,
                        date: n.date,
                        time: n.time,
                        timestamp: n.timestamp
                    }));
                    state.notes = deduplicateByContent([...(state.notes || []), ...cloudNotes], 'notes');
                }

                const transactions = transactionsRes.data || [];
                if (transactions.length) {
                    const cloudTransactions = transactions.map(t => ({
                        id: `T-${t.timestamp}`,
                        channel: t.channel,
                        customerName: t.customer_name,
                        type: t.type,
                        amount: parseFloat(t.amount),
                        date: t.date,
                        time: t.time,
                        timestamp: t.timestamp
                    }));
                    state.transactions = deduplicateByContent([...(state.transactions || []), ...cloudTransactions], 'transactions');
                }

                const unpaidEntries = unpaidRes.data || [];
                if (unpaidEntries.length) {
                    const cloudUnpaid = unpaidEntries.map(u => ({
                        id: `U-${u.timestamp}`,
                        name: u.name,
                        type: u.type,
                        amount: parseFloat(u.amount),
                        date: u.date,
                        time: u.time,
                        timestamp: u.timestamp,
                        paid: u.paid
                    }));
                    state.unpaidEntries = deduplicateByContent([...(state.unpaidEntries || []), ...cloudUnpaid], 'unpaid');
                }

                const floats = floatsRes.data || [];
                if (floats.length) {
                    floats.forEach(f => {
                        if (state.transactionFloats[f.channel]) {
                            state.transactionFloats[f.channel].initial = parseFloat(f.initial_float);
                        }
                    });
                }

                const settings = settingsRes.data || null;
                if (settings) {
                    state.dailyTarget = parseFloat(settings.daily_target || 0);
                    state.monthlyTarget = parseFloat(settings.monthly_target || 0);
                }

                const cloudCycles = periodsRes.data || [];
                if (cloudCycles.length) {
                    state.inventoryPurchaseCycles = cloudCycles.map(c => ({
                        id: generateID('invCycle'),
                        number: c.period_number,
                        title: c.title || '',
                        startDate: c.start_date || '',
                        endDate: c.end_date || '',
                        notes: c.notes || ''
                    }));
                }

                const cloudPurchases = purchasesRes.data || [];
                if (cloudPurchases.length) {
                    state.inventoryPurchases = cloudPurchases.map(p => ({
                        id: generateID('invPurchase'),
                        cycleNumber: p.period_number,
                        itemName: p.item_name,
                        quantity: parseInt(p.quantity || 0, 10),
                        unitCost: parseFloat(p.unit_cost || 0),
                        totalCost: parseFloat(p.total_cost || 0),
                        purchaseDate: p.purchase_date || '',
                        supplierName: p.supplier_name || '',
                        supplierPhone: p.supplier_phone || '',
                        supplierAddress: p.supplier_address || '',
                        notes: p.notes || '',
                        timestamp: p.timestamp
                    }));
                }

                calculateFloatBalances();
                saveData();
                setTimeout(() => {
                    render();
                }, 100);
            } catch (error) {
                console.error('Pull error:', error);
            }
        }
        async function pushToSupabase(table, data) {
            if (!syncEnabled || !currentUser) return;
            try {
                data.user_id = currentUser.id;
                await supabase.from(table).insert(data);
            } catch (error) {
                console.error(`Error syncing to ${table}:`, error);
            }
        }
        const conflictTargets = {
            products: 'user_id,name,category',
            categories: 'user_id,name',
            sales: 'user_id,timestamp',
            expenses: 'user_id,timestamp',
            customers: 'user_id,name,email',
            invoices: 'user_id,number',
            receipts: 'user_id,timestamp',
            inventory: 'user_id,product_name',
            notes: 'user_id,timestamp',
            transactions: 'user_id,timestamp',
            unpaid_entries: 'user_id,timestamp',
            transaction_floats: 'user_id,channel',
            settings: 'user_id'
        };


        const DELETE_QUEUE_KEY = 'tuba-delete-queue-v1';
        const deleteQueue = {
            items: [],
            load() {
                try {
                    const raw = localStorage.getItem(DELETE_QUEUE_KEY);
                    this.items = raw ? JSON.parse(raw) : [];
                } catch { this.items = []; }
            },
            save() {
                try { localStorage.setItem(DELETE_QUEUE_KEY, JSON.stringify(this.items)); } catch { }
            },
            enqueue(table, keySource) {
                this.items.push({
                    id: `${table}-del-${Date.now()}-${Math.random().toString(36).slice(2)}`,
                    table,
                    keySource,
                    attempts: 0,
                    nextTryAt: Date.now() + 1000
                });
                this.save();
                console.log('üóëÔ∏è Enqueued delete', table, keySource);
            },
            backoffDelay(attempts) {
                const schedule = [1000, 2000, 5000, 10000, 30000, 60000];
                return schedule[Math.min(attempts, schedule.length - 1)];
            },
            buildDeleteKeys(table, src) {
                const k = {};
                switch (table) {
                    case 'sales':
                    case 'expenses':
                    case 'notes':
                    case 'transactions':
                    case 'receipts':
                    case 'unpaid_entries':
                        k.timestamp = src.timestamp;
                        break;
                    case 'invoices':
                        k.number = src.number;
                        break;
                    case 'customers':
                        k.name = src.name;
                        k.email = src.email || '';
                        break;
                    case 'products':
                        k.name = src.name;
                        k.category = src.category || '';
                        break;
                    case 'categories':
                        k.name = typeof src === 'string' ? src : (src.name || src);
                        break;
                    default:
                        if (src.timestamp) k.timestamp = src.timestamp;
                        break;
                }
                return k;
            },
            async process() {
                if (!navigator.onLine || !syncEnabled || !currentUser) return;
                if (!Array.isArray(this.items) || this.items.length === 0) return;
                const now = Date.now();
                for (const item of [...this.items]) {
                    if (item.nextTryAt && item.nextTryAt > now) continue;
                    try {
                        const keys = this.buildDeleteKeys(item.table, item.keySource);
                        const { error } = await supabase.from(item.table)
                            .delete()
                            .match({ user_id: currentUser.id, ...keys });
                        if (error) throw error;
                        this.items = this.items.filter(q => q.id !== item.id);
                        this.save();
                        console.log('‚úÖ Delete queue processed', item.table);
                    } catch (err) {
                        console.warn('‚è≥ Delete retry scheduled', item.table, err?.message || err);
                        item.attempts = (item.attempts || 0) + 1;
                        item.nextTryAt = Date.now() + this.backoffDelay(item.attempts);
                        this.save();
                    }
                }
            }
        };
        deleteQueue.load();
        setInterval(() => { try { deleteQueue.process(); } catch { } }, 30000);
        window.addEventListener('online', () => { try { deleteQueue.process(); } catch { } });

        async function deleteOne(table, keySource) {
            if (!syncEnabled || !currentUser) {
                try { deleteQueue.enqueue(table, keySource); } catch { }
                return;
            }
            try {
                const keys = deleteQueue.buildDeleteKeys(table, keySource);
                const { error } = await supabase.from(table)
                    .delete()
                    .match({ user_id: currentUser.id, ...keys });
                if (error) throw error;
            } catch (error) {
                console.error(`Delete error on ${table}:`, error);
                try { deleteQueue.enqueue(table, keySource); } catch { }
            }
        }

        // ============================================
        // Offline Upsert Queue with Backoff
        // ============================================
        const UPSERT_QUEUE_KEY = 'tuba-upsert-queue-v1';
        const upsertQueue = {
            items: [],
            load() {
                try {
                    const raw = localStorage.getItem(UPSERT_QUEUE_KEY);
                    this.items = raw ? JSON.parse(raw) : [];
                } catch { this.items = []; }
            },
            save() {
                try { localStorage.setItem(UPSERT_QUEUE_KEY, JSON.stringify(this.items)); } catch { }
            },
            enqueue(table, payload) {
                const conflict = conflictTargets[table] || null;
                this.items.push({
                    id: `${table}-${Date.now()}-${Math.random().toString(36).slice(2)}`,
                    table,
                    payload,
                    conflict,
                    attempts: 0,
                    nextTryAt: Date.now() + 1000
                });
                this.save();
                console.log('üì¶ Enqueued upsert', table, payload);
            },
            backoffDelay(attempts) {
                // 1s, 2s, 5s, 10s, 30s, 60s
                const schedule = [1000, 2000, 5000, 10000, 30000, 60000];
                return schedule[Math.min(attempts, schedule.length - 1)];
            },
            async process() {
                if (!navigator.onLine || !syncEnabled || !currentUser) return;
                if (!Array.isArray(this.items) || this.items.length === 0) return;
                const now = Date.now();
                // Work on a shallow copy to avoid mutation issues
                for (const item of [...this.items]) {
                    if (item.nextTryAt && item.nextTryAt > now) continue;
                    try {
                        const data = { ...item.payload, user_id: currentUser.id };
                        if (item.table === 'products') { data.category = data.category || ''; }
                        if (item.conflict) {
                            const { error } = await supabase.from(item.table).upsert(data, { onConflict: item.conflict });
                            if (error) throw error;
                        } else {
                            const { error } = await supabase.from(item.table).upsert(data);
                            if (error) throw error;
                        }
                        // Success: remove from queue
                        this.items = this.items.filter(q => q.id !== item.id);
                        this.save();
                        console.log('‚úÖ Upsert queue processed', item.table);
                    } catch (err) {
                        console.warn('‚è≥ Upsert retry scheduled', item.table, err?.message || err);
                        item.attempts = (item.attempts || 0) + 1;
                        item.nextTryAt = Date.now() + this.backoffDelay(item.attempts);
                        // If too many attempts, keep but slow down; do not drop silently
                        this.save();
                    }
                }
            }
        };
        // Initialize queue and periodic processing
        upsertQueue.load();
        setInterval(() => { try { upsertQueue.process(); } catch { } }, 30000);
        window.addEventListener('online', () => { try { upsertQueue.process(); } catch { } });
        async function upsertOne(table, payload) {
            if (!syncEnabled || !currentUser) {
                try { upsertQueue.enqueue(table, payload); } catch { }
                return;
            }
            try {
                const data = { ...payload, user_id: currentUser.id };
                if (table === 'products') { data.category = data.category || ''; }
                const conflict = conflictTargets[table];
                if (conflict) {
                    const { error } = await supabase.from(table).upsert(data, { onConflict: conflict });
                    if (error) throw error;
                } else {
                    const { error } = await supabase.from(table).upsert(data);
                    if (error) throw error;
                }
            } catch (error) {
                console.error(`Upsert error on ${table}:`, error);
                // If offline or error, enqueue for retry
                try { upsertQueue.enqueue(table, payload); } catch { }
            }
        }
        let state = {
            activeTab: 'sales',
            activeTransactionChannel: 'mpesa',
            products: [],
            sales: [],
            expenses: [],
            customers: [],
            invoices: [],
            receipts: [],
            categories: [],
            inventory: {},
            notes: [],
            transactions: [],
            unpaidEntries: [],
            currentNoteIndex: null,
            editingNoteIndex: null,
            collapsedSections: {},
            listExpanded: {},
            selectedItems: {},
            transactionFloats: {
                mpesa: { initial: 0, current: 0 },
                crdb: { initial: 0, current: 0 },
                nmb: { initial: 0, current: 0 },
                airtel: { initial: 0, current: 0 },
                halopesa: { initial: 0, current: 0 },
                yas: { initial: 0, current: 0 }
            },
            inventoryFilters: {
                PeriodNumber: '',
                supplier: '',
                dateFrom: '',
                dateTo: ''
            },
            searchPeriod: '',
            filterDateFrom: '',
            filterDateTo: '',
            filterCategory: '',
            filterCustomer: '',
            dailyTarget: 0,
            monthlyTarget: 0,
            userProfile: {
                businessName: "",
                email: "",
                phone: "",
                address: ""
            },
            // User logo
            userLogoDataUrl: '',
            userLogoMime: '',
            userLogoPublicUrl: '',
            profileEditMode: false,
            profileLoaded: false,
            privacyBlurred: true,  // ADD THIS LINE
            // Daily backup reminder tracking
            backupReminder: { date: '', count: 0 }
        };

        let chartInstance = null;
        let cachedStats = null;
        let lastStatsUpdate = 0;
        let isSyncing = false;
        let idCounters = {              // ADD THIS ENTIRE OBJECT
            sales: 0,
            products: 0,
            expenses: 0,
            customers: 0,
            invoices: 0,
            categories: 0,
            notes: 0,
            transactions: 0,
            unpaid: 0
        };

        function getTodayDateString() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`; // Returns: 2025-01-15
        }

        // Show a backup reminder up to 3 times per day
        function maybeShowBackupReminder() {
            try {
                const today = getTodayDateString();
                if (!state.backupReminder || state.backupReminder.date !== today) {
                    state.backupReminder = { date: today, count: 0 };
                }
                if ((state.backupReminder.count || 0) < 3) {
                    setTimeout(() => {
                        // Click anywhere on toast to save/export immediately
                        showToast('Consider Local Backup', 'info', null, null, 3000, () => exportData('Saved', 2000));
                    }, 600);
                    state.backupReminder.count = (state.backupReminder.count || 0) + 1;
                    saveData();
                }
            } catch (e) { /* no-op */ }
        }

        // ID Generation Functions
        function generateID(type) {
            const prefix = {
                'sales': 'S',
                'products': 'P',
                'expenses': 'E',
                'customers': 'C',
                'transactions': 'T',
                'unpaid': 'U',
                'notes': 'N',
                'categories': 'CAT',
                'invoices': 'INV'
            }[type] || 'X';

            let maxId = 0;
            const items = type === 'unpaid' ? state.unpaidEntries : (state[type] || []);

            items.forEach(item => {
                if (item.id && item.id.startsWith(prefix + '-')) {
                    const num = parseInt(item.id.split('-')[1]);
                    if (!isNaN(num) && num > maxId) maxId = num;
                }
            });

            return `${prefix}-${String(maxId + 1).padStart(6, '0')}`;
        }

        function ensureIDs() {
            // Add IDs to existing data
            state.sales.forEach(s => { if (!s.id) s.id = generateID('sales'); });
            state.products.forEach(p => { if (!p.id) p.id = generateID('products'); });
            state.expenses.forEach(e => { if (!e.id) e.id = generateID('expenses'); });
            state.customers.forEach(c => { if (!c.id) c.id = generateID('customers'); });
            state.transactions.forEach(t => { if (!t.id) t.id = generateID('transactions'); });
            state.unpaidEntries.forEach(u => { if (!u.id) u.id = generateID('unpaid'); });
            state.notes.forEach(n => { if (!n.id) n.id = generateID('notes'); });
        }

        function formatNumber(num) {
            if (num === null || num === undefined || isNaN(num)) return '0';
            const n = Math.round(parseFloat(num));
            const sign = n < 0 ? '-' : '';
            const abs = Math.abs(n);
            return sign + String(abs).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }
        function formatMoney(num) { return formatNumber(num); }
        function parseMoney(str) {
            if (typeof str === 'number') return str;
            if (!str) return 0;
            const cleaned = String(str).replace(/[^0-9\-]/g, '');
            const n = parseInt(cleaned || '0', 10);
            return isNaN(n) ? 0 : n;
        }
        function attachMoneyFormatter(el, { max = 999999999, min = 0 } = {}) {
            if (!el) return;
            const fmt = (v) => formatMoney(Math.max(min, Math.min(max, v)));
            const handle = () => {
                const val = parseMoney(el.value);
                el.dataset.numeric = String(val);
                el.value = fmt(val);
            };
            el.addEventListener('input', handle);
            el.addEventListener('blur', handle);
            // Initialize
            handle();
        }

        function loadData() {
            const saved = localStorage.getItem('financeManagerData');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    state = { ...state, ...parsed };

                    // Ensure userProfile exists
                    if (!state.userProfile) {
                        state.userProfile = {
                            businessName: "",
                            email: "",
                            phone: "",
                            address: ""
                        };
                    }

                    // Ensure profileEditMode exists
                    if (state.profileEditMode === undefined) {
                        state.profileEditMode = false;
                    }

                    // Calculate current float balances
                    calculateFloatBalances();

                    // Ensure all items have IDs
                    ensureIDs();
                } catch (e) {
                    console.error('Error loading data:', e);
                }
            }

            // Always ensure IDs exist
            if (state.sales) ensureIDs();
        }

        // Logo helpers
        // function triggerLogoUpload() {
        //     const input = document.createElement('input');
        //     input.type = 'file';
        //     input.accept = 'image/png,image/jpeg';
        //     input.onchange = async (e) => {
        //         const file = e.target.files && e.target.files[0];
        //         if (!file) return;
        //         try {
        //             const resized = await resizeImageFile(file, 256);
        //             state.userLogoDataUrl = resized.dataUrl;
        //             state.userLogoMime = resized.mime;
        //             saveData();
        //             render();
        //             if (syncEnabled && currentUser) {
        //                 await uploadLogoToSupabase(resized.dataUrl, resized.mime);
        //             }
        //             showToast('Logo saved', 'success');
        //         } catch (err) {
        //             console.error('Logo upload error:', err);
        //             showToast('Failed to process logo', 'error');
        //         }
        //     };
        //     input.click();
        // }

        async function resizeImageFile(file, size = 256) {
            const img = document.createElement('img');
            const reader = new FileReader();
            const mime = file.type.includes('png') ? 'image/png' : 'image/jpeg';
            const dataUrl = await new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = dataUrl;
            });

            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, size, size);
            // contain image
            const ratio = Math.min(size / img.width, size / img.height);
            const w = Math.round(img.width * ratio);
            const h = Math.round(img.height * ratio);
            const x = Math.round((size - w) / 2);
            const y = Math.round((size - h) / 2);
            ctx.drawImage(img, x, y, w, h);
            const outDataUrl = canvas.toDataURL(mime, 0.92);
            return { dataUrl: outDataUrl, mime };
        }

        // async function uploadLogoToSupabase(dataUrl, mime = 'image/png') {
        //     try {
        //         if (!supabase || !currentUser) return;
        //         const blob = await (await fetch(dataUrl)).blob();
        //         const ext = mime === 'image/png' ? 'png' : 'jpg';
        //         const path = `${currentUser.id}/logo.${ext}`;
        //         const { error: upErr } = await supabase.storage.from('logos').upload(path, blob, { upsert: true, contentType: mime });
        //         if (upErr) { console.error('Supabase storage upload error:', upErr); return; }
        //         const { data: pub } = supabase.storage.from('logos').getPublicUrl(path);
        //         if (pub && pub.publicUrl) {
        //             state.userLogoPublicUrl = pub.publicUrl;
        //             saveData();
        //             // Persist into profile for portability (create if missing)
        //             try {
        //                 const { error: upsertErr } = await supabase
        //                     .from('user_profiles')
        //                     .upsert({ user_id: currentUser.id, logo_url: state.userLogoPublicUrl }, { onConflict: 'user_id' });
        //                 if (upsertErr) console.warn('Failed to upsert logo_url to profile:', upsertErr);
        //             } catch (e) { console.warn('Failed to save logo_url to profile:', e); }
        //         }
        //     } catch (e) {
        //         console.error('Upload logo error:', e);
        //     }
        // }

        function getLogoForPdf() {
            const dataUrl = state.userLogoDataUrl || '';
            if (!dataUrl) return null;
            const format = dataUrl.startsWith('data:image/png') ? 'PNG' : 'JPEG';
            return { dataUrl, format };
        }

        // Ensure logo base64 is hydrated before PDF generation
        async function ensureLogoReady() {
            if (state.userLogoDataUrl) return true;
            if (state.userLogoPublicUrl) {
                try {
                    const res = await fetch(state.userLogoPublicUrl, { cache: 'no-cache' });
                    const blob = await res.blob();
                    const reader = new FileReader();
                    const base64 = await new Promise((resolve, reject) => {
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                    state.userLogoDataUrl = base64;
                    state.userLogoMime = blob.type.includes('png') ? 'image/png' : 'image/jpeg';
                    saveData();
                    return true;
                } catch (e) {
                    console.warn('ensureLogoReady: failed to hydrate logo from URL', e);
                }
            }
            return false;
        }

        // Draw logo inside a circular placeholder, clipped to the circle and filling it
        function drawLogo(doc, x, y, size, options = {}) {
            const logo = getLogoForPdf();
            if (!logo) return false;

            const {
                borderColor = [180, 180, 180],
                borderWidth = 1
            } = options;

            const cx = x + size / 2;
            const cy = y + size / 2;
            const r = size / 2;

            try {
                // Clip to circle and draw image to fully fill the circle
                doc.saveGraphicsState();
                doc.beginPath();
                doc.circle(cx, cy, r);
                doc.clip();
                doc.addImage(logo.dataUrl, logo.format, x, y, size, size);
                doc.restoreGraphicsState();

                // Circle border on top
                doc.setDrawColor(...borderColor);
                doc.setLineWidth(borderWidth);
                doc.circle(cx, cy, r, 'S');
                return true;
            } catch (e) {
                console.warn('Logo draw error:', e);
                return false;
            }
        }

        function saveData() {
            cachedStats = null; // Clear cache when data changes
            try {
                localStorage.setItem('financeManagerData', JSON.stringify(state));
            } catch (e) {
                console.error('Error saving data:', e);
                showToast('Error saving data!', 'error');
            }
        }

        function calculateFloatBalances() {
            // Reset to initial values
            Object.keys(state.transactionFloats).forEach(channel => {
                state.transactionFloats[channel].current = state.transactionFloats[channel].initial;
            });

            // Apply all transactions
            (state.transactions || []).forEach(t => {
                if (state.transactionFloats[t.channel]) {
                    if (t.type === 'deposit') {
                        state.transactionFloats[t.channel].current += t.amount;
                    } else if (t.type === 'withdrawal') {
                        state.transactionFloats[t.channel].current -= t.amount;
                    }
                }
            });
        }

        function getStats() {
            const currentTime = Date.now();

            // Return cached stats if less than 3 seconds old
            if (cachedStats && (currentTime - lastStatsUpdate) < 3000) {
                return cachedStats;
            }

            const totalCapital = state.sales.reduce((sum, s) => sum + (s.totalCost || 0), 0);
            const totalProfit = state.sales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const totalRevenue = state.sales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);

            const today = getTodayDateString();
            const todaySales = state.sales.filter(s => s.date === today);
            const todayProfit = todaySales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const todayRevenue = todaySales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);

            const yesterdayDate = new Date(Date.now() - 86400000);
            const yesterday = `${yesterdayDate.getFullYear()}-${String(yesterdayDate.getMonth() + 1).padStart(2, '0')}-${String(yesterdayDate.getDate()).padStart(2, '0')}`;
            const yesterdayProfit = state.sales.filter(s => s.date === yesterday).reduce((sum, s) => sum + (s.profit || 0), 0);

            const now = new Date();
            const monthStartDate = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthStart = `${monthStartDate.getFullYear()}-${String(monthStartDate.getMonth() + 1).padStart(2, '0')}-${String(monthStartDate.getDate()).padStart(2, '0')}`;
            const monthSales = state.sales.filter(s => new Date(s.date) >= new Date(monthStart));
            const monthProfit = monthSales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const monthRevenue = monthSales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);

            const totalExpenses = state.expenses.reduce((sum, e) => sum + (e.amount || 0), 0);
            const monthExpenses = state.expenses.filter(e => new Date(e.date) >= new Date(monthStart)).reduce((sum, e) => sum + (e.amount || 0), 0);

            const totalInvoiced = state.invoices.reduce((sum, inv) => sum + (inv.amount || 0), 0);
            const totalPaid = state.invoices.filter(inv => inv.status === 'Paid').reduce((sum, inv) => sum + (inv.amount || 0), 0);

            const netProfit = totalProfit - totalExpenses;
            const monthNetProfit = monthProfit - monthExpenses;

            cachedStats = {
                totalCapital,
                totalProfit,
                totalRevenue,
                todayProfit,
                todayRevenue,
                yesterdayProfit,
                monthProfit,
                monthRevenue,
                monthNetProfit,
                totalExpenses,
                monthExpenses,
                totalInvoiced,
                totalPaid,
                netProfit,
                totalSalesCount: state.sales.length,
                todaySalesCount: todaySales.length
            };

            lastStatsUpdate = now;
            return cachedStats;
        }


        const tabs = [
            { id: 'dashboard', label: 'Dashboard', icon: 'üìä' },
            { id: 'account', label: 'Account', icon: 'üë§' },  // ADD THIS LINE
            { id: 'sales', label: 'Sales', icon: 'üí∞' },
            { id: 'transactions', label: 'Money', icon: 'üí≥' },
            { id: 'products', label: 'Products/Services', icon: 'üõçÔ∏è' },
            { id: 'categories', label: 'Categories', icon: 'üìÅ' },
            { id: 'expenses', label: 'Expenses', icon: 'üí∏' },
            { id: 'inventory', label: 'Stock', icon: 'üì¶' },
            { id: 'inventoryPurchases', label: 'Inventory', icon: 'üì¶' },
            { id: 'customers', label: 'Customers', icon: 'üë•' },
            { id: 'invoices', label: 'Invoices & Receipts', icon: 'üìÑ' },
            { id: 'analytics', label: 'Analytics', icon: 'üìà' },
            { id: 'unpaid', label: 'Unpaid', icon: '‚è≥' },
            { id: 'notes', label: 'Notes', icon: 'üìù' }
        ];

        function renderNav() {
            const nav = document.getElementById('bottomNav');
            nav.innerHTML = tabs.map(tab => `
                <button class="nav-item ${state.activeTab === tab.id ? 'active' : ''}" onclick="switchTab('${tab.id}')">
                    <span class="nav-icon">${tab.icon}</span>
                    <span>${tab.label}</span>
                </button>
            `).join('');
        }

        function switchTab(tabId) {
            state.activeTab = tabId;
            // Reset privacy blur when switching away from sales
            if (tabId !== 'sales') {
                state.privacyBlurred = true;
            }
            render();
        }

        // FAB features removed; bottom tabs restored

        function showToast(message, type = "info", actionText = null, actionHandler = null, durationMs = 3000, onClickHandler = null) {
            let bar = document.getElementById('toastBar');
            if (!bar) {
                bar = document.createElement('div');
                bar.id = 'toastBar';
                bar.className = 'toast-bar';
                document.body.appendChild(bar);
            }

            const t = document.createElement('div');
            t.className = 'toast toast-' + type;
            const key = (type + ':' + message).toLowerCase();
            t.setAttribute('data-key', key);
            try {
                const existing = Array.from(bar.querySelectorAll('.toast')).find(el => el.getAttribute('data-key') === key);
                if (existing) {
                    existing.classList.remove('show');
                    setTimeout(() => existing.remove(), 0);
                }
            } catch { }
            const span = document.createElement('span');
            span.textContent = message;
            t.appendChild(span);
            if (actionText && typeof actionHandler === 'function') {
                const btn = document.createElement('button');
                btn.textContent = actionText;
                btn.style.cssText = 'margin-left:8px; padding:4px 8px; font-size:10px; border-radius:8px; border:none; background:#fff; color:#000; cursor:pointer;';
                btn.onclick = (e) => { e.stopPropagation(); try { actionHandler(); } finally { t.classList.remove('show'); setTimeout(() => t.remove(), 150); } };
                t.appendChild(btn);
            }
            if (typeof onClickHandler === 'function') {
                t.onclick = () => { try { onClickHandler(); } finally { t.classList.remove('show'); setTimeout(() => t.remove(), 150); } };
            }
            bar.prepend(t);
            requestAnimationFrame(() => t.classList.add('show'));
            setTimeout(() => { t.classList.remove('show'); setTimeout(() => t.remove(), 300); }, Math.max(1000, durationMs || 3000));
        }

        function downloadPDFSafe(doc, filename) {
            try {
                const ua = navigator.userAgent || navigator.vendor || window.opera;
                const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                if (isIOS) {
                    try {
                        const dataUrl = doc.output('dataurlstring');
                        openPdfViewer(dataUrl, filename);
                        return;
                    } catch { }
                    try {
                        const blob = doc.output('blob');
                        const url = URL.createObjectURL(blob);
                        openPdfViewer(url, filename);
                        return;
                    } catch { }
                }
                try {
                    const blob = doc.output('blob');
                    const url = URL.createObjectURL(blob);
                    openPdfViewer(url, filename);
                    return;
                } catch { }
                try { doc.save(filename); } catch { }
            } catch { }
        }

        let __pdfViewerURL = null;
        let __pdfFilename = 'document.pdf';
        function openPdfViewer(url, filename) {
            __pdfFilename = filename || 'document.pdf';
            const modal = document.getElementById('pdfViewerModal');
            const iframe = document.getElementById('pdfIframe');
            const btn = document.getElementById('pdfDownloadBtn');
            const titleEl = document.getElementById('pdfViewerTitle');
            iframe.src = url;
            modal.classList.add('show');
            if (titleEl) {
                try { titleEl.textContent = 'PDF Preview ‚Äî ' + __pdfFilename; } catch { }
            }
            btn.onclick = function () {
                (async function () {
                    try {
                        const ua = navigator.userAgent || navigator.vendor || window.opera;
                        const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                        if (isIOS && navigator.share && navigator.canShare) {
                            let blob;
                            try {
                                const res = await fetch(url);
                                blob = await res.blob();
                            } catch { }
                            if (blob) {
                                const file = new File([blob], __pdfFilename, { type: 'application/pdf' });
                                if (navigator.canShare({ files: [file] })) {
                                    try { await navigator.share({ files: [file], title: __pdfFilename }); return; } catch { }
                                }
                            }
                        }
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = __pdfFilename;
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => { a.remove(); }, 100);
                    } catch { }
                })();
            };
            __pdfViewerURL = url;
        }
        function closePdfViewer() {
            const modal = document.getElementById('pdfViewerModal');
            const iframe = document.getElementById('pdfIframe');
            const titleEl = document.getElementById('pdfViewerTitle');
            modal.classList.remove('show');
            iframe.src = '';
            if (titleEl) {
                try { titleEl.textContent = 'PDF Preview'; } catch { }
            }
            if (__pdfViewerURL && __pdfViewerURL.startsWith('blob:')) {
                try { URL.revokeObjectURL(__pdfViewerURL); } catch { }
            }
            __pdfViewerURL = null;
        }

        function showConfirm(text, onYes) {
            if (confirm(text)) {
                onYes();
            }
        }

        function ensureWalkIn() {
            if (!state.customers) state.customers = [];
            const exists = state.customers.some(c => c && c.name && c.name.toString().toLowerCase().includes('walk'));
            if (!exists) {
                state.customers.unshift({ name: 'WALK IN', email: '', phone: '', address: '', totalPurchases: 0 });
                saveData();
            }
        }
        ensureWalkIn();

        function renderDashboard() {
            const stats = getStats();
            const lowStockProducts = state.products.filter(p => {
                const inv = state.inventory[p.name] || { stock: 0, minAlert: 5 };
                return (p.hasStock !== false) && (inv.stock <= inv.minAlert);
            });

            const unpaidCount = state.unpaidEntries.filter(e => !e.paid).length;
            const unpaidAmount = state.unpaidEntries.filter(e => !e.paid).reduce((sum, e) => sum + (e.amount || 0), 0);

            const dailyProgress = state.dailyTarget > 0 ? (stats.todayProfit / state.dailyTarget * 100) : 0;
            const monthlyProgress = state.monthlyTarget > 0 ? (stats.monthProfit / state.monthlyTarget * 100) : 0;

            return `
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
        <div class="stat-card" onclick="switchTab('sales')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">TODAY'S PROFIT</div>
            <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.todayProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 11px;">${stats.todaySalesCount} sales today</div>
            ${state.dailyTarget > 0 ? `
                <div class="progress-bar" style="height: 6px; margin-top: 6px;">
                    <div class="progress-fill" style="width: ${Math.min(dailyProgress, 100)}%"></div>
                </div>
                <div class="stat-subvalue" style="font-size: 10px; margin-top: 4px;">${dailyProgress.toFixed(0)}% of target</div>
            ` : ''}
        </div>
        
        <div class="stat-card" onclick="switchTab('sales')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">YESTERDAY'S PROFIT</div>
            <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.yesterdayProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 10px;">
                ${stats.todayProfit > stats.yesterdayProfit ? 'üìà Better!' :
                    stats.todayProfit < stats.yesterdayProfit ? 'üìâ Lower' : '‚û°Ô∏è Same'}
            </div>
        </div>

        <div class="stat-card" onclick="switchTab('analytics')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">MONTH PROFIT</div>
            <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.monthProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 10px;">Revenue: ${formatNumber(stats.monthRevenue)} Tsh</div>
            ${state.monthlyTarget > 0 ? `
                <div class="progress-bar" style="height: 6px; margin-top: 6px;">
                    <div class="progress-fill" style="width: ${Math.min(monthlyProgress, 100)}%"></div>
                </div>
                <div class="stat-subvalue" style="font-size: 10px; margin-top: 4px;">${monthlyProgress.toFixed(0)}% of target</div>
            ` : ''}
        </div>

        <div class="stat-card" onclick="switchTab('analytics')" style="background: ${stats.monthNetProfit >= 0 ? '#2e7d32' : '#d32f2f'}; padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">NET PROFIT (MONTH)</div>
            <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.monthNetProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 10px;">Expenses: ${formatNumber(stats.monthExpenses)} Tsh</div>
        </div>

        <div class="stat-card" onclick="switchTab('unpaid')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">UNPAID ENTRIES</div>
            <div class="stat-value" style="font-size: 18px;">${unpaidCount}</div>
            <div class="stat-subvalue" style="font-size: 10px;">Total: ${formatNumber(unpaidAmount)} Tsh</div>
        </div>

        <div class="stat-card" onclick="switchTab('inventory')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">LOW STOCK ALERT</div>
            <div class="stat-value" style="font-size: 18px;">${lowStockProducts.length}</div>
            <div class="stat-subvalue" style="font-size: 10px;">${lowStockProducts.length > 0 ? '‚ö†Ô∏è Check inventory' : '‚úÖ All good'}</div>
        </div>
    </div>

                ${lowStockProducts.length > 0 ? `
                    <div class="alert-box-danger">
                        <strong>‚ö†Ô∏è Low Stock Alert!</strong><br>
                        ${lowStockProducts.slice(0, 3).map(p => `‚Ä¢ ${p.name}`).join('<br>')}
                        ${lowStockProducts.length > 3 ? `<br>...and ${lowStockProducts.length - 3} more` : ''}
                    </div>
                ` : ''}

                ${unpaidCount > 0 ? `
                    <div class="alert-box">
                        <strong>üí∞ Pending Payments</strong><br>
                        You have ${unpaidCount} unpaid entries totaling ${formatNumber(unpaidAmount)} Tsh
                    </div>
                ` : ''}

                <div class="card">
                    <h2>Quick Actions</h2>
                    <div class="flex-gap">
                        <button class="btn-success btn-small" onclick="switchTab('sales')">‚ûï New Sale</button>
                        <button class="btn-danger btn-small" onclick="switchTab('expenses')">üí∏ Add Expense</button>
                        <button class="btn-small" onclick="switchTab('products')">üõí Manage Products/Services</button>
                        <button class="btn-small" onclick="switchTab('transactions')">üí≥ Transactions</button>
                        <button class="btn-small" onclick="switchTab('inventoryPurchases')">üì¶ Inventory</button>
                        <button class="btn-small" onclick="switchTab('invoices')" style="background: linear-gradient(145deg, #1976d2, #0d47a1); color: white;">üìÑ Invoices</button>
                        <button class="btn-small" onclick="switchTab('notes')" style="background: linear-gradient(145deg, #e65100, #bf360c); color: white;">üìù Notes</button>
                        <button class="btn-small" onclick="switchTab('analytics')" style="background: linear-gradient(145deg, #7b1fa2, #4a148c); color: white;">üìà Analytics</button>
                    </div>
                </div>

                <div class="card">
                    <h2>Set Daily Target</h2>
                    <div class="form-group">
                        <label>Daily Profit Target (Tsh)</label>
                        <input type="text" class="money-input" id="dailyTarget" value="${formatMoney(state.dailyTarget || 0)}">
                    </div>
                    <button onclick="setDailyTarget()">Save Target</button>
                </div>

                <div class="card">
                    <h2>Set Monthly Target</h2>
                    <div class="form-group">
                        <label>Monthly Profit Target (Tsh)</label>
                        <input type="text" class="money-input" id="monthlyTarget" value="${formatMoney(state.monthlyTarget || 0)}">
                    </div>
                    <button onclick="setMonthlyTarget()">Save Target</button>
                </div>

                <div class="card">
                    <h2>Recent Activity</h2>
                    ${state.sales.slice().reverse().slice(0, 5).map(s => `
                        <div class="item">
                            <div class="item-header">
                                <span class="item-title">${s.productName}</span>
                                <span style="color: #2e7d32; font-weight: 700;">üí± ${formatNumber(s.profit)} Tsh</span>
                            </div>
                            <div class="item-subtitle">
                                ${s.date} ${s.time} | ${s.customer}
                            </div>
                        </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No recent activity</p>'}
                </div>
            `;
        }

        async function setDailyTarget() {
            const el = document.getElementById('dailyTarget');
            const value = parseMoney(el?.value) || 0;
            if (value < 0 || value > 999999999) return showToast('Enter amount between 0 and 999,999,999', 'error');
            state.dailyTarget = value;
            saveData();
            showToast('Daily target updated', 'success');
            if (syncEnabled) {
                await upsertOne('settings', { daily_target: value });
                const ok = await verifyCloudSettings('daily_target', value);
                if (!ok) { showToast('Cloud verify failed; will retry', 'info'); }
                syncInBackground();
            }
            render();
        }

        async function setMonthlyTarget() {
            const el = document.getElementById('monthlyTarget');
            const value = parseMoney(el?.value) || 0;
            if (value < 0 || value > 999999999) return showToast('Enter amount between 0 and 999,999,999', 'error');
            state.monthlyTarget = value;
            saveData();
            showToast('Monthly target updated', 'success');
            if (syncEnabled) {
                await upsertOne('settings', { monthly_target: value });
                const ok = await verifyCloudSettings('monthly_target', value);
                if (!ok) { showToast('Cloud verify failed; will retry', 'info'); }
                syncInBackground();
            }
            render();
        }

        async function verifyCloudSettings(field, expected) {
            try {
                const { data, error } = await supabase.from('settings').select(field).eq('user_id', currentUser.id).single();
                if (error) return false;
                const val = parseFloat(data?.[field] || 0);
                return Math.round(val) === Math.round(expected);
            } catch { return false; }
        }

        function renderAccount() {
            // Get profile data (works offline or online)
            const profile = getUserProfileData();

            // Check if profile is incomplete
            const isProfileIncomplete = !profile.businessName || !profile.phone || !profile.address;

            if (!currentUser) {
                // NOT SIGNED IN VIEW
                return `
            ${isProfileIncomplete && state.profileEditMode ? `
                <div class="alert-box" style="animation: highlightFade 2s ease-out;">
                    <strong>üìã Complete Your Profile!</strong><br>
                    Please fill in your business information below for personalized invoices and reports.
                </div>
            ` : ''}
            
            <div class="card" id="userProfileCard">
                <h2>üë§ User Profile (Offline Mode)</h2>
                <div class="alert-info" style="margin-bottom: 16px;">
                    <strong>‚ÑπÔ∏è Offline Profile:</strong> Your profile is saved locally. Sign in to sync across devices.
                </div>
                <form onsubmit="updateUserProfile(event)">
                    <div class="form-group">
                        <label>Business Name</label>
                        <input 
                            type="text"
                            id="profileBusinessName"
                            value="${profile.businessName}"
                            placeholder="Enter business name"
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    <div class="form-group">
                        <label>Email</label>
                        <input 
                            type="email" 
                            id="profileEmail" 
                            value="${profile.email}" 
                            placeholder="youremail@domain.com" 
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    <div class="form-group">
                        <label>Phone Number</label>
                        <input 
                            type="tel" 
                            id="profilePhone" 
                            value="${profile.phone}" 
                            placeholder="+00000000000" 
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    <div class="form-group">
                        <label>Address</label>
                        <input 
                            type="text" 
                            id="profileAddress" 
                            value="${profile.address}" 
                            placeholder="your Address" 
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    
                    <div style="display: flex; gap: 12px;">
                        <button 
                            type="submit" 
                            class="btn-success" 
                            style="flex: 1; ${state.profileEditMode ? '' : 'opacity: 0.5; cursor: not-allowed;'}"
                            ${state.profileEditMode ? '' : 'disabled'}>
                            üíæ Save Profile
                        </button>
                        
                        ${!state.profileEditMode ? `
                            <button 
                                type="button" 
                                class="btn" 
                                style="flex: 1;"
                                onclick="enableProfileEdit()">
                                ‚úèÔ∏è Edit
                            </button>
                        ` : ''}
                    </div>
                </form>
            </div>
            
            <div class="card">
                <h2>‚òÅÔ∏è Cloud Sync</h2>
                <p style="margin-bottom: 16px; color: #666;">
                    Sign in to sync your data across all devices!
                </p>
                
                <div class="transaction-tabs" style="margin-bottom: 20px;">
                    <button class="transaction-tab mpesa active" id="loginTab" onclick="switchAuthTab('login')">
                        Sign In
                    </button>
                    <button class="transaction-tab crdb" id="signupTab" onclick="switchAuthTab('signup')">
                        Sign Up
                    </button>
                </div>

                <div id="loginForm">
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="loginEmail" placeholder="your@email.com" name="username" autocomplete="username" autocapitalize="none" autocorrect="off">
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <input type="password" id="loginPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" name="current-password" autocomplete="current-password">
                    </div>
                    <button onclick="handleSignIn()">Sign In</button>
                </div>

                <div id="signupForm" style="display: none;">
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="signupEmail" placeholder="your@email.com">
                    </div>
                    <div class="form-group">
                        <label>Password (min 6 characters)</label>
                        <input type="password" id="signupPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <div class="form-group">
                        <label>Confirm Password</label>
                        <input type="password" id="signupPasswordConfirm" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <button onclick="handleSignUp()">Create Account</button>
                </div>

                <!--
                <div class="card" style="margin-top: 12px;">
                    <h3>üñºÔ∏è Business Logo</h3>
                    <p style="color:#666;font-size:13px;margin-bottom:8px;">Upload your logo (PNG/JPEG). It appears on all PDFs before your business name.</p>
                    <div style="display:flex;align-items:center;gap:12px;">
                        <div id="logoPreview" style="width:64px;height:64px;border-radius:50%;background:#f5f5f5;border:2px solid rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;overflow:hidden;">
                            ${(state.userLogoDataUrl || state.userLogoPublicUrl)
                        ? `<img src="${state.userLogoDataUrl || state.userLogoPublicUrl}" alt="Logo" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                        : '<span style="font-size:12px;color:#999;">No logo</span>'}
                        </div>
                        <button class="btn-secondary" onclick="triggerLogoUpload()">Upload Logo</button>
                    </div>
                    <small style="display:block;color:#888;margin-top:6px;">Recommended size: 256√ó256 px (auto-resized).</small>
                </div>
                -->

                <div class="alert-info">
                    <strong>Benefits of Cloud Sync:</strong>
                    <ul style="margin-top: 8px; padding-left: 20px; font-size: 13px; color: #666;">
                        <li>Access from any device</li>
                        <li>Automatic backup</li>
                        <li>Real-time updates</li>
                        <li>Never lose data</li>
                    </ul>
                </div>
            </div>
        `;
            }

            // SIGNED IN VIEW
            return `
        <div class="card">
            <h2>‚òÅÔ∏è Account</h2>
            <div class="alert-success">
                <div style="font-size: 14px; margin-bottom: 8px;">
                    ‚úî Connected to Cloud
                </div>
                <div style="font-size: 13px;">
                    üìß ${currentUser.email}
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                <button onclick="pullFromCloud()" class="btn-success">
                    ‚¨áÔ∏è Pull from Cloud
                </button>
                <button onclick="pushToCloud()" class="btn-success">
                    ‚¨ÜÔ∏è Push to Cloud
                </button>
            </div>

            <button onclick="syncAllData()" class="btn" style="margin-bottom: 12px;">
                üîÑ Smart Sync
            </button>

            <button onclick="cleanDuplicatesFromUI()" class="btn-danger" style="margin-bottom: 12px;">
                üßπ Clean Cloud Duplicates
            </button>
            
            <button onclick="signOut()" class="btn-danger" style="margin-bottom: 12px;">
                Sign Out
            </button>
            
            <!--
            <div class="card" style="margin-top: 12px;">
                <h3>üñºÔ∏è Business Logo</h3>
                <p style="color:#666;font-size:13px;margin-bottom:8px;">Upload your logo (PNG/JPEG). It appears on all PDFs before your business name.</p>
                <div style="display:flex;align-items:center;gap:12px;">
                    <div id="logoPreview" style="width:64px;height:64px;border-radius:50%;background:#f5f5f5;border:2px solid rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;overflow:hidden;">
                        ${(state.userLogoDataUrl || state.userLogoPublicUrl)
                    ? `<img src="${state.userLogoDataUrl || state.userLogoPublicUrl}" alt="Logo" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                    : '<span style="font-size:12px;color:#999;">No logo</span>'}
                    </div>
                    <button class="btn-secondary" onclick="triggerLogoUpload()">Upload Logo</button>
                </div>
                <small style="display:block;color:#888;margin-top:6px;">Recommended size: 256√ó256 px (auto-resized).</small>
            </div>
            -->
            
            <!-- Removed in-app dashboard refresh button -->

            <div class="alert-info">
                <strong>Sync Options:</strong><br>
                ‚Ä¢ <strong>Pull from Cloud:</strong> Download cloud data (overwrites local)<br>
                ‚Ä¢ <strong>Push to Cloud:</strong> Upload local data (overwrites cloud)<br>
                ‚Ä¢ <strong>Smart Sync:</strong> Auto-detect which direction to sync
            </div>
        </div>

        ${isProfileIncomplete && state.profileEditMode ? `
            <div class="alert-box" style="animation: highlightFade 2s ease-out;">
                <strong>üìã Complete Your Profile!</strong><br>
                Please fill in your business information below for personalized invoices and reports.
            </div>
        ` : ''}

        <div class="card" id="userProfileCard">
            <h2>üë§ User Profile</h2>
            <form onsubmit="updateUserProfile(event)">
                <div class="form-group">
                    <label>Business Name</label>
                   <input 
                    type="text"
                    id="profileBusinessName"
                    value="${profile.businessName}"
                    placeholder="Enter business name"
                    ${state.profileEditMode ? '' : 'readonly'}
                    required>
                </div>
                <div class="form-group">
                    <label>Email</label>
                    <input 
                        type="email" 
                        id="profileEmail" 
                        value="${profile.email}" 
                        placeholder="youremail@domain.com" 
                        ${state.profileEditMode ? '' : 'readonly'}
                        required>
                </div>
                <div class="form-group">
                    <label>Phone Number</label>
                    <input 
                        type="tel" 
                        id="profilePhone" 
                        value="${profile.phone}" 
                        placeholder="+00000000000" 
                        ${state.profileEditMode ? '' : 'readonly'}
                        required>
                </div>
                <div class="form-group">
                    <label>Address</label>
                    <input 
                        type="text" 
                        id="profileAddress" 
                        value="${profile.address}" 
                        placeholder="your Address" 
                        ${state.profileEditMode ? '' : 'readonly'}
                        required>
                </div>
                
                <div style="display: flex; gap: 12px;">
                    <button 
                        type="submit" 
                        class="btn-success" 
                        style="flex: 1; ${state.profileEditMode ? '' : 'opacity: 0.5; cursor: not-allowed;'}"
                        ${state.profileEditMode ? '' : 'disabled'}>
                        üíæ Save Profile
                    </button>
                    
                    ${!state.profileEditMode ? `
                        <button 
                            type="button" 
                            class="btn" 
                            style="flex: 1;"
                            onclick="enableProfileEdit()">
                            ‚úèÔ∏è Edit
                        </button>
                    ` : ''}
                </div>
            </form>
            
        <div class="alert-info" style="margin-top: 16px;">
            <strong>üìù Note:</strong> This information will be used in invoices, reports, and other documents throughout the app.
        </div>
        </div>

        <div class="card" style="margin-top: 12px;">
            <h2>üóëÔ∏è Delete Account</h2>
            <p style="margin-bottom: 16px; color: #666;">Enter your credentials to delete your account and erase your cloud data.</p>
            <div id="deleteAccountForm">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="deleteEmail" placeholder="your@email.com" name="username" autocomplete="username" autocapitalize="none" autocorrect="off">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="deletePassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" name="current-password" autocomplete="current-password">
                </div>
                <button onclick="handleDeleteAccount()">Delete Account</button>
            </div>
        </div>
    `;
        }

        async function updateUserProfile(e) {
            e.preventDefault();

            const profileData = {
                businessName: document.getElementById('profileBusinessName').value.trim(),
                email: document.getElementById('profileEmail').value.trim(),
                phone: document.getElementById('profilePhone').value.trim(),
                address: document.getElementById('profileAddress').value.trim()
            };

            const success = await saveUserProfile(profileData);

            if (success) {
                state.profileEditMode = false;
                saveData();
                showToast('Profile saved successfully!', 'success');
                render();
            }
        }

        function enableProfileEdit() {
            state.profileEditMode = true;
            saveData();
            render();
        }

        async function submitDeleteAccount(e) {
            e.preventDefault();
            try {
                if (!navigator.onLine) { showToast('Go online to delete your account', 'error'); return; }
                if (!currentUser) { showToast('Not signed in', 'error'); return; }
                const email = (document.getElementById('deleteEmail')?.value || '').trim();
                const password = (document.getElementById('deletePassword')?.value || '').trim();
                if (!email || !password) { showToast('Provide email and password', 'error'); return; }
                if (email.toLowerCase() !== String(currentUser.email || '').toLowerCase()) { showToast('Email does not match signed-in account', 'error'); return; }
                const formEl = e.target;
                const btn = formEl.querySelector('.submit');
                if (btn) { btn.disabled = true; btn.style.opacity = '0.6'; btn.style.cursor = 'not-allowed'; }
                showToast('Verifying credentials‚Ä¶', 'info', null, null, 3000);
                const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                if (error) { showToast('Invalid email or password', 'error'); if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; } return; }
                await deleteUserDataAndSignOut();
            } catch (err) { showToast('Delete failed. Try again.', 'error'); } finally {
                const btn = document.querySelector('.form .submit');
                if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; }
            }
        }

        async function handleDeleteAccount() {
            try {
                if (!navigator.onLine) { showToast('Go online to delete your account', 'error'); return; }
                if (!currentUser) { showToast('Not signed in', 'error'); return; }
                const email = (document.getElementById('deleteEmail')?.value || '').trim();
                const password = (document.getElementById('deletePassword')?.value || '').trim();
                if (!email || !password) { showToast('Provide email and password', 'error'); return; }
                if (email.toLowerCase() !== String(currentUser.email || '').toLowerCase()) { showToast('Email does not match signed-in account', 'error'); return; }
                const deleteForm = document.getElementById('deleteAccountForm');
                const btn = deleteForm ? deleteForm.querySelector('button') : null;
                if (btn) { btn.disabled = true; btn.style.opacity = '0.6'; btn.style.cursor = 'not-allowed'; }
                showToast('Verifying credentials‚Ä¶', 'info', null, null, 3000);
                const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                if (error) { showToast('Invalid email or password', 'error'); if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; } return; }
                await deleteUserDataAndSignOut();
            } catch (err) { showToast('Delete failed. Try again.', 'error'); } finally {
                const deleteForm = document.getElementById('deleteAccountForm');
                const btn = deleteForm ? deleteForm.querySelector('button') : null;
                if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; }
            }
        }

        async function deleteUserDataAndSignOut() {
            try {
                showToast('Deleting your cloud data‚Ä¶', 'info', null, null, 5000);
                const uid = currentUser?.id;
                const tables = [
                    'products', 'categories', 'sales', 'expenses', 'customers', 'invoices', 'receipts', 'inventory', 'notes', 'transactions', 'unpaid_entries', 'transaction_floats', 'settings', 'inventory_purchase_periods', 'inventory_purchases', 'user_profiles'
                ];
                for (const t of tables) { try { await supabase.from(t).delete().eq('user_id', uid); } catch { } }
                try { await deleteAuthUserServerSide(uid); } catch { }
                state.products = [];
                state.sales = [];
                state.expenses = [];
                state.customers = [];
                state.invoices = [];
                state.receipts = [];
                state.categories = [];
                state.inventory = {};
                state.notes = [];
                state.transactions = [];
                state.unpaidEntries = [];
                state.userProfile = { businessName: '', email: '', phone: '', address: '' };
                localStorage.removeItem('financeManagerData');
                localStorage.removeItem('tuba-upsert-queue-v1');
                localStorage.removeItem('tuba-delete-queue-v1');
                saveData();
                await supabase.auth.signOut();
                currentUser = null;
                syncEnabled = false;
                try { if (navigator.credentials && navigator.credentials.preventSilentAccess) { await navigator.credentials.preventSilentAccess(); } } catch { }
                showToast('Your cloud data has been erased', 'success');
                render();
                window.updateAuthBanner && window.updateAuthBanner();
            } catch (e) { showToast('Delete failed. Please try again.', 'error'); }
        }

        async function deleteAuthUserServerSide(uid) {
            if (!uid) return false;
            try {
                if (supabase && supabase.functions && typeof supabase.functions.invoke === 'function') {
                    const { data, error } = await supabase.functions.invoke('delete-auth-user', { body: { uid } });
                    if (!error) { showToast('Auth user erased', 'success'); return true; }
                }
            } catch { }
            try {
                const ep = window.SUPABASE_DELETE_USER_URL || null;
                if (ep) {
                    let accessToken = null;
                    try { const s = await supabase.auth.getSession(); accessToken = s?.data?.session?.access_token || null; } catch { }
                    const res = await fetch(ep, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...(accessToken ? { 'Authorization': 'Bearer ' + accessToken } : {}) },
                        body: JSON.stringify({ uid })
                    });
                    if (res.ok) { showToast('Auth user erased', 'success'); return true; }
                }
            } catch { }
            showToast('Auth delete not configured. Set Edge Function delete-auth-user.', 'info');
            return false;
        }

        async function updateUserProfile(e) {
            e.preventDefault();

            const profileData = {
                businessName: document.getElementById('profileBusinessName').value.trim(),
                email: document.getElementById('profileEmail').value.trim(),
                phone: document.getElementById('profilePhone').value.trim(),
                address: document.getElementById('profileAddress').value.trim()
            };

            const success = await saveUserProfile(profileData);

            if (success) {
                state.profileEditMode = false; // Disable edit mode after saving
                saveData();
                showToast('Profile updated successfully!', 'success');
                render();
            }
        }

        function switchAuthTab(tab) {
            if (tab === 'login') {
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('signupForm').style.display = 'none';
                document.getElementById('loginTab').classList.add('active');
                document.getElementById('signupTab').classList.remove('active');
                try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                try {
                    if (typeof isIOSSafari === 'function' && isIOSSafari()) {
                        const emailEl = document.getElementById('loginEmail');
                        emailEl && emailEl.focus();
                    }
                } catch (e) { }
            } else {
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('signupForm').style.display = 'block';
                document.getElementById('loginTab').classList.remove('active');
                document.getElementById('signupTab').classList.add('active');
            }
        }

        // Detect autofill and auto submit sign in
        function autoSubmitLoginIfAutofilled() {
            const emailEl = document.getElementById('loginEmail');
            const passEl = document.getElementById('loginPassword');
            const btn = document.querySelector('#loginForm button[onclick="handleSignIn()"]');
            if (!emailEl || !passEl || !btn) return;

            // On iOS Safari, rely on autofill animation/visibility triggers and avoid polling
            try {
                if (typeof isIOSSafari === 'function' && isIOSSafari()) {
                    const email = (emailEl.value || '').trim();
                    const pwd = (passEl.value || '').trim();
                    if (email && pwd) {
                        try { handleSignIn(); } catch (e) { /* no-op */ }
                    }
                    return; // Skip polling on iOS Safari
                }
            } catch (e) { /* no-op */ }

            let attempts = 0;
            const maxAttempts = 10; // ~1 second
            const timer = setInterval(() => {
                attempts++;
                const email = (emailEl.value || '').trim();
                const pwd = (passEl.value || '').trim();
                if (email && pwd) {
                    clearInterval(timer);
                    try { handleSignIn(); } catch (e) { /* no-op */ }
                } else if (attempts >= maxAttempts) {
                    clearInterval(timer);
                }
            }, 200);
        }

        // iOS Face ID autofill detection via CSS animationstart (Safari only)
        function isIOSSafari() {
            const ua = navigator.userAgent || navigator.vendor || window.opera;
            const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
            return isIOS && isSafari;
        }
        if (isIOSSafari()) {
            document.addEventListener('animationstart', function (e) {
                if (e.animationName === 'autofillDetection') {
                    try { autoSubmitLoginIfAutofilled(); } catch (err) { }
                }
            }, true);
        }

        // Also trigger detection on visibility change and when inputs receive focus
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible' && !currentUser) {
                try { attemptSilentCredentialSignIn(); } catch (e) { }
                if (!currentUser && (typeof isIOSSafari === 'function' && isIOSSafari())) {
                    try { switchTab('account'); } catch (e) { }
                    try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                } else if (state.activeTab === 'account') {
                    try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                }
            }
        });
        async function attemptSilentCredentialSignIn() {
            if (!window.isSecureContext) return false;
            if (!navigator.credentials) return false;
            try {
                const cred = await navigator.credentials.get({ password: true, mediation: 'silent' });
                if (cred && cred.type === 'password' && cred.id && cred.password) {
                    try {
                        const { data, error } = await supabase.auth.signInWithPassword({ email: cred.id, password: cred.password });
                        if (!error && data && data.user) {
                            try { refreshAuthState(); } catch (e) { }
                            return true;
                        }
                    } catch (e) { }
                }
            } catch (e) { }
            return false;
        }
        async function pullFromCloud() {
            if (!syncEnabled || !currentUser) {
                return showToast('Not signed in', 'error');
            }

            if (!confirm('This will replace ALL local data with cloud data. Continue?')) {
                return;
            }

            updateSyncIndicator('syncing');
            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);

            try {
                console.log('‚¨áÔ∏è Pulling data from cloud...');

                // Clear local storage first
                localStorage.removeItem('financeManagerData');

                // Pull everything from cloud
                await pullDataFromSupabase();

                updateSyncIndicator('synced');
                showToast('Data pulled from cloud successfully!', 'success');
                render();
            } catch (error) {
                console.error('Pull error:', error);
                showToast('Pull failed: ' + error.message, 'error');
                updateSyncIndicator('synced');
            }
        }

        async function pushToCloud() {
            if (!syncEnabled || !currentUser) {
                return showToast('Not signed in', 'error');
            }

            if (!confirm('This will replace ALL cloud data with local data. Continue?')) {
                return;
            }

            updateSyncIndicator('syncing');
            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);

            try {
                console.log('‚¨ÜÔ∏è Pushing data to cloud...');
                await clearAndPushAllData();
                updateSyncIndicator('synced');
                showToast('Data pushed to cloud successfully!', 'success');
            } catch (error) {
                console.error('Push error:', error);
                showToast('Push failed: ' + error.message, 'error');
                updateSyncIndicator('synced');
            }
        }
        // Removed in-app forceRefresh function


        async function handleSignIn() {
            const email = document.getElementById('loginEmail')?.value;
            const password = document.getElementById('loginPassword')?.value;

            if (!email || !password) {
                return showToast('Please fill in all fields', 'error');
            }

            // Disable button during sign in
            const loginForm = document.getElementById('loginForm');
            if (loginForm) {
                const buttons = loginForm.querySelectorAll('button');
                buttons.forEach(btn => btn.disabled = true);
            }

            try {
                const result = await signIn(email, password);
                if (result) {
                    // Success - just render normally
                    render();
                } else {
                    // Failed - re-enable buttons
                    if (loginForm) {
                        const buttons = loginForm.querySelectorAll('button');
                        buttons.forEach(btn => btn.disabled = false);
                    }
                }
            } catch (error) {
                console.error('Handle sign in error:', error);
                if (loginForm) {
                    const buttons = loginForm.querySelectorAll('button');
                    buttons.forEach(btn => btn.disabled = false);
                }
            }
        }
        async function handleSignUp() {
            const email = document.getElementById('signupEmail')?.value;
            const password = document.getElementById('signupPassword')?.value;
            const confirm = document.getElementById('signupPasswordConfirm')?.value;

            if (!email || !password || !confirm) {
                return showToast('Please fill in all fields', 'error');
            }

            if (password !== confirm) {
                return showToast('Passwords do not match', 'error');
            }

            if (password.length < 6) {
                return showToast('Password must be at least 6 characters', 'error');
            }

            await signUp(email, password);
        }

        function renderSales() {
            const stats = getStats();

            // Filter sales based on search and filters
            let filteredSales = state.sales.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredSales = filteredSales.filter(s =>
                    s.productName.toLowerCase().includes(Period) ||
                    s.customer.toLowerCase().includes(Period) ||
                    s.payment.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredSales = filteredSales.filter(s => new Date(s.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredSales = filteredSales.filter(s => new Date(s.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCustomer) {
                filteredSales = filteredSales.filter(s => s.customer === state.filterCustomer);
            }

            return `
        <div class="privacy-container">
            <button class="privacy-toggle-btn show" id="privacyToggleBtn" onclick="togglePrivacy()">
                ${state.privacyBlurred ? 'üîí' : 'üîì'}
            </button>

        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL CAPITAL</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalCapital)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL PROFIT</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TODAY'S PROFIT</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.todayProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">10% TODAY</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.todayProfit * 0.1)} Tsh</div>
            </div>
        </div>
    </div>
</div>

        <div class="card">
            <h2>Add Sale</h2>
            <div class="card-header-buttons">
                <button class="quick-nav-btn products" onclick="switchTab('products')">Products/Services</button>
                <button class="quick-nav-btn categories" onclick="switchTab('categories')">Categories</button>
            </div>
            <form onsubmit="addSale(event)">
                <div class="form-group">
                    <label>Product/Service</label>
                    <select id="saleProduct" onchange="updateSaleTotal()" required>
                        <option value="">-- Select Product/Service --</option>
                        ${state.products
                    .map((p, i) => ({ p, i }))
                    .sort((a, b) => String(a.p.name).localeCompare(String(b.p.name)))
                    .map(({ p, i }) => { const stockText = (p.hasStock === false) ? 'N/A' : ((state.inventory[p.name] || { stock: 0 }).stock); const typeTag = p.hasStock === false ? '[Service]' : '[Product]'; return `<option value="${i}">${p.name} - ${p.category} ${typeTag}${p.hasStock === false ? '' : ` (Stock: ${stockText})`}</option>`; }).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Customer</label>
                    <select id="saleCustomer" onchange="toggleCustomerInput()">
                        <option value="">-- Walk-in --</option>
                        ${state.customers
                    .map((c, i) => ({ c, i }))
                    .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                    .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
                        <option value="new">+ Add New Customer</option>
                    </select>
                </div>
                <div id="newCustomerFields" style="display:none;">
                    <div class="form-group">
                        <label>New Customer Name</label>
                        <input type="text" id="newCustomerName" placeholder="Enter customer name">
                    </div>
                    <div class="form-group">
                        <label>Phone (Optional)</label>
                        <input type="tel" id="newCustomerPhone" placeholder="+255...">
                    </div>
                </div>
                <div class="form-group">
                    <label>Quantity</label>
                    <input type="number" id="saleQuantity" value="1" min="1" onchange="updateSaleTotal()" required>
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <select id="salePayment">
                        <option>Cash</option>
                        <option>Card</option>
                        <option>Mobile Money</option>
                        <option>M-Pesa Lipa Number</option>
                        <option>Bank Transfer</option>
                    </select>
                </div>
                <div id="saleInfo"></div>
                <button type="submit">Record Sale</button>
            </form>
        </div>

        <div class="card">
            <h2>Recent Sales (${filteredSales.length})</h2>
            
            <div class="search-box">
                <input type="text" placeholder="üîç Search sales..." oninput="updateSearchPeriod(this.value)">
            </div>

            <div class="filter-row">
                <div class="form-group">
                    <label>From...</label>
                    <input type="date" onchange="updateFilterDateFrom(this.value)" value="${state.filterDateFrom || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>To...</label>
                    <input type="date" onchange="updateFilterDateTo(this.value)" value="${state.filterDateTo || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>Customer</label>
                    <select onchange="updateFilterCustomer(this.value)">
                        <option value="">All Customers</option>
                        ${[...new Set(state.sales.map(s => s.customer))]
                    .filter(c => !!c)
                    .sort((a, b) => String(a).localeCompare(String(b)))
                    .map(c =>
                        `<option value="${c}" ${state.filterCustomer === c ? 'selected' : ''}>${c}</option>`
                    ).join('')}
                    </select>
                </div>
                <button class="btn-small btn-secondary" onclick="clearFilters()">Clear</button>
            </div>

            ${(state.listExpanded.sales || state.searchPeriod || state.filterDateFrom || state.filterDateTo || state.filterCustomer) ? `
                <div class="bulk-actions">
                    <input type="checkbox" id="selectAll_sales" onchange="toggleSelectAll('sales')" class="checkbox-select">
                    <label for="selectAll_sales">Select All</label>
                    <span style="color: #666; font-size: 12px; margin-left: 8px;">
                        ${getSelectedCount('sales')} selected
                    </span>
                    <button class="btn-small btn-danger" onclick="bulkDelete('sales')" ${!hasSelected('sales') ? 'disabled' : ''}>
                        üóëÔ∏è Delete Selected
                    </button>
                </div>

                ${filteredSales.slice().reverse().map((s, idx) => {
                        const isService = (state.products.find(p => p.name === s.productName)?.hasStock === false);
                        const typeBadge = isService ? '<span class="badge badge-warning">Service</span>' : '<span class="badge badge-success">Product</span>';
                        return `
                    <div class="item">
                        <div style="display: flex; gap: 12px; align-items: start;">
                            <input type="checkbox" class="checkbox-select" 
                                   ${state.selectedItems.sales && state.selectedItems.sales[s.id] ? 'checked' : ''}
                                   onchange="toggleSelect('sales', '${s.id}')">
                            <div style="flex: 1;">
                                <div class="item-header">
                                    <span class="item-title">${s.productName} ${typeBadge}</span>
                                    <span style="color: #2e7d32; font-weight: 700;">üí∞ ${formatNumber(s.profit)} Tsh</span>
                                </div>
                                <div class="item-subtitle">
                                    ${s.date} ${s.time}<br>
                                    ${s.customer} | Qty: ${s.quantity} | ${s.payment}<br>
                                    Cost: ${formatNumber(s.totalCost)} | Price: ${formatNumber(s.totalPrice)}
                                </div>
                                <div class="flex-gap" style="margin-top:8px;">
                                    <button class="btn-small" style="background: linear-gradient(145deg, #ffeb3b, #fbc02d); color: #333;" onclick="downloadSaleReceiptPDF(${s.timestamp})">üìÑ Receipt</button>
                                    <button class="btn-small" onclick="editSaleByTimestamp(${s.timestamp})">Edit</button>
                                    <button class="btn-small btn-danger" onclick="deleteSaleByTimestamp(${s.timestamp})">Delete</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `}).join('') || '<p style="text-align: center; color: #666;">No sales found</p>'}
            ` : ''}

            <button class="collapse-btn" onclick="toggleListExpanded('sales')">
                <span class="collapse-icon ${state.listExpanded.sales ? 'expanded' : ''}">‚ñº</span>
                <span>${state.listExpanded.sales ? 'Hide' : 'Show'} All Sales</span>
            </button>
        </div>
    `;
        }


        function updateSearchPeriod(value) {
            state.searchPeriod = value;
            // Don't re-render, just update the list
            renderSalesList();
        }

        function renderSalesList() {
            const container = document.getElementById('salesList');
            if (!container) return;

            let filteredSales = state.sales.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredSales = filteredSales.filter(s =>
                    s.productName.toLowerCase().includes(Period) ||
                    s.customer.toLowerCase().includes(Period) ||
                    s.payment.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredSales = filteredSales.filter(s => new Date(s.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredSales = filteredSales.filter(s => new Date(s.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCustomer) {
                filteredSales = filteredSales.filter(s => s.customer === state.filterCustomer);
            }

            container.innerHTML = filteredSales.slice().reverse().slice(0, 50).map(s => {
                const isService = (state.products.find(p => p.name === s.productName)?.hasStock === false);
                const typeBadge = isService ? '<span class="badge badge-warning">Service</span>' : '<span class="badge badge-success">Product</span>';
                return `
        <div class="item">
            <div class="item-header">
                <span class="item-title">${s.productName} ${typeBadge}</span>
                <span style="color: #2e7d32; font-weight: 700;">üí± ${formatNumber(s.profit)} Tsh</span>
            </div>
            <div class="item-subtitle">
                ${s.date} ${s.time}<br>
                ${s.customer} | Qty: ${s.quantity} | ${s.payment}<br>
                Cost: ${formatNumber(s.totalCost)} | Price: ${formatNumber(s.totalPrice)}
            </div>
            <div class="flex-gap" style="margin-top:8px;">
                <button class="btn-small" onclick="editSaleByTimestamp(${s.timestamp})">Edit</button>
                <button class="btn-small btn-danger" onclick="deleteSaleByTimestamp(${s.timestamp})">Delete</button>
            </div>
        </div>
    `}).join('') || '<p style="text-align: center; color: #666;">No sales found</p>';
        }

        function updateFilterDateFrom(value) {
            state.filterDateFrom = value;
            render();
        }

        function updateFilterDateTo(value) {
            state.filterDateTo = value;
            render();
        }

        function updateFilterCustomer(value) {
            state.filterCustomer = value;
            render();
        }

        function clearFilters() {
            state.searchPeriod = '';
            state.filterDateFrom = '';
            state.filterDateTo = '';
            state.filterCategory = '';
            state.filterCustomer = '';
            render();
        }

        function renderCollapsibleList(items, chunkSize, sectionKey, renderItem, emptyMessage) {
            if (!items || items.length === 0) {
                return `<p style="text-align: center; color: #666;">${emptyMessage}</p>`;
            }

            let html = '';
            for (let i = 0; i < items.length; i += chunkSize) {
                const chunk = items.slice(i, i + chunkSize);
                const chunkId = `${sectionKey}_chunk_${i}`;
                const isCollapsed = state.collapsedSections[chunkId];

                html += chunk.map((item, idx) => renderItem(item, i + idx)).join('');

                if (i + chunkSize < items.length) {
                    html += `
                        <button class="collapse-btn" onclick="toggleCollapse('${chunkId}')">
                            <span class="collapse-icon ${isCollapsed ? '' : 'expanded'}">‚ñº</span>
                            <span>${isCollapsed ? 'Show More' : 'Show Less'}</span>
                        </button>
                    `;

                    if (isCollapsed) {
                        break;
                    }
                }
            }
            return html;
        }

        function toggleCollapse(chunkId) {
            state.collapsedSections[chunkId] = !state.collapsedSections[chunkId];
            render();
        }

        function toggleListExpanded(key) {
            if (!state.listExpanded) state.listExpanded = {};
            state.listExpanded[key] = !state.listExpanded[key];
            render();
        }

        function toggleSelectAll(type) {
            if (!state.selectedItems[type]) state.selectedItems[type] = {};

            const items = type === 'unpaidEntries' ? state.unpaidEntries : state[type];

            // Ensure all items have IDs
            items.forEach(item => {
                if (!item.id) {
                    item.id = generateID(type);
                }
            });

            // Check if ALL items are currently selected
            const allSelected = items.every(item => state.selectedItems[type][item.id]);

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            // Apply the new state to all items
            items.forEach(item => {
                state.selectedItems[type][item.id] = newState;
            });

            saveData();
            render(); // Re-render to update UI
        }

        function updateSelectAllCheckbox(type) {
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                const items = type === 'unpaidEntries' ? state.unpaidEntries : state[type];
                const checkbox = document.getElementById(`selectAll_${type}`);

                if (!checkbox || !items || items.length === 0) return;

                // Ensure all items have IDs
                items.forEach(item => {
                    if (!item.id) {
                        item.id = generateID(type);
                    }
                });

                // Check if all items are selected
                const allSelected = items.every(item => state.selectedItems[type] && state.selectedItems[type][item.id]);

                // Update the "Select All" checkbox state
                checkbox.checked = allSelected;
            }, 0);
        }

        function toggleSelect(type, id) {
            if (!state.selectedItems[type]) state.selectedItems[type] = {};
            state.selectedItems[type][id] = !state.selectedItems[type][id];
            saveData();

            // Update the "Select All" checkbox state
            updateSelectAllCheckbox(type);

            // Update count display
            render();
        }

        function hasSelected(type) {
            return state.selectedItems[type] && Object.values(state.selectedItems[type]).some(v => v);
        }

        function getSelectedCount(type) {
            if (!state.selectedItems[type]) return 0;
            return Object.values(state.selectedItems[type]).filter(v => v).length;
        }

        function bulkDelete(type) {
            const selected = Object.keys(state.selectedItems[type] || {}).filter(id => state.selectedItems[type][id]);

            if (selected.length === 0) return showToast('No items selected', 'info');

            showConfirm(`Delete ${selected.length} selected items?`, async function () {
                const items = type === 'unpaidEntries' ? state.unpaidEntries : state[type];
                // Issue cloud deletes for each selected item
                if (syncEnabled) {
                    try {
                        selected.forEach(selId => {
                            const it = items.find(x => x.id === selId);
                            if (!it) return;
                            switch (type) {
                                case 'sales':
                                    deleteOne('sales', { timestamp: it.timestamp });
                                    break;
                                case 'expenses':
                                    deleteOne('expenses', { timestamp: it.timestamp });
                                    break;
                                case 'customers':
                                    deleteOne('customers', { name: it.name, email: it.email || '' });
                                    break;
                                case 'products':
                                    deleteOne('products', { name: it.name, category: it.category || '' });
                                    break;
                                case 'transactions':
                                    deleteOne('transactions', { timestamp: it.timestamp });
                                    break;
                                case 'unpaidEntries':
                                    deleteOne('unpaid_entries', { timestamp: it.timestamp });
                                    break;
                                case 'notes':
                                    deleteOne('notes', { timestamp: it.timestamp });
                                    break;
                                default:
                                    break;
                            }
                        });
                    } catch { }
                }
                const filtered = items.filter(item => !selected.includes(item.id));

                if (type === 'unpaidEntries') {
                    state.unpaidEntries = filtered;
                } else {
                    state[type] = filtered;
                }

                // Reset selection state
                state.selectedItems[type] = {};
                saveData();
                render();

                // Uncheck select all checkbox after deletion
                setTimeout(() => {
                    const checkbox = document.getElementById(`selectAll_${type}`);
                    if (checkbox) checkbox.checked = false;
                }, 100);

                showToast(`${selected.length} items deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function bulkMarkPaid() {
            const selected = Object.keys(state.selectedItems.unpaidEntries || {})
                .filter(id => state.selectedItems.unpaidEntries[id]);

            if (selected.length === 0) return showToast('No items selected', 'info');

            showConfirm(`Mark ${selected.length} entries as paid?`, function () {
                selected.forEach(id => {
                    const entry = state.unpaidEntries.find(e => e.id === id);
                    if (entry) {
                        entry.paid = true;
                        const now = new Date();
                        state.sales.push({
                            id: generateID('sales'),
                            date: getTodayDateString(),
                            time: now.toLocaleTimeString(),
                            timestamp: now.getTime(),
                            productName: entry.type,
                            customer: entry.name,
                            quantity: 1,
                            costPerUnit: 0,
                            pricePerUnit: entry.amount,
                            totalCost: 0,
                            totalPrice: entry.amount,
                            profit: entry.amount,
                            payment: 'Unpaid Entry - Now Paid'
                        });
                    }
                });

                state.selectedItems.unpaidEntries = {};
                saveData();
                render();

                // Uncheck select all checkbox
                setTimeout(() => {
                    const checkbox = document.getElementById('selectAll_unpaidEntries');
                    if (checkbox) checkbox.checked = false;
                }, 100);

                showToast(`${selected.length} entries marked as paid`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function editSaleByTimestamp(ts) {
            const idx = state.sales.findIndex(s => s.timestamp === ts);
            if (idx === -1) return showToast("Sale not found", "error");
            const s = state.sales[idx];
            const qty = prompt("Quantity:", s.quantity);
            const price = prompt("Price per unit:", s.pricePerUnit);
            if (qty && price && !isNaN(qty) && !isNaN(price)) {
                const qtyNum = parseInt(qty);
                const priceNum = parseFloat(price);
                s.quantity = qtyNum;
                s.pricePerUnit = priceNum;
                s.totalPrice = +(priceNum * qtyNum).toFixed(2);
                s.totalCost = s.costPerUnit * qtyNum;
                s.profit = +(s.totalPrice - s.totalCost).toFixed(2);
                s.timestamp = Date.now();
                saveData();
                render();
                showToast("Sale updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteSaleByTimestamp(ts) {
            showConfirm("Delete this sale?", async function () {
                const idx = state.sales.findIndex(s => s.timestamp === ts);
                if (idx === -1) return showToast("Sale not found", "error");
                const sale = state.sales[idx];

                // Return stock to inventory only if product tracks stock
                const productForSale = state.products.find(p => p.name === sale.productName);
                if (productForSale && productForSale.hasStock !== false && state.inventory[sale.productName]) {
                    state.inventory[sale.productName].stock += sale.quantity;
                }

                if (sale) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('sales', { timestamp: sale.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('sales', { timestamp: sale.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.sales.splice(idx, 1);
                saveData();
                render();
                showToast("Sale deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function toggleCustomerInput() {
            const select = document.getElementById('saleCustomer');
            const fields = document.getElementById('newCustomerFields');
            if (select && fields) {
                if (select.value === 'new') {
                    fields.style.display = 'block';
                } else {
                    fields.style.display = 'none';
                }
            }
        }

        function updateSaleTotal() {
            const productIndex = document.getElementById('saleProduct')?.value;
            const quantity = parseInt(document.getElementById('saleQuantity')?.value) || 1;
            const infoDiv = document.getElementById('saleInfo');
            if (!infoDiv) return;
            if (!productIndex && productIndex !== '0') { infoDiv.innerHTML = ''; return; }
            const product = state.products[productIndex];
            if (!product) { infoDiv.innerHTML = ''; return; }

            const isService = product.hasStock === false;
            let availableStock = null;
            if (!isService) {
                const inventoryItem = state.inventory[product.name] || { stock: 0, minAlert: 5 };
                availableStock = inventoryItem.stock;
                if (quantity > availableStock) {
                    infoDiv.innerHTML = `
                        <div class="alert-box-danger">
                            <strong>‚ö†Ô∏è Insufficient Stock!</strong><br>
                            Available: ${availableStock} units<br>
                            Requested: ${quantity} units
                        </div>
                    `;
                    return;
                }
            }

            const totalCost = product.cost * quantity;
            const totalPrice = product.price * quantity;
            infoDiv.innerHTML = `
                <div class="info-box">
                    <div class="info-row"><span>Cost/unit:</span><span>üí± ${formatNumber(product.cost)} Tsh</span></div>
                    <div class="info-row"><span>Price/unit:</span>
                        <input type="number" id="manualPrice" value="${product.price.toFixed(2)}" step="0.01" style="width:120px;text-align:right;padding:6px;border-radius:6px;border:1px solid #ddd;">
                    </div>
                    ${isService ? `<div class=\"info-row\"><span>Item Type:</span><span>Service (no stock)</span></div>` : `<div class=\"info-row\"><span>Available Stock:</span><span>${availableStock} units</span></div>`}
                    <div class="info-row" style="font-weight:700;"><span>Total Cost:</span><span id="totalCost">üí± ${formatNumber(totalCost)} Tsh</span></div>
                    <div class="info-row" style="font-weight:700;"><span>Total Price:</span><span id="totalPrice">üí± ${formatNumber(product.price * quantity)} Tsh</span></div>
                    <div class="info-row" style="font-weight:700; color: #2e7d32;"><span>Profit:</span><span id="totalProfit">üí± ${formatNumber((product.price - product.cost) * quantity)} Tsh</span></div>
                </div>
            `;
            const manual = document.getElementById('manualPrice');
            manual && manual.addEventListener('input', function () {
                const p = parseFloat(this.value) || 0;
                document.getElementById('totalPrice').textContent = `üí± ${formatNumber(p * quantity)} Tsh`;
                document.getElementById('totalProfit').textContent = `üí± ${formatNumber((p - product.cost) * quantity)} Tsh`;
            });
        }

        async function addSale(e) {
            e && e.preventDefault && e.preventDefault();
            const productIndex = document.getElementById('saleProduct')?.value;
            if (productIndex === null || productIndex === '' || productIndex === undefined) return showToast('Please select a product', 'error');
            const product = state.products[productIndex];
            if (!product) return showToast('Product not found', 'error');
            const isService = product.hasStock === false;

            const customerSelect = document.getElementById('saleCustomer')?.value;
            let customer;

            if (customerSelect === 'new') {
                const newName = document.getElementById('newCustomerName')?.value.trim();
                if (!newName) return showToast('Please enter customer name', 'error');
                const newPhone = document.getElementById('newCustomerPhone')?.value.trim();
                customer = { name: newName, email: '', phone: newPhone, address: '', totalPurchases: 0 };
                state.customers.push(customer);
            } else if (customerSelect) {
                customer = state.customers[customerSelect];
            } else {
                customer = { name: 'WALK IN' };
            }

            const quantity = parseInt(document.getElementById('saleQuantity')?.value) || 1;
            const payment = document.getElementById('salePayment')?.value || 'Cash';
            const manualPriceInput = document.getElementById('manualPrice');
            const pricePerUnit = manualPriceInput ? parseFloat(manualPriceInput.value) : product.price;

            // Check stock only for stock-tracked products
            if (!isService) {
                const inventoryItem = state.inventory[product.name] || { stock: 0, minAlert: 5 };
                if (quantity > inventoryItem.stock) {
                    return showToast(`Insufficient stock! Available: ${inventoryItem.stock}`, 'error');
                }
            }

            const now = new Date();
            const totalCost = product.cost * quantity;
            const totalPrice = +(pricePerUnit * quantity).toFixed(2);
            const sale = {
                id: generateID('sales'),
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                productName: product.name,
                customer: customer ? customer.name : 'WALK IN',
                quantity,
                costPerUnit: product.cost,
                pricePerUnit,
                totalCost,
                totalPrice,
                profit: +(totalPrice - totalCost).toFixed(2),
                payment
            };
            state.sales = state.sales || [];
            state.sales.push(sale);

            // Update customer total purchases
            if (customer && customer.name !== 'WALK IN') {
                const custIndex = state.customers.findIndex(c => c.name === customer.name);
                if (custIndex !== -1) {
                    state.customers[custIndex].totalPurchases = (state.customers[custIndex].totalPurchases || 0) + totalPrice;
                }
            }

            // Update inventory only if product tracks stock
            if (!isService && state.inventory && state.inventory[product.name]) {
                state.inventory[product.name].stock = Math.max(0, (state.inventory[product.name].stock || 0) - quantity);
            }

            saveData();
            render();
            showToast("Sale recorded successfully!", "success");

            // Friendly reminder to save a local backup (max 3 per day)
            maybeShowBackupReminder();

            if (syncEnabled) {
                await upsertOne('sales', {
                    date: sale.date,
                    time: sale.time,
                    timestamp: sale.timestamp,
                    product_name: sale.productName,
                    customer: sale.customer,
                    quantity: sale.quantity,
                    cost_per_unit: sale.costPerUnit,
                    price_per_unit: sale.pricePerUnit,
                    total_cost: sale.totalCost,
                    total_price: sale.totalPrice,
                    profit: sale.profit,
                    payment: sale.payment
                });
                if (customer && customer.name !== 'WALK IN') {
                    const cust = state.customers.find(c => c.name === customer.name) || customer;
                    await upsertOne('customers', {
                        name: cust.name,
                        email: cust.email || '',
                        phone: cust.phone || '',
                        address: cust.address || '',
                        total_purchases: cust.totalPurchases || 0
                    });
                }
                if (product && product.hasStock !== false) {
                    const inv = state.inventory[product.name] || { stock: 0, minAlert: 5 };
                    await upsertOne('inventory', { product_name: product.name, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                }
                syncInBackground();
            }
        }

        function renderTransactions() {
            const channels = [
                { id: 'mpesa', label: 'M-Pesa' },
                { id: 'crdb', label: 'CRDB' },
                { id: 'nmb', label: 'NMB' },
                { id: 'airtel', label: 'Airtel Money' },
                { id: 'halopesa', label: 'Halopesa' },
                { id: 'yas', label: 'Yas Tanzania' }
            ];
            const currentChannel = state.activeTransactionChannel || 'mpesa';
            const channelTransactions = (state.transactions || []).filter(t => t.channel === currentChannel);

            const floatData = state.transactionFloats[currentChannel];
            const floatDifference = floatData.current - floatData.initial;

            return `
                <div class="transaction-tabs">
                    ${channels.map(ch => `
                        <button class="transaction-tab ${ch.id} ${currentChannel === ch.id ? 'active' : ''}" 
                             onclick="switchTransactionChannel('${ch.id}')">
                            ${ch.label}
                        </button>
                    `).join('')}
                </div>

                <div class="float-balance-container">
                    <h3 style="margin-bottom: 12px; color: #0d47a1; font-size: 16px;">üí∞ Float Balance</h3>
                    <div class="float-balance-row">
                        <span class="float-balance-label">Initial Float:</span>
                        <span class="editable-float" onclick="editInitialFloat('${currentChannel}')">
                            üí± ${formatNumber(floatData.initial)} Tsh
                        </span>
                    </div>
                    <div class="float-balance-row">
                        <span class="float-balance-label">Current Float Balance:</span>
                        <span class="float-balance-value ${floatDifference >= 0 ? 'positive' : 'negative'}">
                            üí± ${formatNumber(floatData.current)} Tsh
                        </span>
                    </div>
                    <div class="float-balance-row">
                        <span class="float-balance-label"> Cash Balance:</span>
                        <span class="float-balance-value ${floatDifference >= 0 ? 'positive' : 'negative'}">
                            ${floatDifference >= 0 ? '+' : ''}${formatNumber(floatDifference)} Tsh
                        </span>
                    </div>
                </div>

                </div>

        <div class="card">
            <h2>${channels.find(c => c.id === currentChannel).label} Transactions (${channelTransactions.length})</h2>
            
            <div class="search-box">
                <input type="text" placeholder="üîç Search transactions..." 
                       oninput="searchTransactions(this.value)" 
                       id="transactionSearch">
            </div>
                <div class="card">
                    <h2>Add ${channels.find(c => c.id === currentChannel).label} Transaction</h2>
                    <form onsubmit="addTransaction(event)">
                        <div class="form-group">
                            <label>Customer Name (Optional)</label>
                            <input type="text" id="transactionCustomer" placeholder="Enter customer name">
                        </div>
                        <div class="form-group">
                            <label>Transaction Type</label>
                            <select id="transactionType" required>
                                <option value="deposit">Deposit (+)</option>
                                <option value="withdrawal">Withdrawal (-)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="text" id="transactionAmount" class="money-input" placeholder="0" required>
                        </div>
                        <button type="submit">Save Transaction</button>
                    </form>
                </div>

                <div class="card">
                    <h2>${channels.find(c => c.id === currentChannel).label} Transactions (${channelTransactions.length})</h2>
                    
                    ${state.listExpanded.transactions ? `
    <div class="bulk-actions">
        <input type="checkbox" id="selectAll_transactions" onchange="toggleSelectAll('transactions')" class="checkbox-select">
        <label for="selectAll_transactions">Select All</label>
        <span style="color: #666; font-size: 12px; margin-left: 8px;">
            ${getSelectedCount('transactions')} selected
        </span>
        <button class="btn-small btn-danger" onclick="bulkDelete('transactions')" ${!hasSelected('transactions') ? 'disabled' : ''}>
            üóëÔ∏è Delete Selected
        </button>
    </div>

    <div id="transactionsList">
        ${renderTransactionsList(channelTransactions)}
    </div>
` : ''}

                    <button class="collapse-btn" onclick="toggleListExpanded('transactions')">
                        <span class="collapse-icon ${state.listExpanded.transactions ? 'expanded' : ''}">‚ñº</span>
                        <span>${state.listExpanded.transactions ? 'Hide' : 'Show'} All Transactions</span>
                    </button>
                </div>
            `;
        }

        function renderTransactionsList(transactions, searchPeriod = '') {
            let filtered = transactions;

            if (searchPeriod) {
                const Period = searchPeriod.toLowerCase();
                filtered = transactions.filter(t =>
                    (t.customerName && t.customerName.toLowerCase().includes(Period)) ||
                    t.type.toLowerCase().includes(Period) ||
                    t.channel.toLowerCase().includes(Period)
                );
            }

            if (filtered.length === 0) {
                return '<p style="text-align: center; color: #666;">No transactions found</p>';
            }

            return filtered.slice().reverse().map((t, idx) => `
        <div class="item">
            <div style="display: flex; gap: 12px; align-items: start;">
                <input type="checkbox" class="checkbox-select" 
                       ${state.selectedItems.transactions && state.selectedItems.transactions[t.id] ? 'checked' : ''}
                       onchange="toggleSelect('transactions', '${t.id}')">
                <div style="flex: 1;">
                    <div class="item-header">
                        <span class="item-title">${t.customerName || 'N/A'}</span>
                        <span class="badge badge-${t.channel}">${t.type.toUpperCase()}</span>
                    </div>
                    <div class="item-subtitle">
                        ${t.date} ${t.time}<br>
                        Amount: <strong style="color: ${t.type === 'deposit' ? '#2e7d32' : '#d32f2f'};">
                            ${t.type === 'deposit' ? '+' : '-'}üí∞ ${formatNumber(t.amount)} Tsh
                        </strong>
                    </div>
                    <div class="flex-gap" style="margin-top:8px;">
                        <button class="btn-small" onclick="editTransactionByTimestamp(${t.timestamp})">Edit</button>
                        <button class="btn-small btn-danger" onclick="deleteTransactionByTimestamp(${t.timestamp})">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    `).join('');
        }

        function searchTransactions(Period) {
            const currentChannel = state.activeTransactionChannel || 'mpesa';
            const channelTransactions = (state.transactions || []).filter(t => t.channel === currentChannel);

            document.getElementById('transactionsList').innerHTML = renderTransactionsList(channelTransactions, Period);
        }

        async function editInitialFloat(channel) {
            const current = state.transactionFloats[channel].initial;
            const newValue = prompt(`Set initial float for ${channel.toUpperCase()}:`, current);
            if (newValue !== null) {
                const val = parseFloat(newValue);
                if (!isNaN(val) && val >= 0) {
                    state.transactionFloats[channel].initial = val;
                    calculateFloatBalances();
                    saveData();
                    render();
                    showToast('Float updated', 'success');

                    // Sync to cloud immediately and then background merge
                    if (syncEnabled) {
                        await upsertOne('transaction_floats', { channel, initial_float: val });
                        syncInBackground();
                    }
                } else {
                    showToast('Invalid amount', 'error');
                }
            }
        }
        function switchTransactionChannel(channel) {
            state.activeTransactionChannel = channel;
            render();
        }

        async function addTransaction(e) {
            e.preventDefault();
            const now = new Date();
            const amount = parseMoney(document.getElementById('transactionAmount').value);

            if (isNaN(amount) || amount <= 0) {
                return showToast('Please enter a valid amount', 'error');
            }

            const transaction = {
                id: generateID('transactions'),
                channel: state.activeTransactionChannel,
                customerName: document.getElementById('transactionCustomer').value.trim() || 'N/A',
                type: document.getElementById('transactionType').value,
                amount: amount,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime()
            };

            state.transactions = state.transactions || [];
            state.transactions.push(transaction);

            calculateFloatBalances();
            saveData();
            render();
            showToast("Transaction recorded", "success");

            if (syncEnabled) {
                await upsertOne('transactions', {
                    channel: transaction.channel,
                    customer_name: transaction.customerName,
                    type: transaction.type,
                    amount: transaction.amount,
                    date: transaction.date,
                    time: transaction.time,
                    timestamp: transaction.timestamp
                });
                syncInBackground();
            }
        }

        async function editTransactionByTimestamp(ts) {
            const idx = state.transactions.findIndex(t => t.timestamp === ts);
            if (idx === -1) return showToast("Transaction not found", "error");
            const t = state.transactions[idx];
            const customer = prompt("Customer Name:", t.customerName);
            const type = confirm("Is this a DEPOSIT? (Cancel for Withdrawal)") ? 'deposit' : 'withdrawal';
            const amount = prompt("Amount:", t.amount);
            if (customer !== null && amount) {
                const amountNum = parseFloat(amount);
                if (!isNaN(amountNum) && amountNum > 0) {
                    t.customerName = customer.trim() || 'N/A';
                    t.type = type;
                    t.amount = amountNum;
                    t.timestamp = Date.now();
                    calculateFloatBalances();
                    saveData();
                    render();
                    showToast("Transaction updated", "success");

                    if (syncEnabled) {
                        await upsertOne('transactions', {
                            channel: t.channel,
                            customer_name: t.customerName,
                            type: t.type,
                            amount: t.amount,
                            date: t.date,
                            time: t.time,
                            timestamp: t.timestamp
                        });
                        syncInBackground();
                    }
                } else {
                    showToast("Invalid amount", "error");
                }
            }
        }

        function deleteTransactionByTimestamp(ts) {
            showConfirm("Delete this transaction?", async function () {
                const idx = state.transactions.findIndex(t => t.timestamp === ts);
                if (idx === -1) return showToast("Transaction not found", "error");
                const t = state.transactions[idx];
                if (t) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('transactions', { timestamp: t.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('transactions', { timestamp: t.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.transactions.splice(idx, 1);
                calculateFloatBalances();
                saveData();
                render();
                showToast("Transaction deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderProducts() {
            return `
                <div class="card">
                    <h2>Add Product/Service</h2>
                    <div class="card-header-buttons">
                        <button class="quick-nav-btn back" onclick="switchTab('sales')">‚Üê Sales</button>
                    </div>
                    <form onsubmit="addProduct(event)">
                        <div class="form-group">
                            <label>Item Name</label>
                            <input type="text" id="productName" placeholder="Enter item name" required>
                        </div>
                        <div class="form-group">
                            <label>Category</label>
                            <select id="productCategory" required>
                                <option value="">-- Select Category --</option>
                                ${state.categories.slice().sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}">${c}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Cost (Capital)</label>
                            <input type="number" id="productCost" placeholder="0.00" step="0.01" required>
                        </div>
                        <div class="form-group">
                            <label>Price (Selling)</label>
                            <input type="number" id="productPrice" placeholder="0.00" step="0.01" required>
                        </div>
                        <div class="form-group">
                            <label>Item Type</label>
                            <select id="productHasStock" onchange="toggleInitialStock()">
                                <option value="yes" selected>Product (has stock)</option>
                                <option value="no">Service (no stock)</option>
                            </select>
                        </div>
                        <div class="form-group" id="initialStockGroup">
                            <label>Initial Stock</label>
                            <input type="number" id="productStock" placeholder="0" min="0" value="0">
                        </div>
                        <button type="submit">Add Product</button>
                    </form>
                </div>

                <div class="card">
                    <h2>All Items (${state.products.length})</h2>
    <div class="search-box">
        <input type="text" placeholder="üîç Search items..." oninput="searchProducts(this.value)" id="productSearch">
    </div>
    
    ${state.products.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_products" onchange="toggleSelectAll('products')" class="checkbox-select">
            <label for="selectAll_products">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCount('products')} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDelete('products')" ${!hasSelected('products') ? 'disabled' : ''}>
                üóëÔ∏è Delete Selected
            </button>
        </div>
    ` : ''}
    
    <div id="productsList">
        ${renderProductsList()}
    </div>
</div>
            `;
        }

        // Toggle visibility of initial stock based on has-stock selection
        function toggleInitialStock() {
            const select = document.getElementById('productHasStock');
            const group = document.getElementById('initialStockGroup');
            if (!select || !group) return;
            if (select.value === 'no') {
                group.style.display = 'none';
            } else {
                group.style.display = 'block';
            }
        }

        function renderProductsList(searchPeriod = '') {
            let products = state.products;
            if (searchPeriod) {
                const Period = searchPeriod.toLowerCase();
                products = products.filter(p =>
                    p.name.toLowerCase().includes(Period) ||
                    p.category.toLowerCase().includes(Period)
                );
            }

            if (products.length === 0) {
                return '<p style="text-align: center; color: #666;">No items found</p>';
            }

            return products.map((p, i) => {
                const actualIndex = state.products.indexOf(p);
                const inv = state.inventory[p.name] || { stock: 0 };
                const margin = ((p.price - p.cost) / p.cost * 100).toFixed(1);
                return `
        <div class="item">
            <div style="display: flex; gap: 12px; align-items: start;">
                <input type="checkbox" class="checkbox-select" 
                       ${state.selectedItems.products && state.selectedItems.products[p.id] ? 'checked' : ''}
                       onchange="toggleSelect('products', '${p.id}')">
                <div style="flex: 1;">
                        <div class="item-title">${p.name}</div>
                        <div class="item-subtitle">
                            Category: ${p.category} | ${p.hasStock === false ? 'Service (no stock)' : 'Stock: ' + inv.stock + ' units'}<br>
                            Margin: ${margin}%
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 14px;">
                            <span>Cost: üí± ${formatNumber(p.cost)} Tsh</span>
                            <span>Price: üí± ${formatNumber(p.price)} Tsh</span>
                            <span style="color: #2e7d32; font-weight: 600;">+${formatNumber(p.price - p.cost)} Tsh</span>
                        </div>
                        <div class="flex-gap" style="margin-top:8px;">
                        <button class="btn-small" onclick="editProductIndex(${actualIndex})">Edit</button>
                        <button class="btn-small btn-danger" onclick="deleteProductIndex(${actualIndex})">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    `;
            }).join('');
        }

        function searchProducts(Period) {
            document.getElementById('productsList').innerHTML = renderProductsList(Period);
        }

        async function addProduct(e) {
            e.preventDefault();
            const name = document.getElementById('productName').value.trim();
            let category = document.getElementById('productCategory').value;
            if (typeof category === 'string') category = category.trim();
            const cost = parseFloat(document.getElementById('productCost').value);
            const price = parseFloat(document.getElementById('productPrice').value);
            const stock = parseInt(document.getElementById('productStock').value) || 0;
            const hasStock = (document.getElementById('productHasStock')?.value !== 'no');

            if (cost < 0 || price < 0) {
                return showToast('Cost and price must be positive', 'error');
            }

            if (price < cost) {
                if (!confirm('Warning: Selling price is less than cost. Continue?')) {
                    return;
                }
            }

            if (state.products.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                return showToast('Product already exists', 'error');
            }

            const product = {
                id: generateID('products'),
                name,
                category,
                cost,
                price,
                hasStock
            };
            state.products.push(product);

            // Initialize inventory for new product
            if (!state.inventory) {
                state.inventory = {};
            }

            // Only set initial stock for stock-tracked products
            if (hasStock) {
                state.inventory[name] = {
                    stock: parseInt(stock) || 0,
                    minAlert: 5
                };
            }

            saveData();
            render();
            showToast("Product added successfully!", "success");

            if (syncEnabled) {
                await upsertOne('unpaid_entries', {
                    name: entry.name,
                    type: entry.type,
                    amount: entry.amount,
                    date: entry.date,
                    time: entry.time,
                    timestamp: entry.timestamp,
                    paid: entry.paid
                });
                syncInBackground();
            }
        }

        function editProductIndex(i) {
            const p = state.products[i];
            if (!p) return showToast("Product not found", "error");
            const name = prompt("Product name:", p.name);
            const cost = prompt("Cost:", p.cost);
            const price = prompt("Price:", p.price);
            if (name && cost && price && !isNaN(cost) && !isNaN(price)) {
                const costNum = parseFloat(cost);
                const priceNum = parseFloat(price);

                if (costNum < 0 || priceNum < 0) {
                    return showToast('Cost and price must be positive', 'error');
                }

                const oldName = p.name;
                p.name = name.trim();
                p.cost = costNum;
                p.price = priceNum;

                if (state.inventory && oldName !== p.name) {
                    if (p.hasStock === false) {
                        if (state.inventory[oldName]) delete state.inventory[oldName];
                    } else {
                        state.inventory[p.name] = state.inventory[oldName] || { stock: 0, minAlert: 5 };
                        delete state.inventory[oldName];
                    }
                }
                saveData();
                render();
                showToast("Product updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteProductIndex(i) {
            showConfirm("Delete this item?", async function () {
                const p = state.products[i];
                if (p && p.name && state.inventory && state.inventory[p.name]) delete state.inventory[p.name];
                if (p) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('products', { name: p.name, category: p.category || '' });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('products', { name: p.name, category: p.category || '' });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.products.splice(i, 1);
                saveData();
                render();
                showToast("Product deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }
        function renderCategories() {
            return `
                <div class="card">
                    <h2>Add Category</h2>
                    <div class="card-header-buttons">
                        <button class="quick-nav-btn back" onclick="switchTab('products')">‚Üê Products/Services</button>
                    </div>
                    <form onsubmit="addCategory(event)">
                        <div class="form-group">
                            <input type="text" id="categoryName" placeholder="Category Name" required>
                        </div>
                        <button type="submit">Add Category</button>
                    </form>
                </div>

               <div class="card">
    <h2>All Categories (${state.categories.length})</h2>
    
    ${state.categories.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_categories" onchange="toggleSelectAllCategories()" class="checkbox-select">
            <label for="selectAll_categories">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCategoryCount()} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDeleteCategories()" ${!hasSelectedCategories() ? 'disabled' : ''}>
                üóëÔ∏è Delete Selected
            </button>
        </div>
    ` : ''}
    
    ${state.categories.map((cat, i) => {
                return `
            <div class="item">
                <div style="display: flex; gap: 12px; align-items: center;">
                    <input type="checkbox" class="checkbox-select" 
                           ${state.selectedItems.categories && state.selectedItems.categories[i] ? 'checked' : ''}
                           onchange="toggleSelectCategory(${i})">
                    <div style="flex: 1; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span class="item-title">${cat}</span>
                            <div class="item-subtitle">${state.products.filter(p => p.category === cat).length} products</div>
                        </div>
                        <div class="flex-gap">
                            <button class="btn-small" onclick="editCategoryIndex(${i})">Edit</button>
                            <button class="btn-small btn-danger" onclick="deleteCategoryIndex(${i})">Delete</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
            }).join('') || '<p style="text-align: center; color: #666;">No categories yet</p>'}
</div>
            `;
        }

        function toggleSelectAllCategories() {
            if (!state.selectedItems.categories) state.selectedItems.categories = {};

            // Check if all categories are currently selected
            const allSelected = state.categories.every((cat, i) => state.selectedItems.categories[i]);

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            state.categories.forEach((cat, i) => {
                state.selectedItems.categories[i] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectCategory(index) {
            if (!state.selectedItems.categories) state.selectedItems.categories = {};
            state.selectedItems.categories[index] = !state.selectedItems.categories[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedCategories() {
            return state.selectedItems.categories && Object.values(state.selectedItems.categories).some(v => v);
        }

        function getSelectedCategoryCount() {
            if (!state.selectedItems.categories) return 0;
            return Object.values(state.selectedItems.categories).filter(v => v).length;
        }

        function bulkDeleteCategories() {
            const selected = Object.keys(state.selectedItems.categories || {})
                .filter(i => state.selectedItems.categories[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No categories selected', 'info');

            showConfirm(`Delete ${selected.length} selected categories?`, async function () {
                // Sort in reverse to delete from end first
                selected.sort((a, b) => b - a).forEach(i => {
                    const name = state.categories[i];
                    if (syncEnabled && name) { try { deleteOne('categories', { name }); } catch { } }
                    state.categories.splice(i, 1);
                });

                state.selectedItems.categories = {};
                saveData();
                render();
                showToast(`${selected.length} categories deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        async function addCategory(e) {
            e.preventDefault();
            const name = document.getElementById('categoryName').value.trim();
            if (state.categories.includes(name)) return showToast('Category already exists', 'error');

            state.categories.push(name);
            saveData();
            render();
            showToast("Category added", "success");

            // Sync in background
            if (syncEnabled) {
                await upsertOne('categories', { name });
                syncInBackground();
            }
        }

        function editCategoryIndex(i) {
            const oldName = state.categories[i];
            const name = prompt("Category name:", oldName);
            if (name && name.trim()) {
                const newName = name.trim();
                if (state.categories.includes(newName) && newName !== oldName) {
                    return showToast('Category already exists', 'error');
                }
                state.categories[i] = newName;
                // Update products with this category
                state.products.forEach(p => {
                    if (p.category === oldName) p.category = newName;
                });
                saveData();
                render();
                showToast("Category updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteCategoryIndex(i) {
            const cat = state.categories[i];
            const productsInCategory = state.products.filter(p => p.category === cat).length;
            if (productsInCategory > 0) {
                if (!confirm(`This category has ${productsInCategory} products. Delete anyway?`)) {
                    return;
                }
            }
            showConfirm("Delete this category?", async function () {
                state.categories.splice(i, 1);
                saveData();
                render();
                showToast("Category deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderExpenses() {
            const stats = getStats();

            let filteredExpenses = state.expenses.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredExpenses = filteredExpenses.filter(e =>
                    e.description.toLowerCase().includes(Period) ||
                    e.category.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredExpenses = filteredExpenses.filter(e => new Date(e.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredExpenses = filteredExpenses.filter(e => new Date(e.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCategory) {
                filteredExpenses = filteredExpenses.filter(e => e.category === state.filterCategory);
            }

            return `
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-label">TOTAL EXPENSES</div>
                        <div class="stat-value">üí± ${formatNumber(stats.totalExpenses)} Tsh</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">MONTH EXPENSES</div>
                        <div class="stat-value">üí± ${formatNumber(stats.monthExpenses)} Tsh</div>
                    </div>
                </div>

                <div class="card">
                    <h2>Add Expense</h2>
                    <form onsubmit="addExpense(event)">
                        <div class="form-group">
                            <label>Description</label>
                            <input type="text" id="expenseDesc" placeholder="e.g., Rent, Utilities" required>
                        </div>
                        <div class="form-group">
                            <label>Category</label>
                            <select id="expenseCategory">
                                <option>Rent</option>
                                <option>Utilities</option>
                                <option>Supplies</option>
                                <option>Salaries</option>
                                <option>Marketing</option>
                                <option>Transportation</option>
                                <option>Office Electricity bills</option>
                                <option>Waste disposal bills</option>
                                <option>Food Expenses</option>
                                <option>Miscellaneous</option>
                                <option>Machine Repair bills</option>
                                <option>Home rent</option>
                                <option>Other</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="text" id="expenseAmount" class="money-input" placeholder="0" required>
                        </div>
                        <div class="form-group">
                            <label>Payment Method</label>
                            <select id="expensePayment">
                                <option>Cash</option>
                                <option>Card</option>
                                <option>Mobile Money</option>
                                <option>M-Pesa Lipa Number</option>
                                <option>Bank Transfer</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Comment (Optional)</label>
                            <textarea id="expenseComment" placeholder="Additional notes..."></textarea>
                        </div>
                        <button type="submit">Add Expense</button>
                    </form>
                </div>

                <div class="card">
                    <h2>Recent Expenses (${filteredExpenses.length})</h2>
                    
                    <div class="search-box">
                        <input type="text" placeholder="üîç Search expenses..." oninput="updateSearchPeriod(this.value)">
                    </div>

                    <div class="filter-row">
                        <input type="date" placeholder="From" onchange="updateFilterDateFrom(this.value)" value="${state.filterDateFrom || ''}">
                        <input type="date" placeholder="To" onchange="updateFilterDateTo(this.value)" value="${state.filterDateTo || ''}">
                        <select onchange="updateFilterCategory(this.value)">
                            <option value="">All Categories</option>
                            ${[...new Set(state.expenses.map(e => e.category))]
                    .filter(c => !!c)
                    .sort((a, b) => String(a).localeCompare(String(b)))
                    .map(c =>
                        `<option value="${c}" ${state.filterCategory === c ? 'selected' : ''}>${c}</option>`
                    ).join('')}
                        </select>
                        <button class="btn-small btn-secondary" onclick="clearFilters()">Clear</button>
                    </div>
                    </div>

    ${filteredExpenses.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_expenses" onchange="toggleSelectAll('expenses')" class="checkbox-select">
            <label for="selectAll_expenses">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCount('expenses')} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDelete('expenses')" ${!hasSelected('expenses') ? 'disabled' : ''}>
                üóëÔ∏è Delete Selected
            </button>
        </div>
    ` : ''}

                    ${filteredExpenses.slice().reverse().map((e, idx) => `
    <div class="item">
        <div style="display: flex; gap: 12px; align-items: start;">
            <input type="checkbox" class="checkbox-select" 
                   ${state.selectedItems.expenses && state.selectedItems.expenses[e.id] ? 'checked' : ''}
                   onchange="toggleSelect('expenses', '${e.id}')">
            <div style="flex: 1;">
                <div class="item-header">
                                <span class="item-title">${e.description}</span>
                                <span style="color: #d32f2f; font-weight: 700;">üí± ${formatNumber(e.amount)} Tsh</span>
                            </div>
                            <div class="item-subtitle">
                                ${e.date} | ${e.category} | ${e.payment}
                                ${e.comment ? '<br>üí¨ ' + e.comment : ''}
                            </div>
                            <div class="flex-gap" style="margin-top:8px;">
                                <button class="btn-small" onclick="editExpenseIndex(${state.expenses.length - 1 - idx})">Edit</button>
                                <button class="btn-small btn-danger" onclick="deleteExpenseIndex(${state.expenses.length - 1 - idx})">Delete</button>
                       </div>
                </div>
            </div>
        </div>
    </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No expenses yet</p>'}
                </div>
            `;
        }

        function updateFilterCategory(value) {
            state.filterCategory = value;
            render();
        }

        async function addExpense(e) {
            e.preventDefault();
            const amount = parseMoney(document.getElementById('expenseAmount').value);
            if (isNaN(amount) || amount <= 0) {
                return showToast('Please enter a valid amount', 'error');
            }

            const now = new Date();  // ‚úÖ ADD THIS LINE

            const expense = {
                id: generateID('expenses'),
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                description: document.getElementById('expenseDesc').value.trim(),
                category: document.getElementById('expenseCategory').value,
                amount: amount,
                payment: document.getElementById('expensePayment').value,
                comment: document.getElementById('expenseComment').value.trim()
            };

            state.expenses.push(expense);
            saveData();
            render();
            showToast("Expense added", "success");

            // Always attempt to upsert the expense; it will be queued if not authenticated
            await upsertOne('expenses', {
                date: expense.date,
                time: expense.time,
                timestamp: expense.timestamp,
                description: expense.description,
                category: expense.category,
                amount: expense.amount,
                payment: expense.payment,
                comment: expense.comment
            });
            if (syncEnabled) syncInBackground();
        }

        async function editExpenseIndex(i) {
            const e = state.expenses[i];
            if (!e) return showToast("Expense not found", "error");
            const desc = prompt("Description:", e.description);
            const amt = prompt("Amount:", e.amount);
            if (desc && amt) {
                const amtNum = parseFloat(amt);
                if (!isNaN(amtNum) && amtNum > 0) {
                    e.description = desc.trim();
                    e.amount = amtNum;
                    e.timestamp = Date.now();
                    saveData();
                    render();
                    showToast("Expense updated", "success");

                    if (syncEnabled) {
                        await upsertOne('expenses', {
                            date: e.date,
                            time: e.time,
                            timestamp: e.timestamp,
                            description: e.description,
                            category: e.category,
                            amount: e.amount,
                            payment: e.payment,
                            comment: e.comment
                        });
                        syncInBackground();
                    }
                } else {
                    showToast("Invalid amount", "error");
                }
            }
        }

        function deleteExpenseIndex(i) {
            showConfirm("Delete this expense?", async function () {
                const e = state.expenses[i];
                if (e) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('expenses', { timestamp: e.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('expenses', { timestamp: e.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.expenses.splice(i, 1);
                saveData();
                render();
                showToast("Expense deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderInventory() {
            const trackedProducts = state.products.filter(p => p.hasStock !== false);
            const lowStock = trackedProducts.filter(p => {
                const inv = state.inventory[p.name] || { stock: 0, minAlert: 5 };
                return inv.stock <= inv.minAlert;
            });

            return `
                ${lowStock.length > 0 ? `
                    <div class="alert-box-danger">
                        <strong>‚ö†Ô∏è ${lowStock.length} Products Low on Stock!</strong>
                    </div>
                ` : ''}

                <div class="card">
                    <h2>Stock Levels (${trackedProducts.length} Items)</h2>
                    ${trackedProducts.map(p => {
                const inv = state.inventory[p.name] || { stock: 0, minAlert: 5 };
                const isLow = inv.stock <= inv.minAlert;
                const stockValue = inv.stock * p.cost;
                return `
                            <div class="item" style="${isLow ? 'border-left: 4px solid #d32f2f;' : ''}">
                                <div class="item-header">
                                    <span class="item-title">${p.name}</span>
                                    <span class="badge ${isLow ? 'badge-danger' : 'badge-success'}">
                                        ${isLow ? '‚ö†Ô∏è LOW' : '‚úÖ OK'}
                                    </span>
                                </div>
                                <div class="item-subtitle">
                                    Stock: ${inv.stock} units | Min Alert: ${inv.minAlert}<br>
                                    Value: üí± ${formatNumber(stockValue)} Tsh
                                </div>
                                <div class="flex-gap" style="margin-top: 8px;">
                                    <button class="btn-success btn-small" onclick="adjustStock('${p.name}', 10)">+10</button>
                                    <button class="btn-success btn-small" onclick="adjustStock('${p.name}', 1)">+1</button>
                                    <button class="btn-danger btn-small" onclick="adjustStock('${p.name}', -1)">-1</button>
                                    <input type="number" id="inv_input_${encodeURIComponent(p.name)}" value="${inv.stock}" min="0" style="width:80px;padding:6px;">
                                    <button class="btn-small" onclick="saveStockFor('${p.name}')">Save</button>
                                    <button class="btn-small btn-secondary" onclick="setMinAlert('${p.name}')">‚ö†Ô∏è ${inv.minAlert}</button>
                                </div>
                            </div>
                        `;
            }).join('') || '<p style="text-align: center; color: #666;">No stock-tracked items yet</p>'}
                </div>
            `;
        }

        // Unified Inventory Tab: Purchases + Stock
        function renderInventoryTab() {
            // Summary
            const purchases = (state.inventoryPurchases || []);
            const cycles = (state.inventoryPurchaseCycles || []);
            const totalSpent = purchases.reduce((s, p) => s + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);
            const uniqueSuppliers = Array.from(new Set(purchases.map(p => (p.supplierName || '').trim()).filter(Boolean))).length;

            // Filters
            const filter = state.inventoryFilters || {};
            const cycleOptions = cycles.length > 0
                ? `<option value="">All Periods</option>` + cycles.map(c => `<option value="${c.number}">Period ${c.number} ${c.title ? '‚Äì ' + c.title : ''}</option>`).join('')
                : '<option value="">No Periods yet</option>';

            // Filtered purchases
            const filtered = purchases.filter(p => {
                const matchPeriod = !filter.PeriodNumber || String(p.cycleNumber) === String(filter.PeriodNumber);
                const matchSupplier = !filter.supplier || (p.supplierName || '').toLowerCase().includes(filter.supplier.toLowerCase());
                const df = filter.dateFrom ? new Date(filter.dateFrom).getTime() : null;
                const dt = filter.dateTo ? new Date(filter.dateTo).getTime() : null;
                const ts = p.timestamp || (p.purchaseDate ? new Date(p.purchaseDate).getTime() : 0);
                const matchDate = (!df || ts >= df) && (!dt || ts <= dt);
                return matchPeriod && matchSupplier && matchDate;
            });

            // Group by Period
            const groupedHTML = cycles.map(cycle => {
                const cps = filtered.filter(p => p.cycleNumber === cycle.number);
                const cycleTotal = cps.reduce((sum, p) => sum + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);
                const cycleStart = cycle.startDate || (cps[0]?.purchaseDate) || '';
                const nextCycle = cycles.find(c => c.number === cycle.number + 1);
                const cycleEnd = cycle.endDate || (nextCycle?.startDate) || '';
                let lastedText = '';
                if (cycleStart && cycleEnd) {
                    const days = Math.round((new Date(cycleEnd).getTime() - new Date(cycleStart).getTime()) / (1000 * 60 * 60 * 24));
                    if (!isNaN(days)) lastedText = `Lasted: ${days} day${days === 1 ? '' : 's'}`;
                }
                return `
                    <div class="card">
                        <div class="flex-between">
                            <h2>Period ${cycle.number} ${cycle.title ? '‚Äì ' + cycle.title : ''}</h2>
                            <div class="flex-gap">
                                <span class="badge">Items: ${cps.length}</span>
                                <span class="badge">Spent: ${formatNumber(cycleTotal)} Tsh</span>
                                ${lastedText ? `<span class="badge">${lastedText}</span>` : ''}
                                <button class="btn-small" onclick="downloadInventoryCyclePDF(${cycle.number})">üì• Period PDF</button>
                            </div>
                        </div>
                        ${cps.length === 0 ? '<p style="color:#666">No purchases in this Period</p>' : cps.map(p => `
                            <div class="item">
                                <div class="item-header">
                                    <span class="item-title">${p.itemName} √ó ${p.quantity || 1}</span>
                                    <span class="item-subtitle">${p.purchaseDate || ''} ${p.time || ''}</span>
                                </div>
                                <div class="item-subtitle">
                                    Unit: ${formatNumber(p.unitCost || p.buyingPrice)} Tsh | Total: ${formatNumber(p.totalCost || (p.buyingPrice || 0))} Tsh<br>
                                    Supplier: ${p.supplierName || ''} ${p.supplierPhone ? '(' + p.supplierPhone + ')' : ''}<br>
                                    ${p.supplierAddress || ''}
                                    ${p.notes ? `<br>Notes: ${p.notes}` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }).join('');

            // Build UI
            const summary = `
                <div class="card">
                    <div class="flex-between">
                        <h2>Inventory</h2>
                        <div class="flex-gap">
                            <button class="btn-success" onclick="openInventoryModal()">‚ûï Add Inventory Purchase</button>
                            <button class="btn-small" onclick="generateInventoryReport('csv')">üì• Generate Report (CSV)</button>
                            <button class="btn-small" onclick="downloadInventoryPurchasesReportPDF()">üìÑ Generate Report (PDF)</button>
                        </div>
                    </div>
                    <div class="flex-gap" style="margin-top:8px;">
                        <span class="badge">Purchases: ${purchases.length}</span>
                        <span class="badge">Suppliers: ${uniqueSuppliers}</span>
                        <span class="badge">Total Spent: ${formatNumber(totalSpent)} Tsh</span>
                    </div>
                </div>`;

            const filters = `
                <div class="card">
                    <h3>Filter</h3>
                    <div class="grid-2" style="gap:12px;">
                        <div>
                            <label>Period</label>
                            <select id="invFilterPeriod" onchange="updateInventoryFilter('PeriodNumber', this.value)">${cycleOptions}</select>
                        </div>
                        <div>
                            <label>Supplier</label>
                            <input id="invFilterSupplier" type="text" value="${filter.supplier || ''}" placeholder="Supplier name" oninput="updateInventoryFilter('supplier', this.value)">
                        </div>
                        <div>
                            <label>From</label>
                            <input id="invFilterFrom" type="date" value="${filter.dateFrom || ''}" onchange="updateInventoryFilter('dateFrom', this.value)">
                        </div>
                        <div>
                            <label>To</label>
                            <input id="invFilterTo" type="date" value="${filter.dateTo || ''}" onchange="updateInventoryFilter('dateTo', this.value)">
                        </div>
                    </div>
                </div>`;

            // Embed the existing stock view
            const stock = renderInventory();

            return summary + filters + (groupedHTML || '<p style="text-align:center;color:#666;">No Periods yet. Add an inventory purchase to create a new Period.</p>') + stock;
        }

        function updateInventoryFilter(key, value) {
            state.inventoryFilters = state.inventoryFilters || {};
            state.inventoryFilters[key] = value;
            saveData();
            render();
        }

        function openInventoryModal() {
            const modal = document.getElementById('inventoryModal');
            const content = document.getElementById('inventoryModalContent');
            if (!modal || !content) return;
            const products = (state.products || []).filter(p => p.hasStock !== false);
            const productOptions = products.length > 0
                ? products
                    .slice()
                    .sort((a, b) => String(a.name).localeCompare(String(b.name)))
                    .map(p => `<option value="${p.name}">${p.name}</option>`).join('')
                : '<option value="">No products found</option>';
            const cycles = state.inventoryPurchaseCycles || [];
            const nextPeriodNumber = (cycles?.length || 0) + 1;
            const defaultTitle = new Date().toLocaleString('en-GB', { month: 'long', year: 'numeric' }) + ' Period';
            const cycleOptions = cycles.map(c => `<option value="${c.number}">Period ${c.number} ${c.title ? '‚Äì ' + c.title : ''}</option>`).join('');

            content.innerHTML = `
                <div class="grid-2" style="gap:12px;">
                    <div>
                        <label>Product</label>
                        <select id="invProductSelect">${productOptions}</select>
                    </div>
                    <div>
                        <label>Quantity</label>
                        <input id="invQuantity" type="number" min="1" step="1" value="1">
                    </div>
                    <div>
                        <label>Unit Cost (Tsh)</label>
                        <input id="invUnitCost" type="number" min="0" step="0.01" placeholder="0.00">
                    </div>
                    <div>
                        <label>Total Cost (auto)</label>
                        <input id="invTotalCost" type="number" min="0" step="0.01" placeholder="0.00" disabled>
                    </div>
                    <div>
                        <label>Supplier Name</label>
                        <input id="invSupplierName" type="text" placeholder="Supplier name">
                    </div>
                    <div>
                        <label>Supplier Phone</label>
                        <input id="invSupplierPhone" type="text" placeholder="Phone">
                    </div>
                    <div class="grid-span-2">
                        <label>Supplier Address</label>
                        <input id="invSupplierAddress" type="text" placeholder="Address">
                    </div>
                    <div>
                        <label>Date</label>
                        <input id="invDate" type="date" value="${getTodayDateString()}">
                    </div>
                    <div>
                        <label>Time</label>
                        <input id="invTime" type="time" value="${new Date().toISOString().slice(11, 16)}">
                    </div>
                    <div class="grid-span-2">
                        <label>Notes (optional)</label>
                        <input id="invNotes" type="text" placeholder="Notes">
                    </div>
                </div>

                    <div class="card" style="margin-top:12px;">
                        <h3>Period</h3>
                        <div class="flex-gap">
                            <label style="display:flex;align-items:center;gap:8px;">
                                <input id="invCreateNewPeriod" type="checkbox" checked>
                                Create new Period (recommended)
                            </label>
                            <div>
                                <label>Existing Period</label>
                                <select id="invPeriodSelect"><option value="">‚Äî</option>${cycleOptions}</select>
                            </div>
                            <div>
                                <label>New Period Title</label>
                                <input id="invNewPeriodTitle" type="text" value="${defaultTitle}">
                            </div>
                        </div>
                    </div>
                `;

            // Auto-update total cost
            setTimeout(() => {
                const qtyEl = document.getElementById('invQuantity');
                const unitEl = document.getElementById('invUnitCost');
                const totalEl = document.getElementById('invTotalCost');
                function updateTotal() {
                    const q = parseFloat(qtyEl.value || '0');
                    const u = parseFloat(unitEl.value || '0');
                    const t = (!isNaN(q) && !isNaN(u)) ? (q * u) : 0;
                    totalEl.value = t.toFixed(2);
                }
                qtyEl?.addEventListener('input', updateTotal);
                unitEl?.addEventListener('input', updateTotal);
                updateTotal();
            }, 0);

            modal.classList.add('show');
        }

        function closeInventoryModal() {
            const modal = document.getElementById('inventoryModal');
            if (modal) modal.classList.remove('show');
        }

        function ensurePeriodCreated(purchaseDate, time, titleHint) {
            state.inventoryPurchaseCycles = state.inventoryPurchaseCycles || [];
            const nextNumber = (state.inventoryPurchaseCycles.length || 0) + 1;
            const title = titleHint || (new Date(purchaseDate).toLocaleString('en-GB', { month: 'long', year: 'numeric' }) + ' Period');
            const cycle = {
                id: generateID('invCycle'),
                number: nextNumber,
                title,
                startDate: purchaseDate,
                endDate: '',
                notes: ''
            };
            state.inventoryPurchaseCycles.push(cycle);
            // Persist new period immediately when online
            if (syncEnabled && currentUser) {
                upsertOne('inventory_purchase_periods', {
                    period_number: nextNumber,
                    title,
                    start_date: purchaseDate,
                    end_date: '',
                    notes: ''
                });
            }
            return nextNumber;
        }

        async function addInventoryRecord() {
            const productName = (document.getElementById('invProductSelect')?.value || '').trim();
            const quantity = parseInt(document.getElementById('invQuantity')?.value || '0', 10);
            const unitCost = parseFloat(document.getElementById('invUnitCost')?.value || '0');
            const totalCost = parseFloat(document.getElementById('invTotalCost')?.value || '0');
            const supplierName = (document.getElementById('invSupplierName')?.value || '').trim();
            const supplierPhone = (document.getElementById('invSupplierPhone')?.value || '').trim();
            const supplierAddress = (document.getElementById('invSupplierAddress')?.value || '').trim();
            const purchaseDate = document.getElementById('invDate')?.value || getTodayDateString();
            const time = document.getElementById('invTime')?.value || new Date().toISOString().slice(11, 16);
            const notes = (document.getElementById('invNotes')?.value || '').trim();
            const createNew = !!(document.getElementById('invCreateNewPeriod')?.checked);
            const selectedPeriod = document.getElementById('invPeriodSelect')?.value || '';
            const newPeriodTitle = (document.getElementById('invNewPeriodTitle')?.value || '').trim();

            if (!productName) return showToast('Select a product', 'error');
            if (!quantity || quantity <= 0) return showToast('Enter a valid quantity', 'error');
            if (isNaN(unitCost) || unitCost <= 0) return showToast('Enter unit cost', 'error');

            // DePeriodine Period number
            let cycleNumber = selectedPeriod ? parseInt(selectedPeriod, 10) : null;
            if (createNew || !cycleNumber) {
                cycleNumber = ensurePeriodCreated(purchaseDate, time, newPeriodTitle);
            }

            const timestamp = Date.now();
            const record = {
                id: generateID('invPurchase'),
                cycleNumber,
                itemName: productName,
                quantity,
                unitCost,
                totalCost: (isNaN(totalCost) || totalCost === 0) ? (quantity * unitCost) : totalCost,
                supplierName,
                supplierPhone,
                supplierAddress,
                purchaseDate,
                time,
                notes,
                timestamp
            };

            state.inventoryPurchases = state.inventoryPurchases || [];
            state.inventoryPurchases.push(record);

            // Update product stock locally
            updateProductStock(productName, quantity);

            // Record as an expense (office money usage)
            const expense = {
                id: generateID('expenses'),
                date: purchaseDate,
                time,
                timestamp,
                description: `Inventory: ${productName} √ó ${quantity}`,
                category: 'Inventory Purchase',
                amount: record.totalCost,
                payment: 'cash',
                comment: `Period ${cycleNumber}`
            };
            state.expenses.push(expense);

            saveData();
            closeInventoryModal();
            render();
            showToast('Inventory purchase saved', 'success');
            if (syncEnabled) {
                // Upsert purchase
                await upsertOne('inventory_purchases', {
                    period_number: record.cycleNumber,
                    item_name: record.itemName,
                    quantity: record.quantity,
                    unit_cost: record.unitCost,
                    total_cost: record.totalCost,
                    purchase_date: record.purchaseDate,
                    supplier_name: record.supplierName,
                    supplier_phone: record.supplierPhone,
                    supplier_address: record.supplierAddress,
                    notes: record.notes,
                    timestamp: record.timestamp
                });
                // Upsert related expense
                await upsertOne('expenses', {
                    date: expense.date,
                    time: expense.time,
                    timestamp: expense.timestamp,
                    description: expense.description,
                    category: expense.category,
                    amount: expense.amount,
                    payment: expense.payment,
                    comment: expense.comment
                });
                // Upsert inventory stock snapshot
                const inv = state.inventory[productName] || { stock: 0, minAlert: 5 };
                await upsertOne('inventory', { product_name: productName, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                syncInBackground();
            }
        }

        function updateProductStock(productName, quantity) {
            if (!productName || !quantity) return;
            state.inventory = state.inventory || {};
            const inv = state.inventory[productName] || { stock: 0, minAlert: 5 };
            inv.stock = (parseInt(inv.stock || 0, 10) + parseInt(quantity || 0, 10));
            state.inventory[productName] = inv;
        }

        function generateInventoryReport(format = 'csv') {
            const purchases = state.inventoryPurchases || [];
            const cycles = state.inventoryPurchaseCycles || [];
            if (format === 'csv') {
                const headers = ['Product', 'Quantity', 'UnitCost', 'TotalCost', 'Supplier', 'Phone', 'Address', 'Period', 'Date', 'Time'];
                const rows = purchases.map(p => [
                    p.itemName,
                    p.quantity || 0,
                    (p.unitCost || p.buyingPrice || 0),
                    (p.totalCost || p.buyingPrice || 0),
                    p.supplierName || '',
                    p.supplierPhone || p.supplierContact || '',
                    p.supplierAddress || '',
                    p.cycleNumber,
                    p.purchaseDate || '',
                    p.time || ''
                ]);
                const csv = [headers.join(','), ...rows.map(r => r.map(v => String(v).replace(/\n/g, ' ').replace(/,/g, ';')).join(','))].join('\n');
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Inventory_Report_${getTodayDateString()}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                showToast('CSV report downloaded', 'success');
            } else {
                downloadInventoryPurchasesReportPDF();
            }
        }

        // Inventory PDF generators
        async function downloadInventoryPurchasesReportPDF() {
            await ensureLogoReady();
            try {
                const { jsPDF } = window.jspdf || {};
                if (!jsPDF) {
                    console.error('jsPDF not loaded');
                    showToast('PDF library not loaded', 'error');
                    return;
                }
                const doc = new jsPDF({ unit: 'pt', format: 'a4' });
                const pageWidth = doc.internal.pageSize.getWidth();
                const margin = 50;
                const usableWidth = pageWidth - margin * 2;
                let y = 120;

                // Header (match Financial Report)
                doc.setFillColor(26, 26, 26);
                doc.rect(0, 0, pageWidth, 100, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(24);
                doc.setFont(undefined, 'bold');
                const profile = (typeof getUserProfileData === 'function') ? getUserProfileData() : (state.userProfile || { businessName: 'TUBA', address: '', phone: '', email: '' });
                const drewInvTermHdr = drawLogo(doc, margin, 20, 36, { borderRadius: 18 });
                const titleXTermHdr = drewInvTermHdr ? (margin + 52) : margin;
                doc.text(profile.businessName || 'TUBA', titleXTermHdr, 45);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text(`${profile.address || ''} | ${profile.phone || ''} | ${profile.email || ''}`, margin, 70);
                doc.setDrawColor(102, 126, 234);
                doc.setLineWidth(3);
                doc.line(margin, 85, pageWidth - margin, 85);

                // Title
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text('Inventory Purchases Report', margin, y);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text(`Generated: ${getTodayDateString()}`, margin, y + 20);
                y += 50;

                const cycles = state.inventoryPurchaseCycles || [];
                const purchases = state.inventoryPurchases || [];

                const drawTable = (headers, rows, startY) => {
                    const colCount = headers.length;
                    const colWidth = usableWidth / colCount;
                    let curY = startY;
                    const rowHeight = 20;

                    doc.setFillColor(102, 126, 234);
                    doc.roundedRect(margin, curY, usableWidth, rowHeight, 3, 3, 'F');
                    doc.setTextColor(255, 255, 255);
                    doc.setFont(undefined, 'bold');
                    doc.setFontSize(10);
                    for (let i = 0; i < colCount; i++) {
                        const txtX = margin + i * colWidth + 8;
                        doc.text(String(headers[i]), txtX, curY + 14);
                    }
                    curY += rowHeight + 2;

                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    for (let r = 0; r < rows.length; r++) {
                        if (curY + rowHeight > 750) {
                            doc.addPage();
                            curY = margin;
                        }
                        if (r % 2 === 0) {
                            doc.setFillColor(248, 249, 250);
                            doc.roundedRect(margin, curY, usableWidth, rowHeight, 2, 2, 'F');
                        }
                        doc.setTextColor(40, 40, 40);
                        for (let c = 0; c < colCount; c++) {
                            const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                            const txtX = margin + c * colWidth + 8;
                            doc.text(txt, txtX, curY + 14, { maxWidth: colWidth - 16 });
                        }
                        curY += rowHeight;
                    }
                    return curY + 20;
                };

                if (cycles.length === 0) {
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'normal');
                    doc.text('No Periods found.', margin, y);
                } else {
                    cycles.forEach(cycle => {
                        const cps = purchases.filter(p => p.cycleNumber === cycle.number);
                        const cycleTotal = cps.reduce((sum, p) => sum + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);
                        if (y > 650) { doc.addPage(); y = margin; }
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(0, 0, 0);
                        doc.text(`Period ${cycle.number} ${cycle.title ? '‚Äì ' + cycle.title : ''}`, margin, y);
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(100, 100, 100);
                        doc.text(`Items: ${cps.length} | Spent: ${formatNumber(cycleTotal)} Tsh`, margin, y + 16);
                        y += 36;

                        const headers = ['Date', 'Time', 'Item', 'Qty', 'Unit', 'Total', 'Supplier', 'Phone'];
                        const rows = cps.map(p => [
                            p.purchaseDate || '',
                            p.time || '',
                            p.itemName,
                            String(p.quantity || 1),
                            formatNumber(p.unitCost || p.buyingPrice || 0),
                            formatNumber(p.totalCost || p.buyingPrice || 0),
                            p.supplierName || '',
                            p.supplierPhone || p.supplierContact || ''
                        ]);
                        y = drawTable(headers, rows, y);
                    });
                }

                // Footer
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFillColor(240, 240, 240);
                    doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                    doc.setTextColor(100, 100, 100);
                    doc.setFontSize(9);
                    doc.text(`Page ${i} of ${pageCount}`, margin, 792 - 11);
                    doc.text(`The Ultimate Business Architecture (TUBA) ¬© ${new Date().getFullYear()}`, pageWidth - margin, 792 - 8, { align: 'right' });
                }

                downloadPDFSafe(doc, `Inventory_Purchases_${getTodayDateString()}.pdf`);
                showToast('Inventory report PDF ready', 'success');
            } catch (e) {
                console.error('Inventory PDF error:', e);
                showToast('Failed to generate PDF', 'error');
            }
        }

        async function downloadInventoryCyclePDF(cycleNumber) {
            await ensureLogoReady();
            try {
                const { jsPDF } = window.jspdf || {};
                if (!jsPDF) {
                    console.error('jsPDF not loaded');
                    showToast('PDF library not loaded', 'error');
                    return;
                }
                const doc = new jsPDF({ unit: 'pt', format: 'a4' });
                const pageWidth = doc.internal.pageSize.getWidth();
                const margin = 50;
                const usableWidth = pageWidth - margin * 2;
                let y = 120;

                // Header (match Financial Report)
                doc.setFillColor(26, 26, 26);
                doc.rect(0, 0, pageWidth, 100, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(24);
                doc.setFont(undefined, 'bold');
                const profile = (typeof getUserProfileData === 'function') ? getUserProfileData() : (state.userProfile || { businessName: 'TUBA', address: '', phone: '', email: '' });
                const logo = getLogoForPdf();
                const titleX = logo ? (margin + 48) : margin;
                if (logo) { try { doc.addImage(logo.dataUrl, logo.format, margin, 20, 36, 36); } catch (e) { console.warn('Logo draw error:', e); } }
                doc.text(profile.businessName || 'TUBA', titleX, 45);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text(`${profile.address || ''} | ${profile.phone || ''} | ${profile.email || ''}`, margin, 70);
                doc.setDrawColor(102, 126, 234);
                doc.setLineWidth(3);
                doc.line(margin, 85, pageWidth - margin, 85);

                const cycle = (state.inventoryPurchaseCycles || []).find(c => c.number === cycleNumber);
                const cps = (state.inventoryPurchases || []).filter(p => p.cycleNumber === cycleNumber);
                const cycleTotal = cps.reduce((sum, p) => sum + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);

                // Title
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text(`Inventory Period ${cycleNumber} ${cycle?.title ? '‚Äì ' + cycle.title : ''}`, margin, y);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text(`Items: ${cps.length} | Spent: ${formatNumber(cycleTotal)} Tsh`, margin, y + 20);
                y += 50;

                const headers = ['Date', 'Time', 'Item', 'Qty', 'Unit', 'Total', 'Supplier', 'Phone'];
                const rows = cps.map(p => [
                    p.purchaseDate || '',
                    p.time || '',
                    p.itemName,
                    String(p.quantity || 1),
                    formatNumber(p.unitCost || p.buyingPrice || 0),
                    formatNumber(p.totalCost || p.buyingPrice || 0),
                    p.supplierName || '',
                    p.supplierPhone || p.supplierContact || ''
                ]);

                // Table
                const colCount = headers.length;
                const colWidth = usableWidth / colCount;
                let curY = y;
                const rowHeight = 20;
                doc.setFillColor(102, 126, 234);
                doc.roundedRect(margin, curY, usableWidth, rowHeight, 3, 3, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                for (let i = 0; i < colCount; i++) {
                    const txtX = margin + i * colWidth + 8;
                    doc.text(String(headers[i]), txtX, curY + 14);
                }
                curY += rowHeight + 2;
                doc.setFont(undefined, 'normal');
                doc.setFontSize(9);
                for (let r = 0; r < rows.length; r++) {
                    if (curY + rowHeight > 750) { doc.addPage(); curY = margin; }
                    if (r % 2 === 0) { doc.setFillColor(248, 249, 250); doc.roundedRect(margin, curY, usableWidth, rowHeight, 2, 2, 'F'); }
                    doc.setTextColor(40, 40, 40);
                    for (let c = 0; c < colCount; c++) {
                        const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                        const txtX = margin + c * colWidth + 8;
                        doc.text(txt, txtX, curY + 14, { maxWidth: colWidth - 16 });
                    }
                    curY += rowHeight;
                }

                // Footer
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFillColor(240, 240, 240);
                    doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                    doc.setTextColor(100, 100, 100);
                    doc.setFontSize(9);
                    doc.text(`Page ${i} of ${pageCount}`, margin, 792 - 11);
                    doc.text(`The Ultimate Business Architecture (TUBA) ¬© ${new Date().getFullYear()}`, pageWidth - margin, 792 - 8, { align: 'right' });
                }

                downloadPDFSafe(doc, `Inventory_Period_${cycleNumber}.pdf`);
                showToast('Period report PDF ready', 'success');
            } catch (e) {
                console.error('Period PDF error:', e);
                showToast('Failed to generate Period PDF', 'error');
            }
        }

        async function adjustStock(productName, amount) {
            if (!state.inventory[productName]) {
                state.inventory[productName] = { stock: 0, minAlert: 5 };
            }
            state.inventory[productName].stock = Math.max(0, state.inventory[productName].stock + amount);
            saveData();
            render();
            showToast(`Stock ${amount > 0 ? 'increased' : 'decreased'}`, 'success');
            if (syncEnabled) {
                const inv = state.inventory[productName] || { stock: 0, minAlert: 5 };
                await upsertOne('inventory', { product_name: productName, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                syncInBackground();
            }
        }

        async function saveStockFor(productName) {
            const el = document.getElementById('inv_input_' + encodeURIComponent(productName));
            if (!el) return showToast("Input not found", "error");
            const v = parseInt(el.value);
            if (isNaN(v) || v < 0) return showToast("Invalid value", "error");
            if (!state.inventory) state.inventory = {};
            state.inventory[productName] = state.inventory[productName] || { stock: 0, minAlert: 5 };
            state.inventory[productName].stock = v;

            saveData();
            render();
            showToast("Stock updated", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        function setMinAlert(productName) {
            const current = state.inventory[productName]?.minAlert || 5;
            const newValue = prompt(`Set minimum stock alert for ${productName}:`, current);
            if (newValue !== null) {
                const val = parseInt(newValue);
                if (!isNaN(val) && val >= 0) {
                    if (!state.inventory[productName]) {
                        state.inventory[productName] = { stock: 0, minAlert: 5 };
                    }
                    state.inventory[productName].minAlert = val;
                    saveData();
                    render();
                    showToast('Min alert updated', 'success');

                    // Sync in background
                    if (syncEnabled) syncInBackground();
                } else {
                    showToast('Invalid value', 'error');
                }
            }
        }

        function renderCustomers() {
            // Sort customers by total purchases
            const sortedCustomers = [...state.customers].sort((a, b) =>
                (b.totalPurchases || 0) - (a.totalPurchases || 0)
            );

            return `
                <div class="card">
                    <h2>Add Customer</h2>
                    <form onsubmit="addCustomer(event)">
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" id="customerName" placeholder="Full name" required>
                        </div>
                        <div class="form-group">
                            <label>Email</label>
                            <input type="email" id="customerEmail" placeholder="email@example.com">
                        </div>
                        <div class="form-group">
                            <label>Phone</label>
                            <input type="tel" id="customerPhone" placeholder="+255...">
                        </div>
                        <div class="form-group">
                            <label>Address</label>
                            <input type="text" id="customerAddress" placeholder="Address">
                        </div>
                        <button type="submit">Add Customer</button>
                    </form>
                </div>

                <div class="card">
    <h2>All Customers (${state.customers.length})</h2>
    <div class="search-box">
        <input type="text" placeholder="üîç Search customers..." oninput="searchCustomers(this.value)" id="customerSearch">
    </div>
    
    ${state.customers.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_customers" onchange="toggleSelectAll('customers')" class="checkbox-select">
            <label for="selectAll_customers">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCount('customers')} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDelete('customers')" ${!hasSelected('customers') ? 'disabled' : ''}>
                üóëÔ∏è Delete Selected
            </button>
        </div>
    ` : ''}
    
    <div id="customersList">
        ${renderCustomersList()}
    </div>
</div>
            `;
        }

        function renderCustomersList(searchPeriod = '') {
            let customers = state.customers;
            if (searchPeriod) {
                const Period = searchPeriod.toLowerCase();
                customers = customers.filter(c =>
                    c.name.toLowerCase().includes(Period) ||
                    (c.email && c.email.toLowerCase().includes(Period)) ||
                    (c.phone && c.phone.includes(Period))
                );
            }

            if (customers.length === 0) {
                return '<p style="text-align: center; color: #666;">No customers found</p>';
            }

            return customers.map((c, i) => {
                const actualIndex = state.customers.indexOf(c);
                const purchaseCount = state.sales.filter(s => s.customer === c.name).length;
                return `
        <div class="item">
            <div style="display: flex; gap: 12px; align-items: start;">
                <input type="checkbox" class="checkbox-select" 
                       ${state.selectedItems.customers && state.selectedItems.customers[c.id] ? 'checked' : ''}
                       onchange="toggleSelect('customers', '${c.id}')">
                <div style="flex: 1;">
                    <div class="item-title">${c.name}</div>
                        <div class="item-subtitle">
                            ${c.email ? 'üìß ' + c.email + '<br>' : ''}
                            ${c.phone ? 'üì± ' + c.phone + '<br>' : ''}
                            ${c.address ? 'üìç ' + c.address + '<br>' : ''}
                            <div style="color: #2e7d32; font-weight: 600; margin-top: 4px;">
                                üí∞ Total Purchases: üí± ${formatNumber(c.totalPurchases || 0)} Tsh<br>
                                üìä ${purchaseCount} transactions
                            </div>
                        </div>
                        <div class="flex-gap" style="margin-top:8px;">
                        <button class="btn-small" onclick="viewCustomerHistory(${actualIndex})">History</button>
                        <button class="btn-small" onclick="editCustomerIndex(${actualIndex})">Edit</button>
                        <button class="btn-small btn-danger" onclick="deleteCustomerIndex(${actualIndex})">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    `;
            }).join('');
        }

        function searchCustomers(Period) {
            document.getElementById('customersList').innerHTML = renderCustomersList(Period);
        }

        function viewCustomerHistory(i) {
            const customer = state.customers[i];
            if (!customer) return showToast("Customer not found", "error");

            const sales = state.sales.filter(s => s.customer === customer.name);

            if (sales.length === 0) {
                showToast("No purchase history", "info");
                return;
            }

            let history = `${customer.name}'s Purchase History:\n\n`;
            sales.slice(-10).reverse().forEach(s => {
                history += `${s.date}: ${s.productName} - ${formatNumber(s.totalPrice)} Tsh\n`;
            });

            alert(history);
        }

        async function addCustomer(e) {
            e.preventDefault();
            const name = document.getElementById('customerName').value.trim();

            if (state.customers.some(c => c.name.toLowerCase() === name.toLowerCase())) {
                return showToast('Customer already exists', 'error');
            }

            const customer = {
                id: generateID('customers'),
                name: name,
                email: document.getElementById('customerEmail').value.trim(),
                phone: document.getElementById('customerPhone').value.trim(),
                address: document.getElementById('customerAddress').value.trim(),
                totalPurchases: 0
            };

            state.customers.push(customer);
            saveData();
            render();
            showToast("Customer added", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }
        function editCustomerIndex(i) {
            const c = state.customers[i];
            if (!c) return showToast("Customer not found", "error");
            const name = prompt("Name:", c.name);
            const email = prompt("Email:", c.email);
            const phone = prompt("Phone:", c.phone);
            if (name) {
                c.name = name.trim();
                if (email !== null) c.email = email.trim();
                if (phone !== null) c.phone = phone.trim();
                saveData();
                render();
                showToast("Customer updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteCustomerIndex(i) {
            showConfirm("Delete this customer?", async function () {
                const c = state.customers[i];
                if (c) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('customers', { name: c.name, email: c.email || '' });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('customers', { name: c.name, email: c.email || '' });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.customers.splice(i, 1);
                saveData();
                render();
                showToast("Customer deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderInvoices() {
            const stats = getStats();
            return `
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
        <div class="stat-card" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">TOTAL INVOICED</div>
            <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalInvoiced)} Tsh</div>
        </div>
        <div class="stat-card" style="background: #2e7d32; padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">PAID</div>
            <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalPaid)} Tsh</div>
        </div>
    </div>

    <!-- Template Selection Tabs -->
    <div class="card">
        <h2>üìã Create Document</h2>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
            <button class="transaction-tab ${state.activeInvoiceTab === 'invoice' ? 'mpesa active' : 'mpesa'}" 
                    style="opacity: ${state.activeInvoiceTab === 'invoice' ? '1' : '0.6'};"
                    onclick="switchInvoiceTab('invoice')">
                üìÑ Invoice
            </button>
            <button class="transaction-tab ${state.activeInvoiceTab === 'receipt' ? 'crdb active' : 'crdb'}" 
                    style="opacity: ${state.activeInvoiceTab === 'receipt' ? '1' : '0.6'};"
                    onclick="switchInvoiceTab('receipt')">
                üßæ Receipt
            </button>
        </div>

        ${state.activeInvoiceTab === 'invoice' ? `
            <!-- Invoice Creation Form -->
            <form onsubmit="createInvoice(event)">
                <div class="form-group">
                    <label>Customer</label>
                    <select id="invoiceCustomer" onchange="toggleInvoiceCustomerInput()" required>
                        <option value="">-- Select Customer --</option>
                        ${state.customers
                        .map((c, i) => ({ c, i }))
                        .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                        .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
                        <option value="new">+ Add New Customer</option>
                    </select>
                </div>
                <div id="newInvoiceCustomerFields" style="display:none;">
                    <div class="form-group">
                        <label>New Customer Name</label>
                        <input type="text" id="newInvoiceCustomerName" placeholder="Enter customer name">
                    </div>
                    <div class="form-group">
                        <label>Phone (Optional)</label>
                        <input type="tel" id="newInvoiceCustomerPhone" placeholder="+255...">
                    </div>
                    <div class="form-group">
                        <label>Email (Optional)</label>
                        <input type="email" id="newInvoiceCustomerEmail" placeholder="customer@email.com">
                    </div>
                </div>
                <div class="form-group">
                    <label>Due Date</label>
                    <input type="date" id="invoiceDueDate" required>
                </div>
                <div class="form-group">
                    <label>Payment Periods</label>
                    <input type="text" id="invoicePeriods" placeholder="Due within 7 days" value="Due within 7 days">
                </div>
                <div class="form-group">
    <label>Items/Services</label>
    <div id="invoiceItemsList">
        <div class="invoice-item-row" style="display: flex; gap: 8px; margin-bottom: 8px;">
            <input type="text" class="item-description" placeholder="Item description" style="flex: 2;" required>
            <input type="text" class="item-amount money-input" placeholder="0" style="flex: 1;" required>
            <button type="button" class="btn-small btn-danger" onclick="removeInvoiceItem(this)" style="width: auto; padding: 8px 12px;">‚úï</button>
        </div>
    </div>
    <button type="button" class="btn-secondary" onclick="addInvoiceItem()" style="margin-top: 8px;">+ Add Item</button>
</div>
<div class="form-group">
    <label>Subtotal (Auto-calculated)</label>
    <input type="text" id="invoiceSubtotal" readonly value="0 Tsh" style="background: rgba(0,0,0,0.05);">
</div>
                <div class="form-group">
                    <label>Tax Rate (%)</label>
                    <input type="number" id="invoiceTaxRate" placeholder="0" step="0.01" value="0" min="0" max="100">
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <input type="text" id="invoicePaymentMethod" placeholder="Bank Transfer / Mobile Money" value="Bank Transfer / Mobile Money">
                </div>
                <div class="form-group">
                    <label>Notes (Optional)</label>
                    <textarea id="invoiceNotes" placeholder="Thank you for your business..."></textarea>
                </div>
                <button type="submit">Create Invoice</button>
            </form>
        ` : `
            <!-- Receipt Creation Form -->
<form onsubmit="createReceipt(event)">
    <div class="form-group">
        <label>Received From</label>
        <select id="receiptCustomer" onchange="updateReceiptFromCustomer()" required>
            <option value="">-- Select Customer --</option>
            ${state.customers
                    .map((c, i) => ({ c, i }))
                    .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                    .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
            <option value="manual">‚úèÔ∏è Enter Manually</option>
        </select>
    </div>
    <div id="manualReceiptCustomerField" style="display:none;">
        <div class="form-group">
            <label>Customer Name</label>
            <input type="text" id="manualReceiptCustomerName" placeholder="Enter customer name">
        </div>
        <div class="form-group">
            <label>Customer Email (Optional)</label>
            <input type="email" id="manualReceiptCustomerEmail" placeholder="customer@email.com">
        </div>
    </div>
    <div class="form-group" id="invoiceSelectionGroup" style="display:none;">
        <label>Related Invoice (Optional)</label>
        <select id="receiptInvoice" onchange="updateReceiptFromInvoice()">
            <option value="">-- No Invoice --</option>
        </select>
    </div>
    <div class="form-group">
        <label>Description</label>
        <textarea id="receiptDescription" placeholder="Payment for services rendered" required></textarea>
    </div>
                <div class="form-group">
                    <label>Amount Paid</label>
                    <input type="text" id="receiptAmount" class="money-input" placeholder="0" required>
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <select id="receiptPaymentMethod">
                        <option>Cash</option>
                        <option>M-Pesa</option>
                        <option>Bank Transfer</option>
                        <option>Card</option>
                        <option>Airtel Money</option>
                        <option>Halopesa</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Reference Number (Optional)</label>
                    <input type="text" id="receiptReference" placeholder="REF123XYZ">
                </div>
                <button type="submit">Create Receipt</button>
            </form>
        `}
    </div>

    <!-- Unpaid Invoices -->
    <div class="card">
        <h2>Unpaid Invoices (${state.invoices.filter(i => i.status !== 'Paid').length})</h2>
        
        ${state.invoices.filter(i => i.status !== 'Paid').length > 0 ? `
            <div class="bulk-actions">
                <input type="checkbox" id="selectAll_unpaid_invoices" onchange="toggleSelectAllUnpaidInvoices()" class="checkbox-select">
                <label for="selectAll_unpaid_invoices">Select All</label>
                <span style="color: #666; font-size: 12px; margin-left: 8px;">
                    ${getSelectedUnpaidInvoiceCount()} selected
                </span>
                <button class="btn-small btn-success" onclick="bulkMarkInvoicesPaid()" ${!hasSelectedUnpaidInvoices() ? 'disabled' : ''}>
                    ‚úì Mark as Paid
                </button>
                <button class="btn-small btn-danger" onclick="bulkDeleteUnpaidInvoices()" ${!hasSelectedUnpaidInvoices() ? 'disabled' : ''}>
                    üóëÔ∏è Delete Selected
                </button>
            </div>
            
            ${state.invoices.filter(i => i.status !== 'Paid').map((inv, origIdx) => {
                        const actualIndex = state.invoices.findIndex(i => i === inv);
                        return `
                <div class="item">
                    <div style="display: flex; gap: 12px; align-items: start;">
                        <input type="checkbox" class="checkbox-select" 
                               ${state.selectedItems.unpaid_invoices && state.selectedItems.unpaid_invoices[actualIndex] ? 'checked' : ''}
                               onchange="toggleSelectUnpaidInvoice(${actualIndex})">
                        <div style="flex: 1;">
                            <div class="item-header">
                                <span class="item-title">${inv.number}</span>
                                <span class="badge ${inv.status === 'Overdue' ? 'badge-danger' : 'badge-warning'}">
                                    ${inv.status}
                                </span>
                            </div>
                            <div class="item-subtitle">
                                ${inv.customer}<br>
                                Due: ${inv.dueDate}<br>
                                <span style="font-weight: 700; color: #000;">Amount: üí∞ ${formatNumber(inv.amount)} Tsh</span>
                            </div>
                            <div class="flex-gap" style="margin-top:8px;">
                                <button class="btn-small" onclick="downloadInvoicePDF(${actualIndex})">üì• Invoice PDF</button>
                                <button class="btn-small" onclick="toggleInvoiceStatus(${actualIndex})">Change Status</button>
                                <button class="btn-small btn-danger" onclick="deleteInvoice(${actualIndex})">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
                    }).join('')}
        ` : '<p style="text-align: center; color: #666;">No unpaid invoices</p>'}
    </div>

    <!-- Paid Invoices -->
    <div class="card">
        <h2>Paid Invoices (${state.invoices.filter(i => i.status === 'Paid').length})</h2>
        
        ${state.invoices.filter(i => i.status === 'Paid').length > 0 ? `
            <div class="bulk-actions">
                <input type="checkbox" id="selectAll_paid_invoices" onchange="toggleSelectAllPaidInvoices()" class="checkbox-select">
                <label for="selectAll_paid_invoices">Select All</label>
                <span style="color: #666; font-size: 12px; margin-left: 8px;">
                    ${getSelectedPaidInvoiceCount()} selected
                </span>
                <button class="btn-small btn-danger" onclick="bulkDeletePaidInvoices()" ${!hasSelectedPaidInvoices() ? 'disabled' : ''}>
                    üóëÔ∏è Delete Selected
                </button>
            </div>
            
            ${state.invoices.filter(i => i.status === 'Paid').map((inv, origIdx) => {
                        const actualIndex = state.invoices.findIndex(i => i === inv);
                        return `
                <div class="item">
                    <div style="display: flex; gap: 12px; align-items: start;">
                        <input type="checkbox" class="checkbox-select" 
                               ${state.selectedItems.paid_invoices && state.selectedItems.paid_invoices[actualIndex] ? 'checked' : ''}
                               onchange="toggleSelectPaidInvoice(${actualIndex})">
                        <div style="flex: 1;">
                            <div class="item-header">
                                <span class="item-title">üìÑ ${inv.number}</span>
                                <span class="badge badge-success">Paid</span>
                            </div>
                            <div class="item-subtitle">
                                ${inv.customer}<br>
                                Paid: ${inv.date}<br>
                                <span style="font-weight: 700; color: #000;">Amount: üí∞ ${formatNumber(inv.amount)} Tsh</span>
                            </div>
                            <div class="flex-gap" style="margin-top:8px;">
                                <button class="btn-small" onclick="downloadInvoicePDF(${actualIndex})">üì• Invoice PDF</button>
                                <button class="btn-small btn-danger" onclick="deleteInvoice(${actualIndex})">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
                    }).join('')}
        ` : '<p style="text-align: center; color: #666;">No paid invoices</p>'}
    </div>

    <!-- Receipts -->
    <div class="card">
        <h2>Receipts (${(state.receipts || []).length})</h2>
        
        ${(state.receipts && state.receipts.length > 0) ? `
            <div class="bulk-actions">
                <input type="checkbox" id="selectAll_receipts" onchange="toggleSelectAllReceipts()" class="checkbox-select">
                <label for="selectAll_receipts">Select All</label>
                <span style="color: #666; font-size: 12px; margin-left: 8px;">
                    ${getSelectedReceiptCount()} selected
                </span>
                <button class="btn-small btn-danger" onclick="bulkDeleteReceipts()" ${!hasSelectedReceipts() ? 'disabled' : ''}>
                    üóëÔ∏è Delete Selected
                </button>
            </div>
            
            ${(state.receipts || []).map((receipt, idx) => `
                <div class="item">
                    <div style="display: flex; gap: 12px; align-items: start;">
                        <input type="checkbox" class="checkbox-select" 
                               ${state.selectedItems.receipts && state.selectedItems.receipts[idx] ? 'checked' : ''}
                               onchange="toggleSelectReceipt(${idx})">
                        <div style="flex: 1;">
                            <div class="item-header">
                                <span class="item-title">üßæ ${receipt.number}</span>
                                <span class="badge badge-success">Receipt</span>
                            </div>
                            <div class="item-subtitle">
                                ${receipt.customer}<br>
                                Date: ${receipt.date} ${receipt.time}<br>
                                <span style="font-weight: 700; color: #000;">Amount: üí∞ ${formatNumber(receipt.amount)} Tsh</span>
                                ${receipt.linkedInvoice ? `<br>Linked to: ${receipt.linkedInvoice}` : ''}
                            </div>
                            <div class="flex-gap" style="margin-top:8px;">
                                <button class="btn-small" onclick="downloadReceiptPDF(${idx})">üì• Receipt PDF</button>
                                <button class="btn-small btn-danger" onclick="deleteReceipt(${idx})">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('')}
        ` : '<p style="text-align: center; color: #666;">No receipts yet</p>'}
    </div>
    `;
        }

        function toggleSelectAllUnpaidInvoices() {
            if (!state.selectedItems.unpaid_invoices) state.selectedItems.unpaid_invoices = {};

            const unpaidInvoices = state.invoices.filter(i => i.status !== 'Paid');

            // Check if all unpaid invoices are currently selected
            const allSelected = unpaidInvoices.every((inv) => {
                const idx = state.invoices.indexOf(inv);
                return state.selectedItems.unpaid_invoices[idx];
            });

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            unpaidInvoices.forEach(inv => {
                const idx = state.invoices.indexOf(inv);
                state.selectedItems.unpaid_invoices[idx] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectUnpaidInvoice(index) {
            if (!state.selectedItems.unpaid_invoices) state.selectedItems.unpaid_invoices = {};
            state.selectedItems.unpaid_invoices[index] = !state.selectedItems.unpaid_invoices[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedUnpaidInvoices() {
            return state.selectedItems.unpaid_invoices && Object.values(state.selectedItems.unpaid_invoices).some(v => v);
        }

        function getSelectedUnpaidInvoiceCount() {
            if (!state.selectedItems.unpaid_invoices) return 0;
            return Object.values(state.selectedItems.unpaid_invoices).filter(v => v).length;
        }

        function bulkMarkInvoicesPaid() {
            const selected = Object.keys(state.selectedItems.unpaid_invoices || {})
                .filter(i => state.selectedItems.unpaid_invoices[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No invoices selected', 'info');

            showConfirm(`Mark ${selected.length} invoices as paid?`, async function () {
                selected.forEach(i => {
                    if (state.invoices[i]) {
                        state.invoices[i].status = 'Paid';
                    }
                });

                state.selectedItems.unpaid_invoices = {};
                saveData();
                render();
                showToast(`${selected.length} invoices marked as paid`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function bulkDeleteUnpaidInvoices() {
            const selected = Object.keys(state.selectedItems.unpaid_invoices || {})
                .filter(i => state.selectedItems.unpaid_invoices[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No invoices selected', 'info');

            showConfirm(`Delete ${selected.length} selected invoices?`, async function () {
                selected.sort((a, b) => b - a).forEach(i => {
                    const inv = state.invoices[i];
                    if (syncEnabled && inv) { try { deleteOne('invoices', { number: inv.number }); } catch { } }
                    state.invoices.splice(i, 1);
                });

                state.selectedItems.unpaid_invoices = {};
                saveData();
                render();
                showToast(`${selected.length} invoices deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function toggleSelectAllPaidInvoices() {
            if (!state.selectedItems.paid_invoices) state.selectedItems.paid_invoices = {};

            const paidInvoices = state.invoices.filter(i => i.status === 'Paid');

            // Check if all paid invoices are currently selected
            const allSelected = paidInvoices.every((inv) => {
                const idx = state.invoices.indexOf(inv);
                return state.selectedItems.paid_invoices[idx];
            });

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            paidInvoices.forEach(inv => {
                const idx = state.invoices.indexOf(inv);
                state.selectedItems.paid_invoices[idx] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectPaidInvoice(index) {
            if (!state.selectedItems.paid_invoices) state.selectedItems.paid_invoices = {};
            state.selectedItems.paid_invoices[index] = !state.selectedItems.paid_invoices[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedPaidInvoices() {
            return state.selectedItems.paid_invoices && Object.values(state.selectedItems.paid_invoices).some(v => v);
        }

        function getSelectedPaidInvoiceCount() {
            if (!state.selectedItems.paid_invoices) return 0;
            return Object.values(state.selectedItems.paid_invoices).filter(v => v).length;
        }

        function bulkDeletePaidInvoices() {
            const selected = Object.keys(state.selectedItems.paid_invoices || {})
                .filter(i => state.selectedItems.paid_invoices[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No invoices selected', 'info');

            showConfirm(`Delete ${selected.length} selected invoices?`, async function () {
                selected.sort((a, b) => b - a).forEach(i => {
                    const inv = state.invoices[i];
                    if (syncEnabled && inv) { try { deleteOne('invoices', { number: inv.number }); } catch { } }
                    state.invoices.splice(i, 1);
                });

                state.selectedItems.paid_invoices = {};
                saveData();
                render();
                showToast(`${selected.length} invoices deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function deleteInvoice(index) {
            showConfirm("Delete this invoice?", async function () {
                const inv = state.invoices[index];
                if (inv) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('invoices', { number: inv.number });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('invoices', { number: inv.number });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.invoices.splice(index, 1);
                saveData();
                render();
                showToast("Invoice deleted", "success");

                if (syncEnabled) syncInBackground();
            });
        }

        function toggleInvoiceCustomerInput() {
            const select = document.getElementById('invoiceCustomer');
            const fields = document.getElementById('newInvoiceCustomerFields');
            if (select && fields) {
                if (select.value === 'new') {
                    fields.style.display = 'block';
                } else {
                    fields.style.display = 'none';
                }
            }
        }

        function switchInvoiceTab(tab) {
            state.activeInvoiceTab = tab;
            saveData();
            render();
        }

        function toggleReceiptCustomerInput() {
            const select = document.getElementById('receiptCustomer');
            const fields = document.getElementById('newReceiptCustomerFields');
            if (select && fields) {
                if (select.value === 'new') {
                    fields.style.display = 'block';
                } else {
                    fields.style.display = 'none';
                }
            }
        }

        function addInvoiceItem() {
            const container = document.getElementById('invoiceItemsList');
            const newRow = document.createElement('div');
            newRow.className = 'invoice-item-row';
            newRow.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px;';
            newRow.innerHTML = `
        <input type="text" class="item-description" placeholder="Item description" style="flex: 2;" required>
        <input type="text" class="item-amount money-input" placeholder="0" style="flex: 1;" required oninput="calculateInvoiceSubtotal()">
        <button type="button" class="btn-small btn-danger" onclick="removeInvoiceItem(this)" style="width: auto; padding: 8px 12px;">‚úï</button>
    `;
            container.appendChild(newRow);

            // Add event listener to first input too
            const firstAmount = container.querySelector('.item-amount');
            if (firstAmount && !firstAmount.hasAttribute('oninput')) {
                firstAmount.setAttribute('oninput', 'calculateInvoiceSubtotal()');
            }
        }

        function updateReceiptFromCustomer() {
            const select = document.getElementById('receiptCustomer');
            const manualField = document.getElementById('manualReceiptCustomerField');
            const invoiceGroup = document.getElementById('invoiceSelectionGroup');
            const invoiceSelect = document.getElementById('receiptInvoice');

            if (select.value === 'manual') {
                manualField.style.display = 'block';
                invoiceGroup.style.display = 'none';
                return;
            }

            manualField.style.display = 'none';

            if (select.value === '') {
                invoiceGroup.style.display = 'none';
                return;
            }

            const customer = state.customers[select.value];
            if (!customer) return;

            // Find invoices for this customer
            const customerInvoices = state.invoices.filter(inv =>
                inv.customer === customer.name && inv.status !== 'Paid'
            );

            if (customerInvoices.length > 0) {
                invoiceGroup.style.display = 'block';
                invoiceSelect.innerHTML = '<option value="">-- No Invoice --</option>' +
                    customerInvoices.map((inv, idx) => {
                        const actualIndex = state.invoices.indexOf(inv);
                        return `<option value="${actualIndex}">${inv.number} - ${formatNumber(inv.amount)} Tsh (Due: ${inv.dueDate})</option>`;
                    }).join('');

                // Auto-select first invoice
                if (customerInvoices.length === 1) {
                    invoiceSelect.selectedIndex = 1;
                    updateReceiptFromInvoice();
                }
            } else {
                invoiceGroup.style.display = 'none';
            }
        }

        function updateReceiptFromInvoice() {
            const invoiceSelect = document.getElementById('receiptInvoice');
            const descField = document.getElementById('receiptDescription');
            const amountField = document.getElementById('receiptAmount');

            if (!invoiceSelect.value) return;

            const invoice = state.invoices[invoiceSelect.value];
            if (!invoice) return;

            // Format items properly
            let itemsDescription = '';
            if (Array.isArray(invoice.items)) {
                itemsDescription = invoice.items.map(item =>
                    `${item.description} (${formatMoney(item.amount)} Tsh)`
                ).join(', ');
            } else {
                itemsDescription = String(invoice.items);
            }

            descField.value = `Payment for ${itemsDescription} (Invoice ${invoice.number})`;
            amountField.value = formatMoney(invoice.amount);
        }

        function removeInvoiceItem(button) {
            const container = document.getElementById('invoiceItemsList');
            if (container.children.length > 1) {
                button.parentElement.remove();
                calculateInvoiceSubtotal();
            } else {
                showToast('At least one item is required', 'error');
            }
        }

        function calculateInvoiceSubtotal() {
            const amounts = document.querySelectorAll('.item-amount');
            let subtotal = 0;
            amounts.forEach(input => {
                const val = parseMoney(input.value) || 0;
                subtotal += val;
            });

            const subtotalField = document.getElementById('invoiceSubtotal');
            if (subtotalField) {
                subtotalField.value = formatMoney(subtotal) + ' Tsh';
            }

            // Update total with tax
            const taxRate = parseFloat(document.getElementById('invoiceTaxRate')?.value || 0) / 100;
            const tax = subtotal * taxRate;
            const total = subtotal + tax;

            // You can add a total display field if needed
        }

        async function createReceipt(e) {
            e.preventDefault();

            const customerSelect = document.getElementById('receiptCustomer').value;
            let customer;
            let customerName = '';
            let customerEmail = '';

            if (customerSelect === 'manual') {
                customerName = document.getElementById('manualReceiptCustomerName')?.value.trim();
                customerEmail = document.getElementById('manualReceiptCustomerEmail')?.value.trim();

                if (!customerName) return showToast('Please enter customer name', 'error');

                // Optionally add to customers list
                customer = {
                    id: generateID('customers'),
                    name: customerName,
                    email: customerEmail,
                    phone: '',
                    address: '',
                    totalPurchases: 0
                };
                // Don't auto-add manual entries to avoid clutter
                // state.customers.push(customer);
            } else {
                customer = state.customers[customerSelect];
                customerName = customer.name;
                customerEmail = customer.email || '';
            }

            const amount = parseMoney(document.getElementById('receiptAmount').value);
            if (isNaN(amount) || amount <= 0) {
                return showToast('Please enter a valid amount', 'error');
            }

            const now = new Date();
            const paymentMethod = document.getElementById('receiptPaymentMethod').value;
            const reference = document.getElementById('receiptReference')?.value.trim();

            // Check if linked to an invoice
            const invoiceSelect = document.getElementById('receiptInvoice');
            let linkedInvoice = null;
            if (invoiceSelect && invoiceSelect.value) {
                linkedInvoice = state.invoices[invoiceSelect.value];
                // Mark invoice as paid
                if (linkedInvoice) {
                    linkedInvoice.status = 'Paid';
                    showToast('Invoice marked as paid', 'success');
                }
            }

            const receipt = {
                id: generateID('receipts'),
                number: 'RCPT-' + Date.now().toString().slice(-6),
                customer: customerName,
                customerEmail: customerEmail,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                description: document.getElementById('receiptDescription').value.trim(),
                amount: amount,
                paymentMethod: paymentMethod + (reference ? ' (Ref: ' + reference + ')' : ''),
                linkedInvoice: linkedInvoice ? linkedInvoice.number : null
            };

            if (!state.receipts) state.receipts = [];
            state.receipts.push(receipt);

            saveData();
            render();
            showToast("Receipt created successfully!", "success");

            if (syncEnabled) syncInBackground();
        }

        async function downloadReceiptPDF(idx) {
            await ensureLogoReady();
            const receipt = state.receipts[idx];
            if (!receipt) return showToast("Receipt not found", "error");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: [226.77, 396.85] });
            const margin = 20;
            const centerX = 226.77 / 2;
            let y = 30;

            // Draw zigzag borders
            doc.setDrawColor(0, 0, 0);
            doc.setLineWidth(1);
            const zigzagSize = 8;
            const zigzagCount = Math.floor(226.77 / zigzagSize);

            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, 10, x2, 5);
                    doc.line(x2, 5, x3, 10);
                } else {
                    doc.line(x1, 10, x2, 15);
                    doc.line(x2, 15, x3, 10);
                }
            }

            doc.line(10, 10, 10, 396.85 - 10);
            doc.line(226.77 - 10, 10, 226.77 - 10, 396.85 - 10);

            const profile = getUserProfileData();

            // Header
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            const drewRec = drawLogo(doc, centerX - 12, y - 4, 24, { borderRadius: 12 });
            if (drewRec) { y += 26; }
            doc.text(profile.businessName, centerX, y, { align: 'center' });
            y += 18;

            doc.setFontSize(7);
            doc.setFont(undefined, 'normal');
            if (profile.address) {
                const addressLines = doc.splitTextToSize(profile.address, 186.77);
                addressLines.forEach(line => {
                    doc.text(line, centerX, y, { align: 'center' });
                    y += 10;
                });
            }
            if (profile.phone) {
                doc.text(`Tel: ${profile.phone}`, centerX, y, { align: 'center' });
                y += 10;
            }
            if (profile.email) {
                doc.text(`Email: ${profile.email}`, centerX, y, { align: 'center' });
                y += 10;
            }
            y += 8;

            doc.setLineWidth(0.5);
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Receipt Title
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text('PAYMENT RECEIPT', centerX, y, { align: 'center' });
            y += 18;

            // Receipt Details
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');
            doc.text(`Receipt No: ${receipt.number}`, margin, y);
            y += 11;
            doc.text(`Date: ${receipt.date}`, margin, y);
            y += 11;
            doc.text(`Time: ${receipt.time}`, margin, y);
            y += 16;

            doc.line(margin, y, 226.77 - margin, y);
            y += 13;

            // Received From
            doc.setFont(undefined, 'bold');
            doc.setFontSize(7);
            doc.text('RECEIVED FROM', margin, y);
            y += 11;
            doc.setFont(undefined, 'normal');
            doc.setFontSize(9);
            doc.text(receipt.customer, margin, y);
            if (receipt.customerEmail) {
                y += 11;
                doc.setFontSize(7);
                doc.text(receipt.customerEmail, margin, y);
            }
            y += 16;

            // Description
            doc.setFont(undefined, 'bold');
            doc.setFontSize(7);
            doc.text('DESCRIPTION', margin, y);
            y += 11;
            doc.setFont(undefined, 'normal');
            doc.setFontSize(8);
            const descLines = doc.splitTextToSize(receipt.description, 186.77);
            descLines.forEach(line => {
                if (y > 320) return; // Prevent overflow
                doc.text(line, margin, y);
                y += 10;
            });
            y += 8;

            doc.line(margin, y, 226.77 - margin, y);
            y += 13;

            // Amount
            doc.setFont(undefined, 'bold');
            doc.setFontSize(7);
            doc.text('AMOUNT PAID', margin, y);
            y += 14;
            doc.setFontSize(14);
            doc.text(`${formatNumber(receipt.amount)} Tsh`, centerX, y, { align: 'center' });
            y += 16;

            doc.setFontSize(7);
            doc.setFont(undefined, 'normal');
            const paymentLines = doc.splitTextToSize(`Payment Method: ${receipt.paymentMethod}`, 186.77);
            paymentLines.forEach(line => {
                doc.text(line, centerX, y, { align: 'center' });
                y += 10;
            });
            y += 10;

            // Linked Invoice
            if (receipt.linkedInvoice) {
                doc.setFontSize(7);
                doc.text(`Related Invoice: ${receipt.linkedInvoice}`, centerX, y, { align: 'center' });
                y += 12;
            }

            doc.line(margin, y, 226.77 - margin, y);
            y += 13;

            // Footer
            doc.setFont(undefined, 'bold');
            doc.setFontSize(8);
            doc.text('The Ultimate Business Architecture - TUBA', centerX, y, { align: 'center' });
            y += 11;
            doc.setFontSize(7);
            doc.setFont(undefined, 'normal');
            doc.text(`¬© ${new Date().getFullYear()}`, centerX, y, { align: 'center' });


            // Bottom zigzag
            const bottomY = 396.85 - 10;
            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, bottomY, x2, bottomY + 5);
                    doc.line(x2, bottomY + 5, x3, bottomY);
                } else {
                    doc.line(x1, bottomY, x2, bottomY - 5);
                    doc.line(x2, bottomY - 5, x3, bottomY);
                }
            }

            downloadPDFSafe(doc, `${receipt.number}.pdf`);
            showToast("Receipt PDF ready", "success");
        }
        function deleteReceipt(idx) {
            showConfirm("Delete this receipt?", async function () {
                const r = state.receipts[idx];
                if (r) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('receipts', { timestamp: r.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('receipts', { timestamp: r.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.receipts.splice(idx, 1);
                saveData();
                render();
                showToast("Receipt deleted", "success");

                if (syncEnabled) syncInBackground();
            });
        }
        function toggleSelectAllReceipts() {
            if (!state.selectedItems.receipts) state.selectedItems.receipts = {};

            const receipts = state.receipts || [];

            // Check if all receipts are currently selected
            const allSelected = receipts.every((receipt, idx) => state.selectedItems.receipts[idx]);

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            receipts.forEach((receipt, idx) => {
                state.selectedItems.receipts[idx] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectReceipt(index) {
            if (!state.selectedItems.receipts) state.selectedItems.receipts = {};
            state.selectedItems.receipts[index] = !state.selectedItems.receipts[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedReceipts() {
            return state.selectedItems.receipts && Object.values(state.selectedItems.receipts).some(v => v);
        }

        function getSelectedReceiptCount() {
            if (!state.selectedItems.receipts) return 0;
            return Object.values(state.selectedItems.receipts).filter(v => v).length;
        }

        function bulkDeleteReceipts() {
            const selected = Object.keys(state.selectedItems.receipts || {})
                .filter(i => state.selectedItems.receipts[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No receipts selected', 'info');

            showConfirm(`Delete ${selected.length} selected receipts?`, async function () {
                selected.sort((a, b) => b - a).forEach(i => {
                    const r = state.receipts[i];
                    if (syncEnabled && r) { try { deleteOne('receipts', { timestamp: r.timestamp }); } catch { } }
                    state.receipts.splice(i, 1);
                });

                state.selectedItems.receipts = {};
                saveData();
                render();
                showToast(`${selected.length} receipts deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function toggleInvoiceStatus(idx) {
            const inv = state.invoices[idx];
            if (!inv) return;

            const statuses = ['Pending', 'Paid', 'Overdue'];
            const currentIdx = statuses.indexOf(inv.status);
            inv.status = statuses[(currentIdx + 1) % statuses.length];

            saveData();
            render();
            showToast(`Invoice status changed to ${inv.status}`, 'success');

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        async function createInvoice(e) {
            e.preventDefault();
            const customerSelect = document.getElementById('invoiceCustomer').value;
            let customer;

            if (customerSelect === 'new') {
                const newName = document.getElementById('newInvoiceCustomerName')?.value.trim();
                if (!newName) return showToast('Please enter customer name', 'error');
                const newPhone = document.getElementById('newInvoiceCustomerPhone')?.value.trim();
                const newEmail = document.getElementById('newInvoiceCustomerEmail')?.value.trim();

                // Check if customer already exists
                const existingCustomer = state.customers.find(c => c.name.toLowerCase() === newName.toLowerCase());

                if (existingCustomer) {
                    customer = existingCustomer;
                } else {
                    customer = {
                        id: generateID('customers'),
                        name: newName,
                        email: newEmail,
                        phone: newPhone,
                        address: '',
                        totalPurchases: 0
                    };
                    state.customers.push(customer);
                    showToast('New customer added to customers list', 'info');
                }
            } else {
                customer = state.customers[customerSelect];
            }

            // Collect all items
            const itemRows = document.querySelectorAll('.invoice-item-row');
            const items = [];
            let subtotal = 0;

            itemRows.forEach(row => {
                const desc = row.querySelector('.item-description').value.trim();
                const amount = parseFloat(row.querySelector('.item-amount').value) || 0;

                if (desc && amount > 0) {
                    items.push({ description: desc, amount: amount });
                    subtotal += amount;
                }
            });

            if (items.length === 0) {
                return showToast('Please add at least one item with an amount', 'error');
            }

            const taxRate = parseFloat(document.getElementById('invoiceTaxRate')?.value || 0) / 100;
            const taxAmount = subtotal * taxRate;
            const total = subtotal + taxAmount;

            const now = new Date();
            const invoice = {
                id: generateID('invoices'),
                number: 'INV-' + Date.now().toString().slice(-6),
                customer: customer.name,
                customerEmail: customer.email || '',
                customerAddress: customer.address || '',
                customerPhone: customer.phone || '',
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                dueDate: document.getElementById('invoiceDueDate').value,
                Periods: document.getElementById('invoicePeriods')?.value.trim() || 'Due within 7 days',
                items: items,
                subtotal: subtotal,
                taxRate: taxRate * 100,
                taxAmount: taxAmount,
                amount: total,
                paymentMethod: document.getElementById('invoicePaymentMethod')?.value.trim() || 'Bank Transfer',
                notes: document.getElementById('invoiceNotes')?.value.trim() || '',
                status: 'Pending'
            };

            state.invoices.push(invoice);
            saveData();
            render();
            showToast("Invoice created successfully!", "success");
            if (syncEnabled) {
                await upsertOne('invoices', {
                    number: invoice.number,
                    customer: invoice.customer,
                    date: invoice.date,
                    due_date: invoice.dueDate,
                    items: invoice.items,
                    amount: invoice.amount,
                    status: invoice.status
                });
                syncInBackground();
            }
        }

        async function downloadInvoicePDF(i) {
            await ensureLogoReady();
            const inv = state.invoices[i];
            if (!inv) return showToast("Invoice not found", "error");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: 'a4' });
            const pageWidth = 595.28;
            const margin = 50;
            const usableWidth = pageWidth - margin * 2;
            let y = 50;

            const profile = getUserProfileData();

            // Header with gradient gray background
            doc.setFillColor(245, 245, 245);
            doc.rect(0, 0, pageWidth, 70, 'F');
            doc.setFillColor(230, 230, 230);
            doc.rect(0, 70, pageWidth, 70, 'F');

            // Company name + logo
            doc.setTextColor(40, 40, 40);
            doc.setFontSize(26);
            doc.setFont(undefined, 'bold');
            const drewInv = drawLogo(doc, margin, 20, 40, { borderRadius: 20 });
            const titleX = drewInv ? (margin + 58) : margin;
            doc.text(profile.businessName || 'Your Business Name', titleX, 45);

            // Company details - show all profile info
            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(80, 80, 80);
            let headerY = 70;

            if (profile.address) {
                doc.text(`Address: ${profile.address}`, margin, headerY);
                headerY += 14;
            }
            if (profile.phone) {
                doc.text(`Phone: ${profile.phone}`, margin, headerY);
                headerY += 14;
            }
            if (profile.email) {
                doc.text(`Email: ${profile.email}`, margin, headerY);
                headerY += 14;
            }

            // Add a subtle line separator
            doc.setDrawColor(150, 150, 150);
            doc.setLineWidth(2);
            doc.line(margin, headerY + 5, pageWidth - margin, headerY + 5);

            // Invoice details (right side)
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('INVOICE', pageWidth - margin, 45, { align: 'right' });

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`${inv.number}`, pageWidth - margin, 65, { align: 'right' });
            doc.text(`Date: ${inv.date}`, pageWidth - margin, 80, { align: 'right' });
            doc.text(`Due: ${inv.dueDate}`, pageWidth - margin, 95, { align: 'right' });

            y = 165;
            doc.setTextColor(0, 0, 0);

            // Bill To section
            doc.setFillColor(248, 248, 248);
            doc.roundedRect(margin, y, (usableWidth / 2) - 10, 100, 5, 5, 'F');

            doc.setFontSize(10);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(107, 114, 128);
            doc.text('BILL TO', margin + 15, y + 20);

            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(11);
            doc.text(inv.customer, margin + 15, y + 40);

            let billY = y + 55;
            if (inv.customerEmail) {
                doc.setFontSize(9);
                doc.setTextColor(107, 114, 128);
                doc.text(inv.customerEmail, margin + 15, billY);
                billY += 12;
            }
            if (inv.customerPhone) {
                doc.text(inv.customerPhone, margin + 15, billY);
                billY += 12;
            }
            if (inv.customerAddress) {
                doc.text(inv.customerAddress, margin + 15, billY);
            }

            // Payment Periods section
            doc.setFillColor(248, 248, 248);
            doc.roundedRect(margin + (usableWidth / 2) + 10, y, (usableWidth / 2) - 10, 80, 5, 5, 'F');

            doc.setFontSize(10);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(107, 114, 128);
            doc.text('PAYMENT PeriodS', margin + (usableWidth / 2) + 25, y + 20);

            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);
            doc.text(inv.Periods || 'Due within 7 days', margin + (usableWidth / 2) + 25, y + 40);

            doc.setFont(undefined, 'bold');
            doc.text('Payment Method', margin + (usableWidth / 2) + 25, y + 60);
            doc.setFont(undefined, 'normal');
            doc.text(inv.paymentMethod || 'Bank Transfer', margin + (usableWidth / 2) + 25, y + 75);

            y += 120;

            // Items table
            doc.setFillColor(100, 100, 100);
            doc.rect(margin, y, usableWidth, 25, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFont(undefined, 'bold');
            doc.setFontSize(10);
            doc.text('Item / Service', margin + 10, y + 16);
            doc.text('Amount', pageWidth - margin - 10, y + 16, { align: 'right' });

            y += 25;
            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);

            y += 25;
            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);

            // Parse items properly
            let items = [];
            if (Array.isArray(inv.items)) {
                items = inv.items;
            } else if (typeof inv.items === 'string') {
                try {
                    // Try to parse as JSON first
                    items = JSON.parse(inv.items);
                } catch (e) {
                    // If not JSON, split by comma
                    items = inv.items.split(',').map(s => ({ description: s.trim(), amount: 0 })).filter(i => i.description);
                }
            } else if (typeof inv.items === 'object') {
                items = [inv.items];
            }

            items.forEach((item, idx) => {
                if (idx % 2 === 0) {
                    doc.setFillColor(248, 249, 250);
                    doc.rect(margin, y, usableWidth, 20, 'F');
                }

                const description = item.description || String(item);
                const amount = item.amount || 0;

                doc.text(description, margin + 10, y + 14);
                if (amount > 0) {
                    doc.text(`${formatNumber(amount)} Tsh`, pageWidth - margin - 10, y + 14, { align: 'right' });
                }
                y += 20;
            });

            y += 10;

            // Totals section
            const totalsX = pageWidth - margin - 150;

            if (inv.subtotal !== undefined) {
                doc.setDrawColor(200, 200, 200);
                doc.line(totalsX - 20, y, pageWidth - margin, y);
                y += 15;

                doc.setFont(undefined, 'normal');
                doc.text('Subtotal:', totalsX, y);
                doc.text(`${formatNumber(inv.subtotal)} Tsh`, pageWidth - margin, y, { align: 'right' });
                y += 18;

                if (inv.taxAmount && inv.taxAmount > 0) {
                    doc.text(`Tax (${inv.taxRate}%):`, totalsX, y);
                    doc.text(`${formatNumber(inv.taxAmount)} Tsh`, pageWidth - margin, y, { align: 'right' });
                    y += 18;
                }
            }

            doc.setDrawColor(100, 100, 100);
            doc.setLineWidth(2);
            doc.line(totalsX - 20, y, pageWidth - margin, y);
            y += 18;

            doc.setFont(undefined, 'bold');
            doc.setFontSize(12);
            doc.text('Total Due:', totalsX, y);
            doc.text(`${formatNumber(inv.amount)} Tsh`, pageWidth - margin, y, { align: 'right' });

            // Notes
            if (inv.notes) {
                y += 40;
                doc.setFontSize(9);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(107, 114, 128);
                doc.text('Notes:', margin, y);
                y += 12;
                doc.setFont(undefined, 'normal');
                const noteLines = doc.splitTextToSize(inv.notes, usableWidth);
                noteLines.forEach(line => {
                    doc.text(line, margin, y);
                    y += 12;
                });
            }

            // Footer
            doc.setFillColor(80, 80, 80);
            doc.rect(0, 792 - 50, pageWidth, 50, 'F');
            doc.setFontSize(11);
            doc.setTextColor(255, 255, 255);
            doc.setFont(undefined, 'bold');
            doc.text('The Ultimate Business Architecture', pageWidth / 2, 792 - 28, { align: 'center' });
            doc.setFontSize(14);
            doc.text('- TUBA -', pageWidth / 2, 792 - 12, { align: 'center' });
            downloadPDFSafe(doc, `${inv.number}.pdf`);
            showToast("Invoice PDF ready", "success");
        }

        async function downloadSaleReceiptPDF(timestamp) {
            await ensureLogoReady();
            const sale = state.sales.find(s => s.timestamp === timestamp);
            if (!sale) return showToast("Sale not found", "error");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: [226.77, 396.85] }); // 80mm x 140mm receipt size
            const margin = 20;
            const contentWidth = 226.77 - (margin * 2);
            let y = 30;

            // Draw zigzag top border
            doc.setDrawColor(0, 0, 0);
            doc.setLineWidth(1);
            const zigzagSize = 8;
            const zigzagCount = Math.floor(226.77 / zigzagSize);

            // Top zigzag
            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, 10, x2, 5);
                    doc.line(x2, 5, x3, 10);
                } else {
                    doc.line(x1, 10, x2, 15);
                    doc.line(x2, 15, x3, 10);
                }
            }

            // Left border
            doc.line(10, 10, 10, 396.85 - 10);

            // Right border
            doc.line(226.77 - 10, 10, 226.77 - 10, 396.85 - 10);

            // Get profile data
            const profile = getUserProfileData();

            // Header - Logo + Business Name
            doc.setFontSize(16);
            doc.setFont(undefined, 'bold');
            const centerX = 226.77 / 2;
            const drewSaleRec = drawLogo(doc, centerX - 12, y - 4, 24, { borderRadius: 12 });
            if (drewSaleRec) { y += 26; }
            doc.text(profile.businessName || 'Your Business', centerX, y, { align: 'center' });
            y += 20;

            // Business Info
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');

            if (profile.address) {
                const addressLines = doc.splitTextToSize(profile.address, 186.77);
                addressLines.forEach(line => {
                    doc.text(line, centerX, y, { align: 'center' });
                    y += 10;
                });
            }

            if (profile.phone) {
                doc.text(`Tel: ${profile.phone}`, centerX, y, { align: 'center' });
                y += 10;
            }

            if (profile.email) {
                doc.text(`Email: ${profile.email}`, centerX, y, { align: 'center' });
                y += 10;
            }

            // Separator line
            y += 8;
            doc.setLineWidth(0.5);
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Receipt Title
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text('SALES RECEIPT', centerX, y, { align: 'center' });
            y += 18;

            // Date and Time
            doc.setFontSize(9);
            doc.setFont(undefined, 'normal');
            doc.text(`Date: ${sale.date}`, margin, y);
            y += 12;
            doc.text(`Time: ${sale.time}`, margin, y);
            y += 12;
            doc.text(`Customer: ${sale.customer}`, margin, y);
            y += 18;

            // Separator line
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Item Details Header
            doc.setFontSize(8);
            doc.setFont(undefined, 'bold');
            const pageWidth = 226.77;
            const priceX = pageWidth - margin; // Right aligned at content edge
            const qtyX = priceX - 60; // Leave 60pt gap from price
            doc.text('ITEM/DESCRIPTION', margin, y);
            doc.text('QTY', qtyX, y);
            doc.text('PRICE', priceX, y, { align: 'right' });
            y += 12;

            doc.setFont(undefined, 'normal');

            // Item Details
            doc.text(sale.productName, margin, y);
            y += 12;
            doc.text(`${sale.quantity}`, qtyX, y);
            doc.text(`${formatNumber(sale.pricePerUnit)}`, priceX, y, { align: 'right' });
            y += 18;

            // Separator line
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Totals
            doc.setFontSize(9);
            doc.text('Subtotal:', margin, y);
            doc.text(`${formatNumber(sale.totalPrice)} Tsh`, 160, y, { align: 'right' });
            y += 15;

            doc.setFont(undefined, 'bold');
            doc.setFontSize(11);
            doc.text('TOTAL:', margin, y);
            doc.text(`${formatNumber(sale.totalPrice)} Tsh`, 160, y, { align: 'right' });
            y += 18;

            // Payment Method
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');
            doc.text(`Payment: ${sale.payment}`, margin, y);
            y += 20;

            // Separator line
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Footer
            doc.setFontSize(8);
            doc.text('Thank you for your business!', centerX, y, { align: 'center' });
            y += 12;
            doc.text('Visit us again', centerX, y, { align: 'center' });
            y += 18;

            // Transaction ID
            doc.setFontSize(7);
            doc.text(`Trans ID: ${sale.id || timestamp}`, centerX, y, { align: 'center' });

            // Bottom zigzag
            const bottomY = 396.85 - 10;
            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, bottomY, x2, bottomY + 5);
                    doc.line(x2, bottomY + 5, x3, bottomY);
                } else {
                    doc.line(x1, bottomY, x2, bottomY - 5);
                    doc.line(x2, bottomY - 5, x3, bottomY);
                }
            }

            // Save the PDF
            downloadPDFSafe(doc, `Receipt_${sale.id || timestamp}.pdf`);
            showToast("Receipt PDF ready", "success");
        }

        function renderUnpaid() {
            const unpaidList = state.unpaidEntries.filter(e => !e.paid);
            const unpaidTotal = unpaidList.reduce((sum, e) => sum + (e.amount || 0), 0);

            return `
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-label">UNPAID ENTRIES</div>
                        <div class="stat-value">${unpaidList.length}</div>
                    </div>
                    <div class="stat-card" style="background: #d32f2f;">
                        <div class="stat-label">UNPAID AMOUNT</div>
                        <div class="stat-value">üí± ${formatNumber(unpaidTotal)} Tsh</div>
                    </div>
                </div>

                <div class="card">
                    <h2>Add Unpaid Entry</h2>
                    <form onsubmit="addUnpaidEntry(event)">
                        <div class="form-group">
                            <label>Customer</label>
                            <select id="unpaidCustomer">
                                <option value="">-- Select Customer --</option>
                                ${state.customers
                    .map((c, i) => ({ c, i }))
                    .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                    .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>OR Enter Customer Name</label>
                            <input type="text" id="unpaidName" placeholder="Enter name manually">
                        </div>
                        <div class="form-group">
                            <label>Product</label>
                            <select id="unpaidProduct" onchange="updateUnpaidAmount()">
                                <option value="">-- Select Product --</option>
                                ${state.products.map((p, i) => `<option value="${i}">${p.name} - üí± ${formatNumber(p.price)} Tsh</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>OR Transaction Type</label>
                            <input type="text" id="unpaidType" placeholder="e.g., Product Sale">
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="text" id="unpaidAmount" class="money-input" placeholder="0" required>
                        </div>
                        <button type="submit">Add Unpaid Entry</button>
                    </form>
                </div>

                <div class="card">
                    <h2>Unpaid Entries (${unpaidList.length})</h2>
                    
                    <div class="bulk-actions">
                        <input type="checkbox" id="selectAll_unpaidEntries" onchange="toggleSelectAll('unpaidEntries')" class="checkbox-select">
                        <label for="selectAll_unpaidEntries">Select All</label>
                        <span style="color: #666; font-size: 12px; margin-left: 8px;">
                            ${getSelectedCount('unpaidEntries')} selected
                        </span>
                        <button class="btn-small btn-success" onclick="bulkMarkPaid()" ${!hasSelected('unpaidEntries') ? 'disabled' : ''}>
                            ‚úì Mark Selected as Paid
                        </button>
                        <button class="btn-small btn-danger" onclick="bulkDelete('unpaidEntries')" ${!hasSelected('unpaidEntries') ? 'disabled' : ''}>
                            üóëÔ∏è Delete Selected
                        </button>
                    </div>

                    ${unpaidList.map((entry, idx) => `
                        <div class="item" style="border-left: 4px solid #d32f2f;">
                            <div style="display: flex; gap: 12px; align-items: start;">
                                <input type="checkbox" class="checkbox-select" 
                                       ${state.selectedItems.unpaidEntries && state.selectedItems.unpaidEntries[entry.id] ? 'checked' : ''}
                                       onchange="toggleSelect('unpaidEntries', '${entry.id}')">
                                <div style="flex: 1;">
                                    <div class="item-header">
                                        <span class="item-title">${entry.name}</span>
                                        <span class="badge badge-unpaid">UNPAID</span>
                                    </div>
                                    <div class="item-subtitle">
                                        ${entry.date} ${entry.time}<br>
                                        Type: ${entry.type}<br>
                                        Amount: <strong style="color: #d32f2f;">üí∞ ${formatNumber(entry.amount)} Tsh</strong>
                                    </div>
                                    <div class="flex-gap" style="margin-top:8px;">
                                        <button class="btn-success btn-small" onclick="markAsPaid(${entry.timestamp})">‚úì Mark Paid</button>
                                        <button class="btn-small btn-danger" onclick="deleteUnpaidEntry(${entry.timestamp})">Delete</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No unpaid entries</p>'}
                </div>

                <div class="card">
                    <h2>Paid Entries (Last 10)</h2>
                    ${state.unpaidEntries.filter(e => e.paid).slice().reverse().slice(0, 10).map(entry => `
                        <div class="item">
                            <div class="item-header">
                                <span class="item-title">${entry.name}</span>
                                <span class="badge badge-paid">‚úì PAID</span>
                            </div>
                            <div class="item-subtitle">
                                ${entry.date} ${entry.time}<br>
                                Type: ${entry.type}<br>
                                Amount: üí± ${formatNumber(entry.amount)} Tsh
                            </div>
                        </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No paid entries yet</p>'}
                </div>
            `;
        }

        function updateUnpaidAmount() {
            const productIndex = document.getElementById('unpaidProduct')?.value;
            if (productIndex !== null && productIndex !== '') {
                const product = state.products[productIndex];
                if (product) {
                    document.getElementById('unpaidAmount').value = formatMoney(product.price);
                }
            }
        }

        async function addUnpaidEntry(e) {
            e.preventDefault();
            const now = new Date();
            state.unpaidEntries = state.unpaidEntries || [];

            const customerIndex = document.getElementById('unpaidCustomer')?.value;
            const manualName = document.getElementById('unpaidName')?.value.trim();
            let customerName = manualName;
            if (!customerName && customerIndex) {
                customerName = state.customers[customerIndex].name;
            }
            if (!customerName) {
                return showToast("Please select or enter customer name", "error");
            }

            const productIndex = document.getElementById('unpaidProduct')?.value;
            const manualType = document.getElementById('unpaidType')?.value.trim();
            let transactionType = manualType;
            if (!transactionType && productIndex !== null && productIndex !== '') {
                transactionType = state.products[productIndex].name;
            }
            if (!transactionType) {
                return showToast("Please select product or enter transaction type", "error");
            }

            const amount = parseMoney(document.getElementById('unpaidAmount').value);
            if (isNaN(amount) || amount <= 0) {
                return showToast("Please enter a valid amount", "error");
            }

            const entry = {
                name: customerName,
                type: transactionType,
                amount: amount,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                paid: false
            };

            state.unpaidEntries.push(entry);
            saveData();
            render();
            showToast("Unpaid entry added", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        async function markAsPaid(timestamp) {
            const entry = state.unpaidEntries.find(e => e.timestamp === timestamp);
            if (!entry) return showToast("Entry not found", "error");

            entry.paid = true;
            const now = new Date();
            state.sales.push({
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                productName: entry.type,
                customer: entry.name,
                quantity: 1,
                costPerUnit: 0,
                pricePerUnit: entry.amount,
                totalCost: 0,
                totalPrice: entry.amount,
                profit: entry.amount,
                payment: 'Unpaid Entry - Now Paid'
            });

            // Update customer total
            const customer = state.customers.find(c => c.name === entry.name);
            if (customer) {
                customer.totalPurchases = (customer.totalPurchases || 0) + entry.amount;
            }

            saveData();
            render();
            showToast("Marked as paid and added to sales", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        function deleteUnpaidEntry(timestamp) {
            showConfirm("Delete this unpaid entry?", function () {
                const idx = state.unpaidEntries.findIndex(e => e.timestamp === timestamp);
                if (idx !== -1) {
                    const entry = state.unpaidEntries[idx];
                    if (entry) {
                        (async () => {
                            try {
                                if (navigator.onLine && syncEnabled && currentUser) {
                                    await deleteOne('unpaid_entries', { timestamp: entry.timestamp });
                                    showToast('Deleted from cloud', 'success');
                                } else {
                                    await deleteOne('unpaid_entries', { timestamp: entry.timestamp });
                                    showToast('Will delete from cloud when online', 'info');
                                }
                            } catch { }
                        })();
                    }
                    state.unpaidEntries.splice(idx, 1);
                    saveData();
                    render();
                    showToast("Entry deleted", "success");
                }
            });
        }

        function renderNotes() {
            return `
                <div class="card">
                    <h2>Add Note</h2>
                    <form onsubmit="addNote(event)">
                        <div class="form-group">
                            <label>Note Title (Optional)</label>
                            <input type="text" id="noteTitle" placeholder="Brief title...">
                        </div>
                        <div class="form-group">
                            <textarea id="noteContent" placeholder="Write your note here..." required></textarea>
                        </div>
                        <button type="submit">Save Note</button>
                    </form>
                </div>

                <div class="card">
                    <h2>All Notes (${state.notes.length})</h2>
                    <div class="search-box">
                        <input type="text" placeholder="üîç Search notes..." oninput="searchNotes(this.value)" id="noteSearch">
                    </div>
                    <div id="notesList">
                        ${renderNotesList()}
                    </div>
                </div>
            `;
        }

        function renderNotesList(searchPeriod = '') {
            let notes = state.notes.slice().reverse();

            if (searchPeriod) {
                const Period = searchPeriod.toLowerCase();
                notes = notes.filter(n =>
                    n.content.toLowerCase().includes(Period) ||
                    (n.title && n.title.toLowerCase().includes(Period))
                );
            }

            if (notes.length === 0) {
                return '<p style="text-align: center; color: #666;">No notes found</p>';
            }

            return notes.map((note, idx) => {
                const actualIndex = state.notes.length - 1 - idx;
                const isEditing = state.editingNoteIndex === actualIndex;

                if (isEditing) {
                    return `
                <div class="item">
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Title (Optional)</label>
                        <input type="text" id="editNoteTitle_${actualIndex}" 
                               value="${(note.title || '').replace(/"/g, '&quot;')}" 
                               placeholder="Note title..."
                               style="width: 100%; padding: 10px; border: 2px solid #667eea; border-radius: 8px;">
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Content</label>
                        <textarea id="editNoteContent_${actualIndex}" 
                                  style="width: 100%; min-height: 150px; padding: 10px; border: 2px solid #667eea; border-radius: 8px;"
                                  placeholder="Write your note here...">${note.content}</textarea>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn-success btn-small" onclick="saveNoteEdit(${actualIndex})">üíæ Save</button>
                        <button class="btn-secondary btn-small" onclick="cancelNoteEdit()">‚úñ Cancel</button>
                    </div>
                </div>
            `;
                }

                return `
            <div class="item">
                <div class="note-preview" onclick="openNoteModal(${actualIndex})" style="cursor: pointer;">
                    ${note.title ? `<div class="item-title" style="margin-bottom: 8px;">${note.title}</div>` : ''}
                    <div class="item-subtitle" style="margin-bottom: 8px;">${note.date} ${note.time}</div>
                    <div style="white-space: pre-wrap;">${note.content}</div>
                </div>
                <div style="display: flex; gap: 6px; margin-top: 8px;">
                    <button class="btn-small" onclick="startEditingNote(${actualIndex})">‚úèÔ∏è Edit</button>
                    <button class="btn-small btn-danger" onclick="deleteNoteByIndex(${actualIndex})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `;
            }).join('');
        }

        function startEditingNote(index) {
            state.editingNoteIndex = index;
            saveData();
            render();
        }

        function cancelNoteEdit() {
            state.editingNoteIndex = null;
            saveData();
            render();
        }

        async function saveNoteEdit(index) {
            const titleInput = document.getElementById(`editNoteTitle_${index}`);
            const contentInput = document.getElementById(`editNoteContent_${index}`);

            if (!contentInput || !contentInput.value.trim()) {
                return showToast('Note content cannot be empty', 'error');
            }

            state.notes[index].title = titleInput ? titleInput.value.trim() : '';
            state.notes[index].content = contentInput.value.trim();
            state.editingNoteIndex = null;

            saveData();
            render();
            showToast('Note updated successfully', 'success');
            if (syncEnabled) {
                const n = state.notes[index];
                await upsertOne('notes', {
                    title: n.title || '',
                    content: n.content,
                    date: n.date,
                    time: n.time,
                    timestamp: n.timestamp
                });
                syncInBackground();
            }
        }

        function searchNotes(Period) {
            document.getElementById('notesList').innerHTML = renderNotesList(Period);
        }

        async function addNote(e) {
            e.preventDefault();
            const now = new Date();
            const content = document.getElementById('noteContent').value.trim();
            const title = document.getElementById('noteTitle')?.value.trim();

            if (!content) {
                return showToast('Please enter note content', 'error');
            }

            const note = {
                title: title || '',
                content: content,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime()
            };

            state.notes.push(note);
            saveData();
            render();
            showToast("Note saved", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        function openNoteModal(index) {
            state.currentNoteIndex = index;
            const note = state.notes[index];
            const modal = document.getElementById('noteModal');
            const content = document.getElementById('noteModalContent');
            content.innerHTML = `
                ${note.title ? `<h3 style="margin-bottom: 12px; color: #1a1a1a;">${note.title}</h3>` : ''}
                <div style="margin-bottom: 12px; color: #666; font-size: 13px;">${note.date} ${note.time}</div>
                <div style="white-space: pre-wrap; line-height: 1.6;">${note.content}</div>
            `;
            modal.classList.add('show');
        }

        function closeNoteModal() {
            document.getElementById('noteModal').classList.remove('show');
            state.currentNoteIndex = null;
        }

        function editNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            const note = state.notes[state.currentNoteIndex];
            const newTitle = prompt("Edit title:", note.title);
            const newContent = prompt("Edit note:", note.content);
            if (newContent !== null && newContent.trim()) {
                if (newTitle !== null) note.title = newTitle.trim();
                note.content = newContent.trim();
                saveData();
                closeNoteModal();
                render();
                showToast("Note updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            showConfirm("Delete this note?", async function () {
                const note = state.notes[state.currentNoteIndex];
                if (note) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.notes.splice(state.currentNoteIndex, 1);
                saveData();
                closeNoteModal();
                render();
                showToast("Note deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        // Offline info modal control
        function openOfflineInfoModal() {
            const modal = document.getElementById('offlineInfoModal');
            if (!modal) return;
            modal.classList.add('show');
            const handleOutside = (e) => {
                if (e.target === modal) {
                    closeOfflineInfoModal();
                }
            };
            modal.addEventListener('click', handleOutside, { once: true });
        }

        function closeOfflineInfoModal() {
            const modal = document.getElementById('offlineInfoModal');
            if (modal) modal.classList.remove('show');
        }

        function deleteNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            showConfirm("Delete this note?", async function () {
                const note = state.notes[state.currentNoteIndex];
                if (note) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.notes.splice(state.currentNoteIndex, 1);
                saveData();
                closeNoteModal();
                render();
                showToast("Note deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }


        function deleteNoteByIndex(index) {
            showConfirm("Delete this note?", async function () {
                const note = state.notes[index];
                if (note) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.notes.splice(index, 1);
                saveData();
                render();
                showToast("Note deleted", "success");

                if (syncEnabled) syncInBackground();
            });
        }

        function togglePrivacy() {
            state.privacyBlurred = !state.privacyBlurred;
            saveData();
            render();
        }

        function renderAnalytics() {
            const stats = getStats();
            const netProfit = stats.netProfit;

            return `
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
    <div class="stat-card" style="padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">REVENUE</div>
        <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalRevenue)} Tsh</div>
    </div>
    <div class="stat-card" style="padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">EXPENSES</div>
        <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalExpenses)} Tsh</div>
    </div>
    <div class="stat-card" style="background: ${netProfit >= 0 ? '#2e7d32' : '#d32f2f'}; padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">NET PROFIT</div>
        <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(netProfit)} Tsh</div>
    </div>
    <div class="stat-card" style="background: #1976d2; padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">TOTAL SALES</div>
        <div class="stat-value" style="font-size: 16px;">${stats.totalSalesCount}</div>
    </div>
</div>

    <div class="card">
        <h2>Download Reports</h2>
        <button onclick="downloadDailyReportPDF()">üì• DAILY REPORT (PDF)</button>
        <button style="margin-top:8px;" onclick="downloadSalesReportPDF()">üì• Download Report (PDF)</button>
        <button class="btn-secondary" style="margin-top:8px;" onclick="downloadSalesReportExcel()">üì• Download Report (Excel)</button>
        <button class="btn-secondary" style="margin-top:8px;" onclick="downloadBackup()">üíæ Backup All Data</button>
    </div>

    <div class="card">
        <h2>Payment Methods</h2>
        ${getPaymentMethodsHTML()}
    </div>

    <div class="card">
        <h2>Money Transactions Summary</h2>
        ${getTransactionSummaryHTML()}
    </div>

    <div class="card">
        <h2>Category Performance</h2>
        ${getCategoryPerformanceHTML()}
    </div>

    <div class="card">
        <h2>Top Products by Profit</h2>
        ${getTopProductsHTML()}
    </div>

    <div class="card">
        <h2>Analytics Chart</h2>
        <canvas id="analyticsChart"></canvas>
    </div>
`;
        }

        function getCategoryPerformanceHTML() {
            const categoryStats = {};
            state.sales.forEach(s => {
                const product = state.products.find(p => p.name === s.productName);
                if (product) {
                    if (!categoryStats[product.category]) {
                        categoryStats[product.category] = { profit: 0, revenue: 0, count: 0 };
                    }
                    categoryStats[product.category].profit += s.profit;
                    categoryStats[product.category].revenue += s.totalPrice;
                    categoryStats[product.category].count += 1;
                }
            });

            const entries = Object.entries(categoryStats)
                .sort((a, b) => b[1].profit - a[1].profit)
                .slice(0, 2);

            if (entries.length === 0) {
                return '<p style="text-align: center; color: #666;">No category data yet</p>';
            }

            return entries.map(([category, data]) => `
                <div class="item">
                    <div class="item-header">
                        <span class="item-title">${category}</span>
                        <span style="color: #2e7d32; font-weight: 700;">üí± ${formatNumber(data.profit)} Tsh</span>
                    </div>
                    <div class="item-subtitle">
                        Revenue: ${formatNumber(data.revenue)} Tsh | ${data.count} sales
                    </div>
                </div>
            `).join('');
        }

        function getTopProductsHTML() {
            const productStats = {};
            state.sales.forEach(s => {
                if (!productStats[s.productName]) {
                    productStats[s.productName] = { profit: 0, quantity: 0, revenue: 0 };
                }
                productStats[s.productName].profit += s.profit;
                productStats[s.productName].quantity += s.quantity;
                productStats[s.productName].revenue += s.totalPrice;
            });

            const entries = Object.entries(productStats)
                .sort((a, b) => b[1].profit - a[1].profit)
                .slice(0, 2);

            if (entries.length === 0) {
                return '<p style="text-align: center; color: #666;">No product data yet</p>';
            }

            return entries.map(([product, data], index) => `
                <div class="item">
                    <div class="item-header">
                        <span class="item-title">${index + 1}. ${product}</span>
                        <span style="color: #2e7d32; font-weight: 700;">üí± ${formatNumber(data.profit)} Tsh</span>
                    </div>
                    <div class="item-subtitle">
                        Sold: ${data.quantity} units | Revenue: ${formatNumber(data.revenue)} Tsh
                    </div>
                </div>
            `).join('');
        }

        function getPaymentMethodsHTML() {
            const paymentTotals = {};
            state.sales.forEach(s => {
                paymentTotals[s.payment] = (paymentTotals[s.payment] || 0) + s.totalPrice;
            });
            if (Object.keys(paymentTotals).length === 0) {
                return '<p style="text-align: center; color: #666;">No payment data yet</p>';
            }

            const entries = Object.entries(paymentTotals)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2);
            return entries.map(([method, total]) => `
                <div class="item">
                    <div style="display: flex; justify-content: space-between;">
                        <span class="item-title">${method}</span>
                        <span style="font-weight: 700;">üí± ${formatNumber(total)} Tsh</span>
                    </div>
                </div>
            `).join('');
        }

        function getTransactionSummaryHTML() {
            const transactionTotals = {
                mpesa: { deposit: 0, withdrawal: 0 },
                crdb: { deposit: 0, withdrawal: 0 },
                nmb: { deposit: 0, withdrawal: 0 },
                airtel: { deposit: 0, withdrawal: 0 },
                halopesa: { deposit: 0, withdrawal: 0 },
                yas: { deposit: 0, withdrawal: 0 }
            };

            (state.transactions || []).forEach(t => {
                if (transactionTotals[t.channel]) {
                    transactionTotals[t.channel][t.type] += t.amount || 0;
                }
            });

            const channelLabels = {
                mpesa: 'M-Pesa',
                crdb: 'CRDB',
                nmb: 'NMB',
                airtel: 'Airtel Money',
                halopesa: 'Halopesa',
                yas: 'Yas Tanzania'
            };

            const channelColors = {
                mpesa: '#d32f2f',
                crdb: '#2e7d32',
                nmb: '#e65100',
                airtel: '#b71c1c',
                halopesa: '#fdd835',
                yas: '#0d47a1'
            };

            const hasTransactions = Object.values(transactionTotals).some(val => val.deposit > 0 || val.withdrawal > 0);

            if (!hasTransactions) {
                return '<p style="text-align: center; color: #666;">No transaction data yet</p>';
            }

            const entries = Object.entries(transactionTotals)
                .filter(([channel, amounts]) => amounts.deposit > 0 || amounts.withdrawal > 0)
                .map(([channel, amounts]) => ([channel, amounts, (amounts.deposit + amounts.withdrawal)]))
                .sort((a, b) => b[2] - a[2])
                .slice(0, 2);

            return entries.map(([channel, amounts]) => `
                <div class="item">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <span style="width: 12px; height: 12px; border-radius: 50%; background: ${channelColors[channel]};"></span>
                        <span class="item-title">${channelLabels[channel]}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 13px; color: #666;">
                        <span>Deposits: <strong style="color: #2e7d32;">üí± ${formatNumber(amounts.deposit)} Tsh</strong></span>
                        <span>Withdrawals: <strong style="color: #d32f2f;">üí± ${formatNumber(amounts.withdrawal)} Tsh</strong></span>
                    </div>
                    <div style="margin-top: 4px; font-weight: 600;">
                        Net: <span style="color: ${amounts.deposit - amounts.withdrawal >= 0 ? '#2e7d32' : '#d32f2f'};">
                            ${amounts.deposit - amounts.withdrawal >= 0 ? '+' : ''}üí± ${formatNumber(amounts.deposit - amounts.withdrawal)} Tsh
                        </span>
                    </div>
                </div>
            `).join('');
        }

        function createAnalyticsChart() {
            setTimeout(() => {
                const canvas = document.getElementById('analyticsChart');
                if (!canvas) return;

                if (chartInstance) {
                    chartInstance.destroy();
                }

                const stats = getStats();
                const revenue = stats.totalRevenue;
                const expenses = stats.totalExpenses;
                const profit = stats.totalProfit;

                const transactionTotals = {
                    mpesa: 0, crdb: 0, nmb: 0, airtel: 0, halopesa: 0, yas: 0
                };
                (state.transactions || []).forEach(t => {
                    if (transactionTotals.hasOwnProperty(t.channel)) {
                        transactionTotals[t.channel] += t.amount || 0;
                    }
                });

                const ctx = canvas.getContext('2d');
                chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Revenue', 'Expenses', 'Profit', 'M-Pesa', 'CRDB', 'NMB', 'Airtel', 'Halopesa', 'Yas'],
                        datasets: [{
                            label: 'Amount (Tsh)',
                            data: [
                                revenue,
                                expenses,
                                profit,
                                transactionTotals.mpesa,
                                transactionTotals.crdb,
                                transactionTotals.nmb,
                                transactionTotals.airtel,
                                transactionTotals.halopesa,
                                transactionTotals.yas
                            ],
                            backgroundColor: [
                                '#1976d2',
                                '#d32f2f',
                                '#2e7d32',
                                '#d32f2f',
                                '#2e7d32',
                                '#e65100',
                                '#b71c1c',
                                '#fdd835',
                                '#0d47a1'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }, 100);
        }
        async function downloadSalesReportPDF() {
            await ensureLogoReady();
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: 'a4' });
            const pageWidth = 595.28;
            const margin = 50;
            const usableWidth = pageWidth - margin * 2;
            let y = 50;

            // Header
            doc.setFillColor(26, 26, 26);
            doc.rect(0, 0, pageWidth, 100, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFontSize(24);
            doc.setFont(undefined, 'bold');
            const profile = getUserProfileData();
            const drew = drawLogo(doc, margin, 20, 36, { borderRadius: 18 });
            const titleX = drew ? (margin + 52) : margin;
            doc.text(profile.businessName, titleX, 45);

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`${profile.address} | ${profile.phone} | ${profile.email}`, margin, 70);

            doc.setDrawColor(102, 126, 234);
            doc.setLineWidth(3);
            doc.line(margin, 85, pageWidth - margin, 85);

            y = 120;
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(18);
            doc.setFont(undefined, 'bold');
            doc.text("Financial Report", margin, y);

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(100, 100, 100);
            doc.text(`Generated: ${getTodayDateString()}`, margin, y + 20);
            y += 50;

            function drawTable(headers, rows, startY) {
                const colCount = headers.length;
                const colWidth = usableWidth / colCount;
                let curY = startY;
                const rowHeight = 22;

                doc.setFillColor(102, 126, 234);
                doc.roundedRect(margin, curY, usableWidth, rowHeight, 3, 3, 'F');

                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                for (let i = 0; i < colCount; i++) {
                    const txtX = margin + i * colWidth + 8;
                    doc.text(String(headers[i]), txtX, curY + 15);
                }
                curY += rowHeight + 2;

                doc.setFont(undefined, 'normal');
                doc.setFontSize(9);
                for (let r = 0; r < rows.length; r++) {
                    if (curY + rowHeight > 750) {
                        doc.addPage();
                        curY = margin;
                    }

                    if (r % 2 === 0) {
                        doc.setFillColor(248, 249, 250);
                        doc.roundedRect(margin, curY, usableWidth, rowHeight, 2, 2, 'F');
                    }

                    doc.setTextColor(40, 40, 40);
                    for (let c = 0; c < colCount; c++) {
                        const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                        const txtX = margin + c * colWidth + 8;
                        doc.text(txt, txtX, curY + 15, { maxWidth: colWidth - 16 });
                    }
                    curY += rowHeight;
                }
                return curY + 20;
            }

            // Sales
            const salesHeaders = ["Date", "Product", "Customer", "Qty", "Price", "Profit"];
            const salesRows = (state.sales || []).map(s => [
                s.date, s.productName, s.customer, s.quantity, formatNumber(s.totalPrice) + ' Tsh', formatNumber(s.profit) + ' Tsh'
            ]);
            if (salesRows.length > 0) {
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text("Sales Records", margin, y);
                y += 15;
                y = drawTable(salesHeaders, salesRows, y);
                const totalQty = (state.sales || []).reduce((sum, s) => sum + (s.quantity || 0), 0);
                const totalPrice = (state.sales || []).reduce((sum, s) => sum + (s.totalPrice || 0), 0);
                const totalProfit = (state.sales || []).reduce((sum, s) => sum + (s.profit || 0), 0);
                const colCount = salesHeaders.length;
                const colWidth = usableWidth / colCount;
                const rowHeight = 22;
                if (y + rowHeight > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeight, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Totals', margin + 2 * colWidth + 8, y + 15);
                doc.text(String(totalQty), margin + 3 * colWidth + 8, y + 15);
                doc.text(formatNumber(totalProfit) + ' Tsh', margin + 5 * colWidth + 8, y + 15);
                y += rowHeight + 20;
            }

            // Expenses
            const expHeaders = ["Date", "Description", "Category", "Amount"];
            const expRows = (state.expenses || []).map(e => [
                e.date, e.description, e.category, formatNumber(e.amount || 0) + ' Tsh'
            ]);
            if (expRows.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Expenses", margin, y);
                y += 15;
                y = drawTable(expHeaders, expRows, y);
                const totalExp = (state.expenses || []).reduce((sum, e) => sum + (e.amount || 0), 0);
                const colCountE = expHeaders.length;
                const colWidthE = usableWidth / colCountE;
                const rowHeightE = 22;
                if (y + rowHeightE > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeightE, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Total', margin + 2 * colWidthE + 8, y + 15);
                doc.text(formatNumber(totalExp) + ' Tsh', margin + 3 * colWidthE + 8, y + 15);
                y += rowHeightE + 20;
            }

            // Transactions
            const transHeaders = ["Type", "Date", "Customer", "Amount"];
            const transRows = (state.transactions || []).map(t => [
                t.channel.toUpperCase(), t.date, t.customerName || 'N/A', formatNumber(t.amount || 0) + ' Tsh'
            ]);
            if (transRows.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Money Transactions", margin, y);
                y += 15;
                y = drawTable(transHeaders, transRows, y);
            }

            // Chart
            if (chartInstance) {
                doc.addPage();
                doc.setFontSize(16);
                doc.setFont(undefined, 'bold');
                doc.text("Analytics Overview", margin, 50);

                const chartImage = chartInstance.toBase64Image();
                doc.addImage(chartImage, 'PNG', margin, 70, usableWidth, 250);
            }

            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFillColor(240, 240, 240);
                doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                doc.setTextColor(100, 100, 100);
                doc.setFontSize(9);
                doc.text(`Page ${i} of ${pageCount}`, margin, 792 - 11);
                doc.text(`The Ultimate Business Achitecture (TUBA) ¬© ${new Date().getFullYear()}`, pageWidth - margin, 792 - 8, { align: 'right' });
            }

            downloadPDFSafe(doc, `Financial_Report_${getTodayDateString()}.pdf`);
            showToast("PDF ready", "success");
        }

        async function downloadDailyReportPDF() {
            await ensureLogoReady();
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: 'a4' });
            const pageWidth = 595.28;
            const margin = 50;
            const usableWidth = pageWidth - margin * 2;
            let y = 50;

            const today = getTodayDateString();
            const todaySales = state.sales.filter(s => s.date === today);
            const todayExpenses = state.expenses.filter(e => e.date === today);
            const todayTransactions = state.transactions.filter(t => t.date === today);

            // Calculate today's stats
            const todayRevenue = todaySales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);
            const todayProfit = todaySales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const todayExpenseTotal = todayExpenses.reduce((sum, e) => sum + (e.amount || 0), 0);
            const todayNetProfit = todayProfit - todayExpenseTotal;

            // Header
            doc.setFillColor(26, 26, 26);
            doc.rect(0, 0, pageWidth, 100, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFontSize(24);
            doc.setFont(undefined, 'bold');

            const profile = getUserProfileData();
            const drewDaily = drawLogo(doc, margin, 20, 36, { borderRadius: 18 });
            const nameX = drewDaily ? (margin + 52) : margin;
            doc.text(profile.businessName, nameX, 45);

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`${profile.address} | ${profile.phone} | ${profile.email}`, margin, 70);

            doc.setDrawColor(102, 126, 234);
            doc.setLineWidth(3);
            doc.line(margin, 85, pageWidth - margin, 85);

            y = 120;
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(18);
            doc.setFont(undefined, 'bold');
            doc.text("Daily Report", margin, y);

            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(100, 100, 100);
            doc.text(`Date: ${today}`, margin, y + 20);
            y += 50;

            // Summary Box
            doc.setFillColor(240, 248, 255);
            doc.roundedRect(margin, y, usableWidth, 100, 5, 5, 'F');
            doc.setDrawColor(102, 126, 234);
            doc.setLineWidth(2);
            doc.roundedRect(margin, y, usableWidth, 100, 5, 5, 'S');

            doc.setTextColor(0, 0, 0);
            doc.setFontSize(11);
            doc.setFont(undefined, 'bold');
            doc.text("TODAY'S SUMMARY", margin + 15, y + 20);

            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);
            doc.text(`Total Sales: ${todaySales.length}`, margin + 15, y + 40);
            doc.text(`Revenue: ${formatNumber(todayRevenue)} Tsh`, margin + 15, y + 55);
            doc.text(`Profit: ${formatNumber(todayProfit)} Tsh`, margin + 15, y + 70);
            doc.text(`Expenses: ${formatNumber(todayExpenseTotal)} Tsh`, margin + 200, y + 40);
            doc.text(`Net Profit: ${formatNumber(todayNetProfit)} Tsh`, margin + 200, y + 55);

            const netColor = todayNetProfit >= 0 ? [46, 125, 50] : [211, 47, 47];
            doc.setTextColor(...netColor);
            doc.setFont(undefined, 'bold');
            doc.text(`Status: ${todayNetProfit >= 0 ? 'Profitable ‚úì' : 'Loss ‚úó'}`, margin + 200, y + 70);

            y += 120;

            function drawTable(headers, rows, startY) {
                const colCount = headers.length;
                const colWidth = usableWidth / colCount;
                let curY = startY;
                const rowHeight = 22;

                doc.setFillColor(102, 126, 234);
                doc.roundedRect(margin, curY, usableWidth, rowHeight, 3, 3, 'F');

                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                for (let i = 0; i < colCount; i++) {
                    const txtX = margin + i * colWidth + 8;
                    doc.text(String(headers[i]), txtX, curY + 15);
                }
                curY += rowHeight + 2;

                doc.setFont(undefined, 'normal');
                doc.setFontSize(9);
                for (let r = 0; r < rows.length; r++) {
                    if (curY + rowHeight > 750) {
                        doc.addPage();
                        curY = margin;
                    }

                    if (r % 2 === 0) {
                        doc.setFillColor(248, 249, 250);
                        doc.roundedRect(margin, curY, usableWidth, rowHeight, 2, 2, 'F');
                    }

                    doc.setTextColor(40, 40, 40);
                    for (let c = 0; c < colCount; c++) {
                        const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                        const txtX = margin + c * colWidth + 8;
                        doc.text(txt, txtX, curY + 15, { maxWidth: colWidth - 16 });
                    }
                    curY += rowHeight;
                }
                return curY + 20;
            }

            // Today's Sales
            if (todaySales.length > 0) {
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text("Today's Sales", margin, y);
                y += 15;
                const salesHeaders = ["Time", "Product", "Customer", "Qty", "Price", "Profit"];
                const salesRows = todaySales.map(s => [
                    s.time, s.productName, s.customer, s.quantity,
                    formatNumber(s.totalPrice) + ' Tsh', formatNumber(s.profit) + ' Tsh'
                ]);
                y = drawTable(salesHeaders, salesRows, y);
                const totalQty = todaySales.reduce((sum, s) => sum + (s.quantity || 0), 0);
                const totalPrice = todaySales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);
                const totalProfit = todaySales.reduce((sum, s) => sum + (s.profit || 0), 0);
                const colCount = salesHeaders.length;
                const colWidth = usableWidth / colCount;
                const rowHeight = 22;
                if (y + rowHeight > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeight, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Totals', margin + 2 * colWidth + 8, y + 15);
                doc.text(String(totalQty), margin + 3 * colWidth + 8, y + 15);
                doc.text(formatNumber(totalProfit) + ' Tsh', margin + 5 * colWidth + 8, y + 15);
                y += rowHeight + 20;
            }

            // Today's Expenses
            if (todayExpenses.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Today's Expenses", margin, y);
                y += 15;
                const expHeaders = ["Time", "Description", "Category", "Amount"];
                const expRows = todayExpenses.map(e => [
                    e.time, e.description, e.category, formatNumber(e.amount || 0) + ' Tsh'
                ]);
                y = drawTable(expHeaders, expRows, y);
                const totalExp = todayExpenses.reduce((sum, e) => sum + (e.amount || 0), 0);
                const colCountE = expHeaders.length;
                const colWidthE = usableWidth / colCountE;
                const rowHeightE = 22;
                if (y + rowHeightE > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeightE, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Total', margin + 2 * colWidthE + 8, y + 15);
                doc.text(formatNumber(totalExp) + ' Tsh', margin + 3 * colWidthE + 8, y + 15);
                y += rowHeightE + 20;
            }

            // Today's Transactions
            if (todayTransactions.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Today's Transactions", margin, y);
                y += 15;
                const transHeaders = ["Type", "Time", "Customer", "Amount"];
                const transRows = todayTransactions.map(t => [
                    t.channel.toUpperCase(), t.time, t.customerName || 'N/A',
                    formatNumber(t.amount || 0) + ' Tsh'
                ]);
                y = drawTable(transHeaders, transRows, y);
            }

            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFillColor(240, 240, 240);
                doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                doc.setTextColor(100, 100, 100);
                doc.setFontSize(9);
                doc.text(`Page ${i} of ${pageCount}`, margin, 792 - 12);
                doc.text(`The Ultimate Business Achitecture (TUBA) ¬© ${new Date().getFullYear()}`, pageWidth - margin, 792 - 8, { align: 'right' });
            }

            downloadPDFSafe(doc, `Daily_Report_${today}.pdf`);
            showToast("Daily report PDF ready", "success");
        }

        function downloadSalesReportExcel() {
            const rows = [
                ["TUBA - The Ultimate Business Architecture"],
                ["Financial Report"],
                [`Generated: ${getTodayDateString()}`],
                [],
                ["SALES RECORDS"],
                ["Date", "Product", "Customer", "Quantity", "Price (Tsh)", "Profit (Tsh)"],
                ...((state.sales || []).map(s => [s.date, s.productName, s.customer, s.quantity, s.totalPrice, s.profit])),
                [],
                ["EXPENSES"],
                ["Date", "Description", "Category", "Amount (Tsh)"],
                ...((state.expenses || []).map(e => [e.date, e.description, e.category, e.amount])),
                [],
                ["MONEY TRANSACTIONS"],
                ["Type", "Date", "Customer", "Amount (Tsh)"],
                ...((state.transactions || []).map(t => [t.channel.toUpperCase(), t.date, t.customerName || 'N/A', t.amount]))
            ];

            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(rows);

            ws['!cols'] = [
                { wch: 15 }, { wch: 20 }, { wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws, "Financial Report");
            XLSX.writeFile(wb, `Financial_Report_${getTodayDateString()}.xlsx`);
            showToast("Excel downloaded successfully!", "success");
        }

        function downloadBackup() {
            exportData();
        }


        function openCleanupModal() {
            if (!currentUser) {
                showToast('You must be signed in to clean duplicates.', 'info');
                return;
            }
            document.getElementById('cleanupModal').classList.add('show');
        }

        function closeCleanupModal() {
            document.getElementById('cleanupModal').classList.remove('show');
        }

        async function confirmCleanup() {
            closeCleanupModal();
            await cleanDuplicatesInSupabase();
        }

        async function cleanDuplicatesInSupabase() {
            if (!supabase || !currentUser) {
                showToast('You must be signed in before cleaning.', 'error');
                return;
            }

            showToast('üßπ Starting cleanup...', 'info');
            updateSyncIndicator('syncing');

            // Delegate to comprehensive cleaner (content-based + clear-and-push)
            try {
                const result = await cleanAllDuplicates();
                updateSyncIndicator('synced');
                showToast(`‚úÖ Removed ${result.totalRemoved} duplicates!`, 'success');
            } catch (e) {
                console.error('Cleanup error:', e);
                updateSyncIndicator('synced');
                showToast('‚ùå Cleanup failed', 'error');
            }
        }

        function exportData(customMessage = null, customDurationMs = null) {
            const data = {
                products: state.products,
                sales: state.sales,
                expenses: state.expenses,
                customers: state.customers,
                invoices: state.invoices,
                receipts: state.receipts || [],
                categories: state.categories,
                inventory: state.inventory,
                notes: state.notes,
                transactions: state.transactions,
                unpaidEntries: state.unpaidEntries,
                transactionFloats: state.transactionFloats,
                dailyTarget: state.dailyTarget,
                monthlyTarget: state.monthlyTarget,
                exportDate: new Date().toISOString(),
                version: '2.0'
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `TUBA_finance_backup_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast(customMessage || 'Data exported successfully!', 'success', null, null, customDurationMs || 3000);
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (confirm('Import will MERGE with existing data (no overwrite). Continue?')) {
                            // Merge arrays and deduplicate
                            state.products = deduplicateByContent([...(state.products || []), ...(data.products || [])], 'products');
                            state.sales = deduplicateByContent([...(state.sales || []), ...(data.sales || [])], 'sales');
                            state.expenses = deduplicateByContent([...(state.expenses || []), ...(data.expenses || [])], 'expenses');
                            state.customers = deduplicateByContent([...(state.customers || []), ...(data.customers || [])], 'customers');
                            state.invoices = deduplicateByContent([...(state.invoices || []), ...(data.invoices || [])], 'invoices');
                            state.notes = deduplicateByContent([...(state.notes || []), ...(data.notes || [])], 'notes');
                            state.transactions = deduplicateByContent([...(state.transactions || []), ...(data.transactions || [])], 'transactions');
                            state.unpaidEntries = deduplicateByContent([...(state.unpaidEntries || []), ...(data.unpaidEntries || [])], 'unpaid');

                            // Merge categories (set-based)
                            state.categories = Array.from(new Set([...(state.categories || []), ...((data.categories || []))]));

                            // Merge inventory by product name without overwriting local values
                            state.inventory = state.inventory || {};
                            const importedInventory = data.inventory || {};
                            Object.keys(importedInventory).forEach(name => {
                                if (!(name in state.inventory)) {
                                    state.inventory[name] = {
                                        stock: parseInt(importedInventory[name].stock) || 0,
                                        minAlert: parseInt(importedInventory[name].minAlert) || 5
                                    };
                                }
                            });

                            // Floats: merge per channel without overwriting
                            state.transactionFloats = state.transactionFloats || {};
                            const importedFloats = data.transactionFloats || {};
                            Object.keys(importedFloats).forEach(ch => {
                                if (!(ch in state.transactionFloats)) {
                                    state.transactionFloats[ch] = { initial: parseFloat(importedFloats[ch].initial) || 0, current: 0 };
                                }
                            });

                            // Targets: keep existing unless missing
                            if (state.dailyTarget == null) state.dailyTarget = data.dailyTarget || 0;
                            if (state.monthlyTarget == null) state.monthlyTarget = data.monthlyTarget || 0;

                            calculateFloatBalances();
                            saveData();
                            render();
                            showToast('Data imported and merged successfully!', 'success');

                            // If signed-in, upsert merged data to cloud in background
                            if (syncEnabled && currentUser) {
                                try { await clearAndPushAllData(); } catch (e) { /* no-op */ }
                            }
                        }
                    } catch (error) {
                        showToast('Error importing file. Please check the file format.', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function updateHeaderDate() {
            const dateElement = document.getElementById('headerDate');
            if (!dateElement) return;

            const now = new Date();

            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');

            let hours = now.getHours();
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');

            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // Convert 0 to 12

            dateElement.textContent = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${ampm}`;
        }

        function render() {
            const app = document.getElementById('app');
            switch (state.activeTab) {
                case 'dashboard': app.innerHTML = renderDashboard(); break;
                case 'account': app.innerHTML = renderAccount(); break;
                case 'sales': app.innerHTML = renderSales(); break;
                case 'transactions': app.innerHTML = renderTransactions(); break;
                case 'products': app.innerHTML = renderProducts(); break;
                case 'categories': app.innerHTML = renderCategories(); break;
                case 'expenses': app.innerHTML = renderExpenses(); break;
                case 'inventory': app.innerHTML = renderInventory(); break;
                case 'inventoryPurchases': app.innerHTML = renderInventoryTab(); break;
                case 'customers': app.innerHTML = renderCustomers(); break;
                case 'invoices': app.innerHTML = renderInvoices(); break;
                case 'analytics':
                    app.innerHTML = renderAnalytics();
                    createAnalyticsChart();
                    break;
                case 'unpaid': app.innerHTML = renderUnpaid(); break;
                case 'notes': app.innerHTML = renderNotes(); break;
            }
            renderNav();
            updateSideNavActiveState();

            // Update all "Select All" checkboxes after render
            setTimeout(() => {
                updateSelectAllCheckbox('sales');
                updateSelectAllCheckbox('products');
                updateSelectAllCheckbox('expenses');
                updateSelectAllCheckbox('customers');
                updateSelectAllCheckbox('transactions');
                updateSelectAllCheckbox('unpaidEntries');
            }, 0);
            try {
                document.querySelectorAll('.money-input').forEach(el => attachMoneyFormatter(el));
                const dt = document.getElementById('dailyTarget');
                const mt = document.getElementById('monthlyTarget');
                dt && dt.addEventListener('blur', () => { try { setDailyTarget(); } catch { } });
                mt && mt.addEventListener('blur', () => { try { setMonthlyTarget(); } catch { } });
            } catch { }
        }

        function runFormattingTests() {
            const cases = [1000, 999999, 999999999, 0, -12345];
            let passed = 0;
            cases.forEach(n => {
                const s = formatMoney(n);
                const back = parseMoney(s);
                if (Math.round(back) === Math.round(n)) passed++;
            });
            showToast(`Formatting tests: ${passed}/${cases.length} passed`, passed === cases.length ? 'success' : 'error');
        }
        async function runTargetSyncTests() {
            if (!syncEnabled || !currentUser) { showToast('Sign in to run sync tests', 'info'); return; }
            const val = Math.floor(Math.random() * 1000000);
            await upsertOne('settings', { daily_target: val });
            const ok = await verifyCloudSettings('daily_target', val);
            showToast(`Cloud verify daily_target: ${ok ? 'OK' : 'FAIL'}`, ok ? 'success' : 'error');
        }

        // Side Navigation Functions
        function toggleSideNav() {
            const sideNav = document.getElementById('sideNav');
            const overlay = document.getElementById('sideNavOverlay');
            const body = document.body;

            sideNav.classList.toggle('open');
            overlay.classList.toggle('show');
            body.classList.toggle('nav-open');
        }

        function navigateToTab(tabId) {
            switchTab(tabId);
            toggleSideNav();
        }

        function updateSideNavActiveState() {
            const items = document.querySelectorAll('.side-nav-item');
            items.forEach(item => {
                item.classList.remove('active');
            });

            const activeItem = Array.from(items).find(item => {
                const onclick = item.getAttribute('onclick');
                return onclick && onclick.includes(`'${state.activeTab}'`);
            });

            if (activeItem) {
                activeItem.classList.add('active');
            }
        }

        // Initialize
        initSupabase();

        // ============================================
        // TUBA SWIPE NAVIGATION v2.0
        // Enables left/right swipe with smooth transitions
        // ============================================

        (function () {
            console.log('üëÜ Initializing smooth swipe navigation...');

            let touchStartX = 0;
            let touchEndX = 0;
            let touchStartY = 0;
            let touchEndY = 0;
            let isSwiping = false;
            const SWIPE_THRESHOLD = 80; // Minimum swipe distance in pixels
            const VERTICAL_THRESHOLD = 50; // Maximum vertical movement to count as horizontal swipe

            // Add smooth transition CSS
            const style = document.createElement('style');
            style.textContent = `
                .content {
                    transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                }
                
                .content.swipe-exit-left {
                    opacity: 0;
                    transform: translateX(-30px);
                }
                
                .content.swipe-exit-right {
                    opacity: 0;
                    transform: translateX(30px);
                }
                
                .content.swipe-enter-left {
                    opacity: 0;
                    transform: translateX(30px);
                }
                
                .content.swipe-enter-right {
                    opacity: 0;
                    transform: translateX(-30px);
                }
                
                .content.swipe-active {
                    opacity: 1;
                    transform: translateX(0);
                }
                
                /* Smooth bottom nav highlight */
                .bottom-nav {
                    transition: all 0.3s ease;
                }
                
                .nav-item {
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                }
                
                .nav-item.active {
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                }
            `;
            document.head.appendChild(style);

            // Get tab order from tabs array
            const tabOrder = tabs.map(t => t.id);

            function getCurrentTabIndex() {
                return tabOrder.indexOf(state.activeTab);
            }

            function switchToTabByIndexWithAnimation(index, direction) {
                if (index < 0 || index >= tabOrder.length || isSwiping) {
                    return;
                }

                isSwiping = true;
                const newTab = tabOrder[index];
                const content = document.querySelector('.content');

                if (!content) {
                    switchTab(newTab);
                    isSwiping = false;
                    return;
                }

                // Exit animation
                content.classList.remove('swipe-active', 'swipe-enter-left', 'swipe-enter-right');
                content.classList.add(direction === 'left' ? 'swipe-exit-left' : 'swipe-exit-right');

                // Switch tab after exit animation starts
                setTimeout(() => {
                    state.activeTab = newTab;
                    render();

                    // Enter animation
                    const newContent = document.querySelector('.content');
                    if (newContent) {
                        newContent.classList.remove('swipe-active');
                        newContent.classList.add(direction === 'left' ? 'swipe-enter-right' : 'swipe-enter-left');

                        // Force reflow
                        void newContent.offsetWidth;

                        // Activate
                        requestAnimationFrame(() => {
                            newContent.classList.remove('swipe-enter-left', 'swipe-enter-right');
                            newContent.classList.add('swipe-active');

                            setTimeout(() => {
                                isSwiping = false;
                            }, 300);
                        });
                    } else {
                        isSwiping = false;
                    }
                }, 150);

                console.log(`üì± Smooth swipe to: ${newTab}`);
            }

            function handleSwipe() {
                const swipeDistanceX = touchEndX - touchStartX;
                const swipeDistanceY = Math.abs(touchEndY - touchStartY);

                // Check if it's a horizontal swipe (not vertical)
                if (swipeDistanceY > VERTICAL_THRESHOLD) {
                    return;
                }

                const currentIndex = getCurrentTabIndex();

                if (swipeDistanceX > SWIPE_THRESHOLD) {
                    // Swipe right - go to previous tab
                    console.log('üëâ Swipe right detected');
                    switchToTabByIndexWithAnimation(currentIndex - 1, 'right');
                } else if (swipeDistanceX < -SWIPE_THRESHOLD) {
                    // Swipe left - go to next tab
                    console.log('üëà Swipe left detected');
                    switchToTabByIndexWithAnimation(currentIndex + 1, 'left');
                }
            }

            // Add touch event listeners to the main content area
            const app = document.getElementById('app');
            if (!app) {
                console.error('‚ùå App element not found');
                return;
            }

            app.addEventListener('touchstart', (e) => {
                if (isSwiping) return;
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            app.addEventListener('touchend', (e) => {
                if (isSwiping) return;
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });

            // Initialize content with active class
            setTimeout(() => {
                const content = document.querySelector('.content');
                if (content) {
                    content.classList.add('swipe-active');
                }
            }, 100);

            console.log('‚úÖ Smooth swipe navigation initialized!');
            console.log('   üëà Swipe left = Next tab (smooth)');
            console.log('   üëâ Swipe right = Previous tab (smooth)');
            console.log(`   üìä Tab order: ${tabOrder.join(' ‚Üí ')}`);
        })();

        updateHeaderDate();

        // Load local data IMMEDIATELY - don't wait
        console.log('üì± Loading local data...');
        loadData();
        render(); // SHOW UI NOW

        // Restore session in BACKGROUND
        (async function () {
            try {
                const sessionRestored = await restoreSession();
                if (sessionRestored) {
                    console.log('‚òÅÔ∏è Session restored - syncing...');
                    render(); // Update UI with cloud data
                }
            } catch (error) {
                console.error('Session restore failed:', error);
            }
        })();

        // Update header date every second
        setInterval(() => {
            updateHeaderDate();
        }, 1000);

        // Auto-save every 15 seconds
        setInterval(() => {
            saveData();
        }, 15000);

        // PWA Manifest (find this section and replace it)
        const manifestData = {
            "name": "TUBA - The Ultimate Business Architecture",
            "short_name": "TUBA",
            "start_url": ".",
            "display": "standalone",
            "background_color": "#000000",
            "theme_color": "#000000",
            "description": "Complete business management solution",
            "icons": [
                {
                    "src": "tuba-icon.png",
                    "sizes": "192x192",
                    "type": "image/png"
                },
                {
                    "src": "tuba-icon.png",
                    "sizes": "512x512",
                    "type": "image/png",
                    "purpose": "any maskable"
                }
            ]
        };

        const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: 'application/json' });
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.querySelector('link[rel="manifest"]').setAttribute('href', manifestURL);

        // ============================================
        // TUBA SALES ENHANCEMENT PATCH v1.0
        // Added: Dynamic Product & Category Creation
        // ============================================

        // Store original renderSales function
        const originalRenderSales = window.renderSales;

        // Override renderSales function
        window.renderSales = function () {
            const stats = getStats();

            // Filter sales based on search and filters
            let filteredSales = state.sales.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredSales = filteredSales.filter(s =>
                    s.productName.toLowerCase().includes(Period) ||
                    s.customer.toLowerCase().includes(Period) ||
                    s.payment.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredSales = filteredSales.filter(s => new Date(s.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredSales = filteredSales.filter(s => new Date(s.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCustomer) {
                filteredSales = filteredSales.filter(s => s.customer === state.filterCustomer);
            }

            return `
        <div class="privacy-container">
            <button class="privacy-toggle-btn show" id="privacyToggleBtn" onclick="togglePrivacy()">
                ${state.privacyBlurred ? 'üîí' : 'üîì'}
            </button>

        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL CAPITAL</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalCapital)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL PROFIT</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.totalProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TODAY'S PROFIT</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.todayProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">10% TODAY</div>
                <div class="stat-value" style="font-size: 16px;">üí∞ ${formatNumber(stats.todayProfit * 0.1)} Tsh</div>
            </div>
        </div>
    </div>
</div>

        <div class="card">
            <h2>Add Sale</h2>
            <div class="card-header-buttons">
                <button class="quick-nav-btn products" onclick="switchTab('products')">Products</button>
                <button class="quick-nav-btn categories" onclick="switchTab('categories')">Categories</button>
            </div>
            <form onsubmit="addSale(event)">
                <div class="form-group">
                    <label>Product</label>
                    <select id="saleProduct" onchange="handleProductSelection()" required>
                        <option value="">-- Select Product --</option>
                        ${state.products
                    .map((p, i) => ({ p, i }))
                    .sort((a, b) => String(a.p.name).localeCompare(String(b.p.name)))
                    .map(({ p, i }) => {
                        const stockVal = (state.inventory[p.name] || { stock: 0 }).stock;
                        const label = (p.hasStock === false)
                            ? `${p.name} - ${p.category}`
                            : `${p.name} - ${p.category} (Stock: ${stockVal})`;
                        return `<option value="${i}">${label}</option>`;
                    }).join('')}
                        <option value="new" style="background: #e3f2fd; font-weight: 600;">+ Add New Product</option>
                    </select>
                </div>
                
                <div id="newProductFields" style="display:none;">
                    <div class="form-group">
                        <label>New Product Name</label>
                        <input type="text" id="newProductName" placeholder="Enter product name">
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <select id="newProductCategory" onchange="handleCategorySelection()">
                            <option value="">-- Select Category --</option>
                            ${state.categories.slice().sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}">${c}</option>`).join('')}
                            <option value="new" style="background: #fff3e0; font-weight: 600;">+ Add New Category</option>
                        </select>
                    </div>
                    
                    <div id="newCategoryField" style="display:none;">
                        <div class="form-group">
                            <label>New Category Name</label>
                            <input type="text" id="newCategoryName" placeholder="Enter category name">
                        </div>
                    </div>

                    <div class="form-group" style="display:flex;align-items:center;gap:8px;">
                        <label style="margin:0;">Track stock</label>
                        <input type="checkbox" id="newProductHasStock" checked onchange="toggleNewProductHasStock()">
                    </div>
                    
                    <div class="form-group" id="newProductStockGroup">
                        <label>Cost (Capital)</label>
                        <input type="number" id="newProductCost" placeholder="0.00" step="0.01">
                    </div>
                    <div class="form-group">
                        <label>Price (Selling)</label>
                        <input type="number" id="newProductPrice" placeholder="0.00" step="0.01">
                    </div>
                    <div class="form-group" id="newProductInitialStockGroup">
                        <label>Initial Stock</label>
                        <input type="number" id="newProductStock" placeholder="0" min="0" value="0">
                    </div>
                    <button type="button" class="btn-success" onclick="saveNewProductFromSales()" style="margin-bottom: 12px;">
                        ‚úÖ Save New Product
                    </button>
                    <button type="button" class="btn-secondary" onclick="cancelNewProduct()" style="margin-bottom: 12px;">
                        ‚úñ Cancel
                    </button>
                </div>

                <div class="form-group">
                    <label>Customer</label>
                    <select id="saleCustomer" onchange="toggleCustomerInput()">
                        <option value="">-- Walk-in --</option>
                        ${state.customers.map((c, i) => `<option value="${i}">${c.name}</option>`).join('')}
                        <option value="new">+ Add New Customer</option>
                    </select>
                </div>
                <div id="newCustomerFields" style="display:none;">
                    <div class="form-group">
                        <label>New Customer Name</label>
                        <input type="text" id="newCustomerName" placeholder="Enter customer name">
                    </div>
                    <div class="form-group">
                        <label>Phone (Optional)</label>
                        <input type="tel" id="newCustomerPhone" placeholder="+255...">
                    </div>
                </div>
                <div class="form-group">
                    <label>Quantity</label>
                    <input type="number" id="saleQuantity" value="1" min="1" onchange="updateSaleTotal()" required>
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <select id="salePayment">
                        <option>Cash</option>
                        <option>Card</option>
                        <option>Mobile Money</option>
                        <option>M-Pesa Lipa Number</option>
                        <option>Bank Transfer</option>
                    </select>
                </div>
                <div id="saleInfo"></div>
                <button type="submit">Record Sale</button>
            </form>
        </div>

        <div class="card">
            <h2>Recent Sales (${filteredSales.length})</h2>
            
            <div class="search-box">
                <input type="text" placeholder="üîç Search sales..." oninput="updateSearchPeriod(this.value)">
            </div>

            <div class="filter-row">
                <div class="form-group">
                    <label>From...</label>
                    <input type="date" onchange="updateFilterDateFrom(this.value)" value="${state.filterDateFrom || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>To...</label>
                    <input type="date" onchange="updateFilterDateTo(this.value)" value="${state.filterDateTo || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>Customer</label>
                    <select onchange="updateFilterCustomer(this.value)">
                        <option value="">All Customers</option>
                        ${[...new Set(state.sales.map(s => s.customer))].map(c =>
                        `<option value="${c}" ${state.filterCustomer === c ? 'selected' : ''}>${c}</option>`
                    ).join('')}
                    </select>
                </div>
                <button class="btn-small btn-secondary" onclick="clearFilters()">Clear</button>
            </div>

            ${(state.listExpanded.sales || state.searchPeriod || state.filterDateFrom || state.filterDateTo || state.filterCustomer) ? `
                <div class="bulk-actions">
                    <input type="checkbox" id="selectAll_sales" onchange="toggleSelectAll('sales')" class="checkbox-select">
                    <label for="selectAll_sales">Select All</label>
                    <span style="color: #666; font-size: 12px; margin-left: 8px;">
                        ${getSelectedCount('sales')} selected
                    </span>
                    <button class="btn-small btn-danger" onclick="bulkDelete('sales')" ${!hasSelected('sales') ? 'disabled' : ''}>
                        üóëÔ∏è Delete Selected
                    </button>
                </div>

                ${filteredSales.slice().reverse().map((s, idx) => `
                    <div class="item">
                        <div style="display: flex; gap: 12px; align-items: start;">
                            <input type="checkbox" class="checkbox-select" 
                                   ${state.selectedItems.sales && state.selectedItems.sales[s.id] ? 'checked' : ''}
                                   onchange="toggleSelect('sales', '${s.id}')">
                            <div style="flex: 1;">
                                <div class="item-header">
                                    <span class="item-title">${s.productName}</span>
                                    <span style="color: #2e7d32; font-weight: 700;">üí∞ ${formatNumber(s.profit)} Tsh</span>
                                </div>
                                <div class="item-subtitle">
                                    ${s.date} ${s.time}<br>
                                    ${s.customer} | Qty: ${s.quantity} | ${s.payment}<br>
                                    Cost: ${formatNumber(s.totalCost)} | Price: ${formatNumber(s.totalPrice)}
                                </div>
                                <div class="flex-gap" style="margin-top:8px;">
                                    <button class="btn-small" style="background: linear-gradient(145deg, #ffeb3b, #fbc02d); color: #333;" onclick="downloadSaleReceiptPDF(${s.timestamp})">üìÑ Receipt</button>
                                    <button class="btn-small" onclick="editSaleByTimestamp(${s.timestamp})">Edit</button>
                                    <button class="btn-small btn-danger" onclick="deleteSaleByTimestamp(${s.timestamp})">Delete</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('') || '<p style="text-align: center; color: #666;">No sales found</p>'}
            ` : ''}

            <button class="collapse-btn" onclick="toggleListExpanded('sales')">
                <span class="collapse-icon ${state.listExpanded.sales ? 'expanded' : ''}">‚ñº</span>
                <span>${state.listExpanded.sales ? 'Hide' : 'Show'} All Sales</span>
            </button>
        </div>
    `;
        };

        // New function: Handle product selection
        window.handleProductSelection = function () {
            const select = document.getElementById('saleProduct');
            const newFields = document.getElementById('newProductFields');

            if (select && newFields) {
                if (select.value === 'new') {
                    newFields.style.display = 'block';
                    // Clear previous inputs
                    document.getElementById('newProductName').value = '';
                    document.getElementById('newProductCategory').value = '';
                    document.getElementById('newCategoryName').value = '';
                    document.getElementById('newProductCost').value = '';
                    document.getElementById('newProductPrice').value = '';
                    document.getElementById('newProductStock').value = '0';
                    document.getElementById('newCategoryField').style.display = 'none';
                    const hasStockEl = document.getElementById('newProductHasStock');
                    const stockGroup = document.getElementById('newProductInitialStockGroup');
                    if (hasStockEl && stockGroup) { hasStockEl.checked = true; stockGroup.style.display = 'block'; }
                } else {
                    newFields.style.display = 'none';
                    updateSaleTotal();
                }
            }
        };

        // New function: Handle category selection in new product form
        window.handleCategorySelection = function () {
            const select = document.getElementById('newProductCategory');
            const newCategoryField = document.getElementById('newCategoryField');

            if (select && newCategoryField) {
                if (select.value === 'new') {
                    newCategoryField.style.display = 'block';
                    document.getElementById('newCategoryName').value = '';
                } else {
                    newCategoryField.style.display = 'none';
                }
            }
        };

        // Toggle initial stock visibility based on hasStock checkbox
        window.toggleNewProductHasStock = function () {
            const hasStockEl = document.getElementById('newProductHasStock');
            const stockGroup = document.getElementById('newProductInitialStockGroup');
            if (hasStockEl && stockGroup) {
                stockGroup.style.display = hasStockEl.checked ? 'block' : 'none';
            }
        };

        // New function: Save new product from sales form
        window.saveNewProductFromSales = async function () {
            const name = document.getElementById('newProductName').value.trim();
            let categorySelect = document.getElementById('newProductCategory').value;
            if (typeof categorySelect === 'string') categorySelect = categorySelect.trim();
            const newCategoryName = document.getElementById('newCategoryName').value.trim();
            const cost = parseFloat(document.getElementById('newProductCost').value);
            const price = parseFloat(document.getElementById('newProductPrice').value);
            const hasStock = document.getElementById('newProductHasStock')?.checked !== false;
            const stock = hasStock ? (parseInt(document.getElementById('newProductStock').value) || 0) : 0;

            // Validation
            if (!name) {
                return showToast('Please enter product name', 'error');
            }

            let category;
            if (categorySelect === 'new') {
                if (!newCategoryName) {
                    return showToast('Please enter category name', 'error');
                }
                // Check if category already exists
                if (state.categories.includes(newCategoryName)) {
                    category = newCategoryName;
                    showToast('Category already exists, using existing one', 'info');
                } else {
                    // Add new category
                    state.categories.push(newCategoryName);
                    category = newCategoryName;
                    showToast('New category added!', 'success');
                }
            } else {
                if (!categorySelect) {
                    return showToast('Please select or create a category', 'error');
                }
                category = categorySelect;
            }

            if (isNaN(cost) || cost < 0) {
                return showToast('Please enter a valid cost', 'error');
            }

            if (isNaN(price) || price < 0) {
                return showToast('Please enter a valid price', 'error');
            }

            if (price < cost) {
                if (!confirm('Warning: Selling price is less than cost. Continue?')) {
                    return;
                }
            }

            // Check if product already exists
            if (state.products.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                return showToast('Product already exists', 'error');
            }

            // Create new product
            const product = {
                id: generateID('products'),
                name,
                category,
                cost,
                price,
                hasStock: hasStock ? true : false
            };
            state.products.push(product);

            // Initialize inventory
            if (!state.inventory) {
                state.inventory = {};
            }
            if (hasStock) {
                state.inventory[name] = {
                    stock: stock,
                    minAlert: 5
                };
            }

            saveData();

            if (syncEnabled) {
                await upsertOne('products', { name, category, cost, price, has_stock: hasStock ? true : false });
                if (hasStock) {
                    await upsertOne('inventory', { product_name: name, stock: stock, min_alert: 5 });
                }
                if (category) {
                    await upsertOne('categories', { name: category });
                }
                syncInBackground();
            }

            // Auto-select the new product
            const productSelect = document.getElementById('saleProduct');
            const newProductIndex = state.products.length - 1;

            // Re-render to show new product in list
            render();

            // After re-render, select the new product
            setTimeout(() => {
                const updatedSelect = document.getElementById('saleProduct');
                if (updatedSelect) {
                    updatedSelect.value = newProductIndex;
                    updateSaleTotal();
                }
            }, 100);

            showToast('‚úÖ Product added successfully!', 'success');
        };

        // New function: Cancel new product creation
        window.cancelNewProduct = function () {
            document.getElementById('saleProduct').value = '';
            document.getElementById('newProductFields').style.display = 'none';
            document.getElementById('saleInfo').innerHTML = '';
        };

        console.log('‚úÖ TUBA Sales Enhancement Patch loaded successfully!');
        // END OF PATCH


        // ============================================
        // TUBA COMPLETE ENHANCEMENT v2.0
        // ============================================

        console.log('üöÄ Loading TUBA enhancements...');

        // ============================================
        // FIX 1: Deterministic ID Generation
        // ============================================

        function generateDeterministicID(type, item) {
            let hashBase = '';

            switch (type) {
                case 'sales':
                    hashBase = `${item.productName}|${item.customer}|${item.timestamp || Date.now()}`;
                    break;
                case 'products':
                    hashBase = `${item.name}|${item.category}|${item.cost}|${item.price}`;
                    break;
                case 'expenses':
                    hashBase = `${item.description}|${item.category}|${item.timestamp || Date.now()}`;
                    break;
                case 'customers':
                    hashBase = `${item.name}|${item.email || ''}|${item.phone || ''}`;
                    break;
                case 'transactions':
                    hashBase = `${item.channel}|${item.type}|${item.timestamp || Date.now()}`;
                    break;
                case 'unpaid':
                    hashBase = `${item.name}|${item.type}|${item.timestamp || Date.now()}`;
                    break;
                case 'notes':
                    hashBase = `${item.content.substring(0, 50)}|${item.timestamp || Date.now()}`;
                    break;
                default:
                    hashBase = JSON.stringify(item);
            }

            let hash = 0;
            for (let i = 0; i < hashBase.length; i++) {
                const char = hashBase.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }

            const prefix = {
                'sales': 'S',
                'products': 'P',
                'expenses': 'E',
                'customers': 'C',
                'transactions': 'T',
                'unpaid': 'U',
                'notes': 'N'
            }[type] || 'X';

            return `${prefix}-${Math.abs(hash).toString(36).toUpperCase()}`;
        }

        function generateIDSafe(type, item = null) {
            if (item && typeof item === 'object') {
                return generateDeterministicID(type, item);
            }
            return generateID(type);
        }

        // ============================================
        // FIX 2: Content-Based Deduplication
        // ============================================

        function deduplicateByContent(items, type) {
            if (!Array.isArray(items) || items.length === 0) return items;

            const uniqueMap = new Map();

            items.forEach(item => {
                let contentKey;

                switch (type) {
                    case 'sales':
                        contentKey = `${item.productName}|${item.customer}|${item.date}|${item.time}|${item.quantity}|${item.totalPrice}`;
                        break;
                    case 'products':
                        contentKey = `${(item.name || '').trim()}|${(item.category || '').trim()}`;
                        break;
                    case 'expenses':
                        contentKey = `${item.description}|${item.date}|${item.time}|${item.amount}`;
                        break;
                    case 'customers':
                        contentKey = `${item.name}|${item.email || ''}|${item.phone || ''}`;
                        break;
                    case 'transactions':
                        contentKey = `${item.channel}|${item.date}|${item.time}|${item.amount}|${item.type}`;
                        break;
                    case 'unpaid':
                        contentKey = `${item.name}|${item.type}|${item.date}|${item.amount}`;
                        break;
                    case 'notes':
                        contentKey = `${item.content}|${item.date}|${item.time}`;
                        break;
                    default:
                        contentKey = JSON.stringify(item);
                }

                if (!uniqueMap.has(contentKey)) {
                    if (!item.id) {
                        item.id = generateDeterministicID(type, item);
                    }
                    uniqueMap.set(contentKey, item);
                } else {
                    const existing = uniqueMap.get(contentKey);
                    const merged = { ...existing, ...item };
                    merged.id = existing.id;
                    uniqueMap.set(contentKey, merged);
                }
            });

            return Array.from(uniqueMap.values());
        }

        // ============================================
        // FIX 3: Improved Smart Merge
        // ============================================

        async function smartMergeDataFixed() {
            try {
                updateSyncIndicator('syncing');
                showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                console.log('üîÑ Starting smart merge with duplicate prevention...');

                const localData = {
                    sales: [...(state.sales || [])],
                    products: [...(state.products || [])],
                    expenses: [...(state.expenses || [])],
                    customers: [...(state.customers || [])],
                    transactions: [...(state.transactions || [])],
                    unpaidEntries: [...(state.unpaidEntries || [])],
                    notes: [...(state.notes || [])]
                };

                console.log('üì¶ Local data backed up');

                const cloudData = {
                    sales: [],
                    products: [],
                    expenses: [],
                    customers: [],
                    transactions: [],
                    unpaidEntries: [],
                    notes: []
                };

                try {
                    const { data: products } = await supabase
                        .from('products')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (products) {
                        cloudData.products = products.map(p => ({
                            name: p.name,
                            category: p.category,
                            cost: parseFloat(p.cost),
                            price: parseFloat(p.price),
                            hasStock: (p.has_stock === false) ? false : true
                        }));
                    }

                    const { data: sales } = await supabase
                        .from('sales')
                        .select('*')
                        .eq('user_id', currentUser.id)
                        .order('timestamp', { ascending: false });
                    if (sales) {
                        cloudData.sales = sales.map(s => ({
                            date: s.date,
                            time: s.time,
                            timestamp: s.timestamp,
                            productName: s.product_name,
                            customer: s.customer,
                            quantity: s.quantity,
                            costPerUnit: parseFloat(s.cost_per_unit),
                            pricePerUnit: parseFloat(s.price_per_unit),
                            totalCost: parseFloat(s.total_cost),
                            totalPrice: parseFloat(s.total_price),
                            profit: parseFloat(s.profit),
                            payment: s.payment
                        }));
                    }

                    const { data: expenses } = await supabase
                        .from('expenses')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (expenses) {
                        cloudData.expenses = expenses.map(e => ({
                            date: e.date,
                            time: e.time,
                            timestamp: e.timestamp,
                            description: e.description,
                            category: e.category,
                            amount: parseFloat(e.amount),
                            payment: e.payment,
                            comment: e.comment
                        }));
                    }

                    const { data: customers } = await supabase
                        .from('customers')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (customers) {
                        cloudData.customers = customers.map(c => ({
                            name: c.name,
                            email: c.email || '',
                            phone: c.phone || '',
                            address: c.address || '',
                            totalPurchases: parseFloat(c.total_purchases || 0)
                        }));
                    }

                    const { data: transactions } = await supabase
                        .from('transactions')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (transactions) {
                        cloudData.transactions = transactions.map(t => ({
                            channel: t.channel,
                            customerName: t.customer_name,
                            type: t.type,
                            amount: parseFloat(t.amount),
                            date: t.date,
                            time: t.time,
                            timestamp: t.timestamp
                        }));
                    }

                    const { data: unpaidEntries } = await supabase
                        .from('unpaid_entries')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (unpaidEntries) {
                        cloudData.unpaidEntries = unpaidEntries.map(u => ({
                            name: u.name,
                            type: u.type,
                            amount: parseFloat(u.amount),
                            date: u.date,
                            time: u.time,
                            timestamp: u.timestamp,
                            paid: u.paid
                        }));
                    }

                    const { data: notes } = await supabase
                        .from('notes')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (notes) {
                        cloudData.notes = notes.map(n => ({
                            title: n.title || '',
                            content: n.content,
                            date: n.date,
                            time: n.time,
                            timestamp: n.timestamp
                        }));
                    }

                    console.log('‚òÅÔ∏è  Cloud data fetched');

                } catch (fetchError) {
                    console.error('Error fetching cloud data:', fetchError);
                    throw fetchError;
                }

                console.log('üîÄ Merging data...');

                state.sales = [...localData.sales, ...cloudData.sales];
                state.products = [...localData.products, ...cloudData.products];
                state.expenses = [...localData.expenses, ...cloudData.expenses];
                state.customers = [...localData.customers, ...cloudData.customers];
                state.transactions = [...localData.transactions, ...cloudData.transactions];
                state.unpaidEntries = [...localData.unpaidEntries, ...cloudData.unpaidEntries];
                state.notes = [...localData.notes, ...cloudData.notes];

                state.sales = deduplicateByContent(state.sales, 'sales');
                state.products = deduplicateByContent(state.products, 'products');
                state.expenses = deduplicateByContent(state.expenses, 'expenses');
                state.customers = deduplicateByContent(state.customers, 'customers');
                state.transactions = deduplicateByContent(state.transactions, 'transactions');
                state.unpaidEntries = deduplicateByContent(state.unpaidEntries, 'unpaid');
                state.notes = deduplicateByContent(state.notes, 'notes');

                console.log('‚úÖ Deduplication complete');
                console.log(`üìä Final counts: ${state.sales.length} sales, ${state.products.length} products`);

                saveData();

                console.log('‚¨ÜÔ∏è  Pushing merged data to cloud...');
                await clearAndPushAllData();

                updateSyncIndicator('synced');
                console.log('‚úÖ Smart merge completed successfully');

            } catch (error) {
                console.error('Smart merge error:', error);
                updateSyncIndicator('synced');
                throw error;
            }
        }

        window.smartMergeData = smartMergeDataFixed;

        // ============================================
        // FIX 4: Sync Lock
        // ============================================

        let syncLock = false;

        async function syncInBackgroundSafe() {
            if (!syncEnabled || !currentUser) return;
            if (syncLock) {
                console.log('‚è∏Ô∏è  Sync already in progress, skipping...');
                return;
            }

            syncLock = true;
            try {
                await clearAndPushAllData();
                console.log('‚úÖ Background sync complete');
            } catch (error) {
                console.error('‚ùå Background sync error:', error);
            } finally {
                syncLock = false;
            }
        }

        window.syncInBackground = syncInBackgroundSafe;

        // ============================================
        // FIX 5: Manual Duplicate Cleaner
        // ============================================

        async function cleanAllDuplicates() {
            console.log('üßπ Cleaning duplicates...');

            const beforeCounts = {
                sales: state.sales.length,
                products: state.products.length,
                expenses: state.expenses.length,
                customers: state.customers.length,
                transactions: state.transactions.length,
                unpaidEntries: state.unpaidEntries.length,
                notes: state.notes.length
            };

            state.sales = deduplicateByContent(state.sales, 'sales');
            state.products = deduplicateByContent(state.products, 'products');
            state.expenses = deduplicateByContent(state.expenses, 'expenses');
            state.customers = deduplicateByContent(state.customers, 'customers');
            state.transactions = deduplicateByContent(state.transactions, 'transactions');
            state.unpaidEntries = deduplicateByContent(state.unpaidEntries, 'unpaid');
            state.notes = deduplicateByContent(state.notes, 'notes');

            const afterCounts = {
                sales: state.sales.length,
                products: state.products.length,
                expenses: state.expenses.length,
                customers: state.customers.length,
                transactions: state.transactions.length,
                unpaidEntries: state.unpaidEntries.length,
                notes: state.notes.length
            };

            const removed = {
                sales: beforeCounts.sales - afterCounts.sales,
                products: beforeCounts.products - afterCounts.products,
                expenses: beforeCounts.expenses - afterCounts.expenses,
                customers: beforeCounts.customers - afterCounts.customers,
                transactions: beforeCounts.transactions - afterCounts.transactions,
                unpaidEntries: beforeCounts.unpaidEntries - afterCounts.unpaidEntries,
                notes: beforeCounts.notes - afterCounts.notes
            };

            const totalRemoved = Object.values(removed).reduce((a, b) => a + b, 0);

            console.log('‚úÖ Duplicates removed:', removed);
            console.log(`üéâ Total duplicates removed: ${totalRemoved}`);

            saveData();

            if (syncEnabled && currentUser) {
                await clearAndPushAllData();
            }

            render();
            showToast(`üßπ Removed ${totalRemoved} duplicates!`, 'success');

            return { removed, totalRemoved };
        }

        window.cleanAllDuplicates = cleanAllDuplicates;

        // ============================================
        // FIX 6: Auto Duplicate Detection on Load
        // ============================================

        function detectDuplicatesOnLoad() {
            console.log('üîç Checking for duplicates on load...');

            const duplicateCounts = {
                sales: 0,
                products: 0,
                expenses: 0,
                customers: 0,
                transactions: 0,
                unpaidEntries: 0,
                notes: 0
            };

            // Check sales
            const salesMap = new Map();
            state.sales.forEach(s => {
                const key = `${s.productName}|${s.customer}|${s.date}|${s.time}`;
                if (salesMap.has(key)) duplicateCounts.sales++;
                salesMap.set(key, true);
            });

            // Check products
            const productsMap = new Map();
            state.products.forEach(p => {
                const key = `${p.name}|${p.category}`;
                if (productsMap.has(key)) duplicateCounts.products++;
                productsMap.set(key, true);
            });

            // Check expenses
            const expensesMap = new Map();
            state.expenses.forEach(e => {
                const key = `${e.description}|${e.date}|${e.time}`;
                if (expensesMap.has(key)) duplicateCounts.expenses++;
                expensesMap.set(key, true);
            });

            // Check customers
            const customersMap = new Map();
            state.customers.forEach(c => {
                const key = `${c.name}|${c.email || ''}`;
                if (customersMap.has(key)) duplicateCounts.customers++;
                customersMap.set(key, true);
            });

            // Check transactions
            const transactionsMap = new Map();
            state.transactions.forEach(t => {
                const key = `${t.channel}|${t.date}|${t.time}|${t.amount}`;
                if (transactionsMap.has(key)) duplicateCounts.transactions++;
                transactionsMap.set(key, true);
            });

            // Check unpaid
            const unpaidMap = new Map();
            state.unpaidEntries.forEach(u => {
                const key = `${u.name}|${u.type}|${u.date}`;
                if (unpaidMap.has(key)) duplicateCounts.unpaidEntries++;
                unpaidMap.set(key, true);
            });

            // Check notes
            const notesMap = new Map();
            state.notes.forEach(n => {
                const key = `${n.content}|${n.date}|${n.time}`;
                if (notesMap.has(key)) duplicateCounts.notes++;
                notesMap.set(key, true);
            });

            const totalDuplicates = Object.values(duplicateCounts).reduce((a, b) => a + b, 0);

            if (totalDuplicates > 0) {
                console.warn(`‚ö†Ô∏è  Found ${totalDuplicates} potential duplicates!`, duplicateCounts);
                state.hasDuplicates = true;
                state.duplicateCounts = duplicateCounts;
            } else {
                console.log('‚úÖ No duplicates detected');
                state.hasDuplicates = false;
                state.duplicateCounts = null;
            }

            return { hasDuplicates: totalDuplicates > 0, counts: duplicateCounts, total: totalDuplicates };
        }

        window.detectDuplicatesOnLoad = detectDuplicatesOnLoad;

        // ============================================
        // FIX 7: Enhanced Dashboard with Duplicate Alert
        // ============================================

        const originalRenderDashboard = window.renderDashboard;

        window.renderDashboard = function () {
            const dashboardHTML = originalRenderDashboard();

            // Check for duplicates
            const dupeCheck = detectDuplicatesOnLoad();

            if (dupeCheck.hasDuplicates) {
                const dupeAlert = `
                <div class="alert-box-danger" style="animation: highlightFade 2s ease-out;">
                    <strong>‚ö†Ô∏è  Duplicate Data Detected!</strong><br>
                    Found ${dupeCheck.total} potential duplicates in your data.<br>
                    <div style="margin-top: 8px; font-size: 12px;">
                        Sales: ${dupeCheck.counts.sales} | 
                        Products: ${dupeCheck.counts.products} | 
                        Expenses: ${dupeCheck.counts.expenses} |
                        Customers: ${dupeCheck.counts.customers}
                    </div>
                    <button class="btn-danger" style="margin-top: 12px; width: 100%;" onclick="cleanDuplicatesFromUI()">
                        üßπ Clean All Duplicates Now
                    </button>
                </div>
            `;

                return dupeAlert + dashboardHTML;
            }

            return dashboardHTML;
        };

        // ============================================
        // FIX 8: Clean Duplicates UI Function
        // ============================================

        async function cleanDuplicatesFromUI() {
            if (!confirm('This will remove all duplicate entries. Continue?')) {
                return;
            }

            showToast('üßπ Cleaning duplicates...', 'info');

            try {
                const result = await cleanAllDuplicates();

                if (result.totalRemoved > 0) {
                    showToast(`‚úÖ Removed ${result.totalRemoved} duplicates!`, 'success');
                } else {
                    showToast('‚úÖ No duplicates found!', 'success');
                }
            } catch (error) {
                console.error('Error cleaning duplicates:', error);
                showToast('‚ùå Error cleaning duplicates', 'error');
            }
        }

        window.cleanDuplicatesFromUI = cleanDuplicatesFromUI;

        // ============================================
        // FIX 9: Update Side Nav with Clean Button
        // ============================================

        const sideNavCleanupItem = document.querySelector('.side-nav-item[onclick="openCleanupModal()"]');
        if (sideNavCleanupItem) {
            sideNavCleanupItem.setAttribute('onclick', 'cleanDuplicatesFromUI(); toggleSideNav();');
            sideNavCleanupItem.innerHTML = `
            <span class="side-nav-icon">üßπ</span>
            <span>Clean Duplicates</span>
        `;
        }

        // ============================================
        // FIX 10: Run Detection on First Load
        // ============================================

        setTimeout(() => {
            const dupeCheck = detectDuplicatesOnLoad();
            if (dupeCheck.hasDuplicates && state.activeTab === 'dashboard') {
                render();
            }
        }, 2000);

        console.log('‚úÖ All TUBA enhancements loaded successfully!');
        console.log('üìã Available functions:');
        console.log('   ‚Ä¢ cleanAllDuplicates() - Manual duplicate cleaning');
        console.log('   ‚Ä¢ detectDuplicatesOnLoad() - Check for duplicates');
        console.log('   ‚Ä¢ cleanDuplicatesFromUI() - UI-triggered cleaning');


        // ============================================
        // UI ENHANCEMENT FUNCTIONS
        // ============================================

        console.log('üé® Loading UI enhancements...');

        // Update side nav auth button based on login state
        function updateSideNavAuthButton() {
            const authButton = document.getElementById('sideNavAuthButton');
            const authIcon = document.getElementById('sideNavAuthIcon');
            const authText = document.getElementById('sideNavAuthText');

            if (!authButton || !authIcon || !authText) return;

            if (currentUser && syncEnabled) {
                // User is logged in
                authIcon.textContent = 'üö™';
                authText.textContent = 'Logout';
                authButton.style.background = 'linear-gradient(145deg, #d32f2f, #b71c1c)';
            } else {
                // User is logged out
                authIcon.textContent = 'üîê';
                authText.textContent = 'Login';
                authButton.style.background = 'linear-gradient(145deg, #2e7d32, #1b5e20)';
            }
        }

        // Handle side nav auth button click
        async function handleSideNavAuth() {
            // Double-check actual session to avoid UI desync
            let effectiveUser = null;
            try {
                const { data: { session } } = await supabase.auth.getSession();
                effectiveUser = session?.user || null;
            } catch { }

            if (effectiveUser && syncEnabled) {
                // User is logged in - logout
                if (confirm('Are you sure you want to logout?')) {
                    await signOut();
                    toggleSideNav();
                    showToast('Logged out successfully', 'info');
                }
            } else {
                // User is logged out - go to account tab
                switchTab('account');
                toggleSideNav();
            }
        }

        // Override the original render to update auth button
        const originalRender = window.render;
        window.render = function () {
            originalRender();
            updateSideNavAuthButton();
            // Auto-submit login if autofill populated credentials
            if (state.activeTab === 'account' && !currentUser) {
                try { autoSubmitLoginIfAutofilled(); } catch (e) { /* no-op */ }
            }
        };

        // Override toggleSideNav to update button when opened
        const originalToggleSideNav = window.toggleSideNav;
        window.toggleSideNav = function () {
            originalToggleSideNav();
            setTimeout(updateSideNavAuthButton, 100);
        };

        // Update button on initial load
        setTimeout(updateSideNavAuthButton, 1000);

        // Enhanced renderDashboard with new quick actions

        window.renderDashboard = function () {
            let html = originalRenderDashboard();

            // Check if quick actions need updating (for older versions)
            if (!html.includes('üìÑ Invoices')) {
                const quickActionsRegex = /<div class="card">\s*<h2>Quick Actions<\/h2>\s*<div class="flex-gap">([\s\S]*?)<\/div>\s*<\/div>/;

                const newQuickActions = `<div class="card">
                    <h2>Quick Actions</h2>
                    <div class="flex-gap">
                        <button class="btn-success btn-small" onclick="switchTab('sales')">‚ûï New Sale</button>
                        <button class="btn-danger btn-small" onclick="switchTab('expenses')">üí∏ Add Expense</button>
                        <button class="btn-small" onclick="switchTab('products')">üõí Manage Products/Services</button>
                        <button class="btn-small" onclick="switchTab('transactions')">üí≥ Transactions</button>
                        <button class="btn-small" onclick="switchTab('inventoryPurchases')">üì¶ Inventory</button>
                        <button class="btn-small" onclick="switchTab('invoices')" style="background: linear-gradient(145deg, #1976d2, #0d47a1); color: white;">üìÑ Invoices</button>
                        <button class="btn-small" onclick="switchTab('notes')" style="background: linear-gradient(145deg, #e65100, #bf360c); color: white;">üìù Notes</button>
                        <button class="btn-small" onclick="switchTab('analytics')" style="background: linear-gradient(145deg, #7b1fa2, #4a148c); color: white;">üìà Analytics</button>
                    </div>
                </div>`;

                if (quickActionsRegex.test(html)) {
                    html = html.replace(quickActionsRegex, newQuickActions);
                }
            }

            return html;
        };

        console.log('‚úÖ UI enhancements loaded successfully!');


        // ============================================
        // TUBA AUTHENTICATION FIX PATCH v1.0
        // Auto-applied on 2025-10-20T19:50:55.516Z
        // Fixes 404 error during registration
        // ============================================

        (function () {
            console.log('üîß Applying authentication fix patch...');

            // Override signUp function with enhanced error handling
            window.signUp = async function (email, password) {
                try {
                    console.log('üìß Attempting to sign up:', email);

                    // Validate inputs
                    if (!email || !password) {
                        showToast('Please provide email and password', 'error');
                        return null;
                    }

                    if (password.length < 6) {
                        showToast('Password must be at least 6 characters', 'error');
                        return null;
                    }

                    // Check if supabase is initialized
                    if (!supabase) {
                        console.error('‚ùå Supabase not initialized');
                        showToast('Database connection error. Please refresh the page.', 'error');
                        return null;
                    }

                    // Attempt sign up with enhanced options
                    const { data, error } = await supabase.auth.signUp({
                        email: email.trim(),
                        password: password,
                        options: {
                            emailRedirectTo: window.location.origin,
                            data: {
                                created_at: new Date().toISOString(),
                                app_version: '2.0'
                            }
                        }
                    });

                    if (error) {
                        console.error('‚ùå Sign up error:', error);

                        // Handle specific error codes
                        if (error.message.includes('User already registered') || error.message.includes('already been registered')) {
                            showToast('This email is already registered. Try signing in instead.', 'error');
                        } else if (error.message.includes('Invalid email')) {
                            showToast('Please enter a valid email address', 'error');
                        } else if (error.status === 404 || error.message.includes('404')) {
                            showToast('‚ö†Ô∏è Authentication service configuration error', 'error');
                            console.error('üîç Possible causes:');
                            console.error('   1. Invalid Supabase URL');
                            console.error('   2. Wrong API key');
                            console.error('   3. Email auth not enabled in Supabase dashboard');
                            console.error('   4. Project paused or deleted');
                            console.error('   ‚Üí Check your Supabase dashboard: https://supabase.com/dashboard');
                        } else if (error.message.includes('Email not confirmed')) {
                            showToast('Please confirm your email address', 'info');
                        } else {
                            showToast('Sign up error: ' + error.message, 'error');
                        }

                        return null;
                    }

                    console.log('‚úÖ Sign up response:', data);

                    // Check if email confirmation is required
                    if (data.user && !data.session) {
                        showToast('‚úÖ Account created! Please check your email to confirm.', 'success');
                        console.log('üìß Email confirmation required. Check your inbox.');
                    } else if (data.user && data.session) {
                        showToast('‚úÖ Account created and logged in successfully!', 'success');
                        currentUser = data.user;
                        syncEnabled = true;
                        updateSyncIndicator('synced');

                        // Initialize user profile
                        await loadUserProfile();
                        render();
                    } else if (data.user && data.user.identities && data.user.identities.length === 0) {
                        showToast('This email is already registered. Please sign in instead.', 'info');
                    }

                    return data;

                } catch (error) {
                    console.error('‚ùå Sign up exception:', error);
                    showToast('Unexpected error during sign up. Please try again.', 'error');
                    return null;
                }
            };

            // Override handleSignUp function
            window.handleSignUp = async function () {
                const email = document.getElementById('signupEmail')?.value;
                const password = document.getElementById('signupPassword')?.value;
                const confirm = document.getElementById('signupPasswordConfirm')?.value;

                if (!email || !password || !confirm) {
                    return showToast('Please fill in all fields', 'error');
                }

                // Email validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    return showToast('Please enter a valid email address', 'error');
                }

                if (password !== confirm) {
                    return showToast('Passwords do not match', 'error');
                }

                if (password.length < 6) {
                    return showToast('Password must be at least 6 characters', 'error');
                }

                // Disable buttons during sign up
                const signupForm = document.getElementById('signupForm');
                if (signupForm) {
                    const buttons = signupForm.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.6';
                        btn.style.cursor = 'not-allowed';
                    });
                }

                try {
                    await window.signUp(email, password);
                } finally {
                    // Re-enable buttons
                    if (signupForm) {
                        const buttons = signupForm.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.disabled = false;
                            btn.style.opacity = '1';
                            btn.style.cursor = 'pointer';
                        });
                    }
                }
            };

            // Enhanced handleSignIn with better error handling
            const originalHandleSignIn = window.handleSignIn;
            window.handleSignIn = async function () {
                const email = document.getElementById('loginEmail')?.value;
                const password = document.getElementById('loginPassword')?.value;

                if (!email || !password) {
                    return showToast('Please fill in all fields', 'error');
                }

                // Email validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    return showToast('Please enter a valid email address', 'error');
                }

                // Disable button during sign in
                const loginForm = document.getElementById('loginForm');
                if (loginForm) {
                    const buttons = loginForm.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.6';
                        btn.style.cursor = 'not-allowed';
                    });
                }

                try {
                    const result = await signIn(email, password);
                    if (result) {
                        render();
                    }
                } catch (error) {
                    console.error('Handle sign in error:', error);
                } finally {
                    // Re-enable buttons
                    if (loginForm) {
                        const buttons = loginForm.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.disabled = false;
                            btn.style.opacity = '1';
                            btn.style.cursor = 'pointer';
                        });
                    }
                }
            };

            // Enhanced signIn function with better error handling
            const originalSignIn = window.signIn;
            window.signIn = async function (email, password) {
                try {
                    console.log('üîê Attempting to sign in:', email);

                    const { data, error } = await supabase.auth.signInWithPassword({
                        email: email.trim(),
                        password: password
                    });

                    if (error) {
                        console.error('‚ùå Sign in error:', error);

                        if (error.message.includes('Invalid login credentials')) {
                            showToast('Invalid email or password', 'error');
                        } else if (error.message.includes('Email not confirmed')) {
                            showToast('Please confirm your email address first', 'error');
                        } else if (error.status === 404) {
                            showToast('Authentication service error. Check your connection.', 'error');
                        } else {
                            showToast('Sign in error: ' + error.message, 'error');
                        }

                        currentUser = null;
                        syncEnabled = false;
                        return null;
                    }

                    currentUser = data.user;
                    syncEnabled = true;

                    showToast('‚úÖ Signed in successfully!', 'success');

                    // Hydrate profile and logo
                    await loadUserProfile();
                    try { await ensureLogoReady(); } catch (e) { /* no-op */ }
                    // if (state.userLogoDataUrl) {
                    //     try { await uploadLogoToSupabase(state.userLogoDataUrl, state.userLogoMime || 'image/png'); } catch (e) { console.warn('Logo upload after sign-in failed:', e); }
                    // }
                    try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }

                    // Load user profile first
                    await loadUserProfile();

                    // Upload logo if selected locally
                    if (state.userLogoDataUrl) {
                        try { await uploadLogoToSupabase(state.userLogoDataUrl, state.userLogoMime || 'image/png'); } catch (e) { console.warn('Logo upload after sign-in failed:', e); }
                    }

                    // Check if local data exists
                    const localHasData = state.sales.length > 0 || state.products.length > 0;

                    try {
                        if (localHasData) {
                            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                            await smartMergeData();
                            showToast('Local and cloud data merged successfully', 'success');
                        } else {
                            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                            await pullDataFromSupabase();
                            showToast('Cloud data loaded', 'success');
                        }
                    } catch (syncError) {
                        console.error('Sync error after sign in:', syncError);
                        showToast('Signed in but sync failed. Try manual sync.', 'error');
                    }

                    try {
                        if (window.isSecureContext && navigator.credentials && window.PasswordCredential) {
                            const c = new PasswordCredential({ id: email.trim(), password: password });
                            try { navigator.credentials.store(c); } catch (e) { }
                        }
                    } catch (e) { }
                    return data;
                } catch (error) {
                    console.error('Sign in exception:', error);
                    showToast('Sign in error: ' + error.message, 'error');
                    currentUser = null;
                    syncEnabled = false;
                    return null;
                }
            };

            // Diagnostic function - run this in console to test connection
            window.testSupabaseConnection = async function () {
                console.log('üîç Running Supabase diagnostics...');
                console.log('==========================================');
                console.log('URL:', SUPABASE_URL);
                console.log('Key:', SUPABASE_ANON_KEY.substring(0, 30) + '...');
                console.log('Supabase initialized:', !!supabase);
                console.log('Current user:', currentUser?.email || 'Not logged in');
                console.log('Sync enabled:', syncEnabled);
                console.log('==========================================');

                if (!supabase) {
                    console.error('‚ùå Supabase not initialized!');
                    console.error('‚Üí Check if the Supabase script loaded correctly');
                    return false;
                }

                try {
                    // Test session
                    console.log('Testing session...');
                    const { data: sessionData, error: sessionError } = await supabase.auth.getSession();

                    if (sessionError) {
                        console.error('‚ùå Session test failed:', sessionError);
                    } else {
                        console.log('‚úÖ Session test passed');
                    }

                    // Test direct auth endpoint
                    console.log('Testing auth endpoint...');
                    const response = await fetch(SUPABASE_URL + '/auth/v1/health', {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY
                        }
                    });

                    console.log('Auth endpoint status:', response.status);

                    if (response.status === 404) {
                        console.error('‚ùå 404 Error - Possible issues:');
                        console.error('   1. Incorrect Supabase URL');
                        console.error('   2. Project paused or deleted');
                        console.error('   3. Invalid API key');
                        console.error('‚Üí Go to: https://supabase.com/dashboard');
                        console.error('‚Üí Verify your project settings');
                        return false;
                    } else if (response.ok) {
                        console.log('‚úÖ Auth endpoint accessible');
                    }

                    console.log('==========================================');
                    console.log('‚úÖ Diagnostics complete');
                    return true;

                } catch (error) {
                    console.error('‚ùå Connection test exception:', error);
                    console.error('‚Üí Check your internet connection');
                    console.error('‚Üí Verify Supabase project is active');
                    return false;
                }
            };

            // Auto-run diagnostics if there's a connection issue
            setTimeout(() => {
                if (!supabase || !SUPABASE_URL || !SUPABASE_ANON_KEY) {
                    console.error('‚ö†Ô∏è Supabase configuration incomplete!');
                    console.error('Run testSupabaseConnection() in console for diagnostics');
                }
            }, 2000);

            console.log('‚úÖ Authentication fix patch applied successfully!');
            console.log('üí° Available commands:');
            console.log('   ‚Ä¢ testSupabaseConnection() - Test your Supabase setup');
            console.log('');
            console.log('üîß Troubleshooting steps:');
            console.log('   1. Run: testSupabaseConnection()');
            console.log('   2. Check Supabase dashboard: https://supabase.com/dashboard');
            console.log('   3. Verify Email auth is enabled');
            console.log('   4. Check if email confirmation is required');
        })();

        // Mobile App Enhancements
        (function () {
            'use strict';

            // Splash Screen Management
            // Removed in-app pull-to-refresh functionality

            // PWA Installation
            let deferredPrompt;
            let installButton;

            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                showInstallButton();
            });

            function showInstallButton() {
                // Create install button if it doesn't exist
                if (!installButton) {
                    installButton = document.createElement('button');
                    installButton.innerHTML = 'üì± Install App';
                    installButton.className = 'btn btn-success';
                    installButton.style.cssText = `
                        position: fixed;
                        bottom: 80px;
                        right: 16px;
                        z-index: 1000;
                        padding: 8px 12px;
                        font-size: 12px;
                        width: auto;
                        border-radius: 20px;
                    `;
                    installButton.onclick = installApp;
                    document.body.appendChild(installButton);
                }
            }

            async function installApp() {
                if (!deferredPrompt) return;

                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;

                if (outcome === 'accepted') {
                    console.log('PWA installed successfully');
                    showToast('App installed successfully!', 'success');
                } else {
                    console.log('PWA installation declined');
                }

                deferredPrompt = null;
                if (installButton) {
                    installButton.remove();
                    installButton = null;
                }
            }



            // Offline banner: ensure element exists and update immediately and on connectivity changes
            (function () {
                const getOfflineBannerEl = () => {
                    let el = document.getElementById('offlineBanner');
                    if (!el) {
                        el = document.createElement('div');
                        el.id = 'offlineBanner';
                        el.className = 'offline-banner';
                        el.setAttribute('role', 'status');
                        el.setAttribute('aria-live', 'polite');
                        el.setAttribute('aria-atomic', 'true');
                        const headerEl = document.querySelector('.header');
                        if (headerEl && headerEl.parentNode) {
                            headerEl.parentNode.insertBefore(el, headerEl.nextSibling);
                        } else if (document.body) {
                            document.body.insertBefore(el, document.body.firstChild);
                        }
                    }
                    return el;
                };

                const updateOfflineBanner = () => {
                    const offlineBannerEl = getOfflineBannerEl();
                    if (!offlineBannerEl) return;
                    if (navigator.onLine) {
                        offlineBannerEl.style.display = 'none';
                        offlineBannerEl.textContent = '';
                        offlineBannerEl.onclick = null;
                        offlineBannerEl.classList.remove('clickable');
                    } else {
                        offlineBannerEl.innerHTML = "You‚Äôre offline ‚Äî Changes are saved locally <span style='opacity:0.9'>(Click for Info)</span>";
                        offlineBannerEl.style.display = 'block';
                        offlineBannerEl.onclick = () => { try { openOfflineInfoModal(); } catch (e) { } };
                        offlineBannerEl.classList.add('clickable');
                    }
                };

                updateOfflineBanner();
                window.addEventListener('online', updateOfflineBanner);
                window.addEventListener('offline', updateOfflineBanner);

                window.updateOfflineBanner = updateOfflineBanner;
            })();

            (function () {
                let isAuthRestoring = true;
                const getAuthBannerEl = () => {
                    let el = document.getElementById('authBanner');
                    if (!el) {
                        el = document.createElement('div');
                        el.id = 'authBanner';
                        el.className = 'offline-banner auth-banner';
                        el.setAttribute('role', 'status');
                        el.setAttribute('aria-live', 'polite');
                        el.setAttribute('aria-atomic', 'true');
                        const headerEl = document.querySelector('.header');
                        if (headerEl && headerEl.parentNode) {
                            headerEl.parentNode.insertBefore(el, headerEl.nextSibling.nextSibling);
                        } else if (document.body) {
                            document.body.insertBefore(el, document.body.firstChild);
                        }
                    }
                    return el;
                };
                window.updateAuthBanner = () => {
                    const el = getAuthBannerEl();
                    if (!el) return;
                    if (!navigator.onLine) {
                        el.style.display = 'none';
                        el.textContent = '';
                        el.onclick = null;
                    } else if (isAuthRestoring) {
                        el.innerHTML = "Restoring session‚Ä¶";
                        el.style.display = 'block';
                        el.onclick = null;
                    } else if (currentUser && syncEnabled) {
                        el.style.display = 'none';
                        el.textContent = '';
                        el.onclick = null;
                    } else {
                        el.innerHTML = "You‚Äôre not signed in ‚Äî tap to sign in and sync.";
                        el.style.display = 'block';
                        el.onclick = () => {
                            try {
                                switchTab('account');
                                setTimeout(() => {
                                    try { switchAuthTab('login'); } catch (e) { }
                                    const lf = document.getElementById('loginForm');
                                    lf && lf.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }, 50);
                            } catch (e) { }
                        };
                    }
                };
                window.updateAuthBanner();
                window.addEventListener('online', () => {
                    try { window.updateAuthBanner(); } catch { }
                    try {
                        if (!currentUser) {
                            showToast('Back online ‚Äî sign in to sync your data', 'info');
                        }
                    } catch { }
                });
                window.addEventListener('offline', () => { try { window.updateAuthBanner(); } catch { } });
                window.setAuthRestoring = (v) => { isAuthRestoring = !!v; };
            })();

            // Service Worker Registration and Capacitor Initialization
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', async () => {
                    try {
                        // Initialize Capacitor plugins if available
                        if (window.Capacitor) {
                            const { CapacitorApp } = await import('@capacitor/app');
                            const { StatusBar, Style } = await import('@capacitor/status-bar');

                            // Set status bar style
                            await StatusBar.setStyle({ style: Style.Dark });

                            console.log('Capacitor plugins initialized');
                        }

                        const registration = await navigator.serviceWorker.register('./sw.js', { scope: './' });
                        console.log('SW registered: ', registration);





                        // Initial state and event listeners
                        window.updateAuthBanner && window.updateAuthBanner();
                        // Periodic auth heartbeat to keep UI in sync
                        async function refreshAuthState() {
                            try {
                                const { data: { session } } = await supabase.auth.getSession();
                                if (session && session.user) {
                                    currentUser = session.user;
                                    syncEnabled = true;
                                } else {
                                    currentUser = null;
                                    syncEnabled = false;
                                }
                            } catch { }
                            try { window.setAuthRestoring(false); } catch { }
                            window.updateAuthBanner && window.updateAuthBanner();
                            updateSideNavAuthButton && updateSideNavAuthButton();
                        }
                        // On load, after SW ready, reconcile auth state
                        refreshAuthState();
                        // Also reconcile on online and visibility changes
                        window.addEventListener('online', refreshAuthState);
                        document.addEventListener('visibilitychange', () => { if (!document.hidden) refreshAuthState(); });
                        // Cross-tab sync via storage events
                        window.addEventListener('storage', (e) => {
                            const k = e.key || '';
                            if (k.includes('tuba-auth-token') || k.includes('sb-')) {
                                refreshAuthState();
                            }
                        });
                        // Periodic heartbeat
                        setInterval(refreshAuthState, 60000);
                        window.addEventListener('online', () => {
                            window.updateAuthBanner && window.updateAuthBanner();
                            try {
                                if (navigator.serviceWorker && navigator.serviceWorker.ready) {
                                    navigator.serviceWorker.ready.then(reg => {
                                        if (reg.sync && typeof reg.sync.register === 'function') {
                                            reg.sync.register('background-sync').catch(() => { });
                                        }
                                    });
                                }
                                // Trigger a background sync merge immediately when online
                                if (syncEnabled && currentUser) {
                                    try { syncInBackground(); } catch (e) { /* no-op */ }
                                }
                            } catch (e) { /* no-op */ }
                        });
                        window.addEventListener('offline', () => {
                            window.updateAuthBanner && window.updateAuthBanner();
                        });

                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    showToast('New version available! Refresh to update.', 'info');
                                }
                            });
                        });
                        // FAB removed; bottom tabs used for navigation
                    } catch (error) {
                        console.log('SW registration failed: ', error);
                    }
                });
            }

            // Enhanced Touch Feedback
            function addTouchFeedback() {
                const touchElements = document.querySelectorAll('button, .btn, .nav-item, .stat-card, .item, .quick-nav-btn');

                touchElements.forEach(element => {
                    element.addEventListener('touchstart', function () {
                        this.style.transform = 'scale(0.98)';
                        this.style.transition = 'transform 0.1s ease';
                    });

                    element.addEventListener('touchend', function () {
                        this.style.transform = '';
                    });

                    element.addEventListener('touchcancel', function () {
                        this.style.transform = '';
                    });
                });
            }

            // Prevent zoom on double tap
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);

            // Initialize mobile features
            document.addEventListener('DOMContentLoaded', function () {
                addTouchFeedback();
                try { attemptSilentCredentialSignIn(); } catch (e) { }
                if (!currentUser) {
                    try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                }

                // Ensure apple-touch-icon hrefs are absolute for iOS launchers
                try {
                    const origin = window.location.origin || '';
                    document.querySelectorAll('link[rel="apple-touch-icon"], link[rel="apple-touch-icon-precomposed"]').forEach(link => {
                        const href = link.getAttribute('href') || '';
                        if (href && !href.startsWith('http') && origin) {
                            link.setAttribute('href', origin.replace(/\/$/, '') + '/' + href.replace(/^\//, ''));
                        }
                    });
                } catch { }

                window.addEventListener('orientationchange', function () {
                    setTimeout(() => {
                        window.scrollTo(0, 1);
                    }, 500);
                });

                document.addEventListener('visibilitychange', function () {
                    if (document.visibilityState === 'visible') {
                        console.log('App became visible');
                    }
                });
            });

            // Expose functions globally for debugging
            window.mobileApp = {
                installApp,
                addTouchFeedback
            };
        })();

    </script>
</body>

</html>